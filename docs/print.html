<!DOCTYPE HTML>
<html lang="fr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
            <link rel="stylesheet" href="glightbox/dist/css/glightbox.min.css" />
           <script src="glightbox/dist/js/glightbox.min.js"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Électricité</li><li class="chapter-item expanded "><a href="electricite.html"><strong aria-hidden="true">1.</strong> Courant et alimentation</a></li><li class="chapter-item expanded "><a href="grandeurs_electriques.html"><strong aria-hidden="true">2.</strong> Grandeurs électriques</a></li><li class="chapter-item expanded "><a href="schemas_circuit.html"><strong aria-hidden="true">3.</strong> Schémas de circuit</a></li><li class="chapter-item expanded affix "><li class="part-title">Électronique</li><li class="chapter-item expanded "><a href="platine_experimentation.html"><strong aria-hidden="true">4.</strong> Platine d'expérimentation</a></li><li class="chapter-item expanded "><a href="erreurs_fatales.html"><strong aria-hidden="true">5.</strong> Erreurs fatales</a></li><li class="chapter-item expanded "><a href="del.html"><strong aria-hidden="true">6.</strong> DEL</a></li><li class="chapter-item expanded "><a href="resistance.html"><strong aria-hidden="true">7.</strong> Résistance</a></li><li class="chapter-item expanded "><a href="alimenter_del.html"><strong aria-hidden="true">8.</strong> Alimenter une DEL</a></li><li class="chapter-item expanded "><a href="micro-soudure.html"><strong aria-hidden="true">9.</strong> Micro-soudure</a></li><li class="chapter-item expanded "><a href="multimetre.html"><strong aria-hidden="true">10.</strong> Multimètre</a></li><li class="chapter-item expanded affix "><li class="part-title">Arduino</li><li class="chapter-item expanded "><a href="arduino_cartes.html"><strong aria-hidden="true">11.</strong> Modèles de cartes</a></li><li class="chapter-item expanded "><a href="arduino_nano.html"><strong aria-hidden="true">12.</strong> Arduino Nano</a></li><li class="chapter-item expanded "><a href="arduino_port.html"><strong aria-hidden="true">13.</strong> Identifier le port de la carte</a></li><li class="chapter-item expanded "><a href="arduino-ide_test_blink.html"><strong aria-hidden="true">14.</strong> Blink: le code test universel</a></li><li class="chapter-item expanded "><a href="arduino_code.html"><strong aria-hidden="true">15.</strong> Le code Arduino</a></li><li class="chapter-item expanded affix "><li class="part-title">Bases de la communication</li><li class="chapter-item expanded "><a href="arduino_deboguer.html"><strong aria-hidden="true">16.</strong> Déboguage série ASCII</a></li><li class="chapter-item expanded "><a href="arduino_millis.html"><strong aria-hidden="true">17.</strong> Mesurer le temps</a></li><li class="chapter-item expanded affix "><li class="part-title">Les sorties numériques</li><li class="chapter-item expanded "><a href="sortie_numerique/sortie_numerique.html"><strong aria-hidden="true">18.</strong> Sortie numérique</a></li><li class="chapter-item expanded "><a href="arduino_exemple_del.html"><strong aria-hidden="true">19.</strong> Contrôler une DEL</a></li><li class="chapter-item expanded affix "><li class="part-title">Les entrées numériques</li><li class="chapter-item expanded "><a href="entree_numerique/entree_numerique.html"><strong aria-hidden="true">20.</strong> Entrée numérique</a></li><li class="chapter-item expanded "><a href="interrupteur.html"><strong aria-hidden="true">21.</strong> Interrupteur</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bouton_poussoir.html"><strong aria-hidden="true">21.1.</strong> Bouton poussoir</a></li><li class="chapter-item expanded "><a href="bouton_arcade.html"><strong aria-hidden="true">21.2.</strong> Bouton d'arcade</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.3.</strong> Élimination du rebondissement</div></li></ol></li><li class="chapter-item expanded "><a href="controle_sortie_num_par_entree_num.html"><strong aria-hidden="true">22.</strong> Exemples</a></li><li class="chapter-item expanded affix "><li class="part-title">Optimiser la communication</li><li class="chapter-item expanded "><a href="intervalle.html"><strong aria-hidden="true">23.</strong> Intervalle de temps</a></li><li class="chapter-item expanded "><a href="changement.html"><strong aria-hidden="true">24.</strong> Changement de valeur</a></li><li class="chapter-item expanded "><a href="envoie_valeur.html"><strong aria-hidden="true">25.</strong> Envoi optimal de valeur</a></li><li class="chapter-item expanded affix "><li class="part-title">Les entrées analogiques</li><li class="chapter-item expanded "><a href="entree_analogique/entree_analogique.html"><strong aria-hidden="true">26.</strong> Entrée analogique</a></li><li class="chapter-item expanded "><a href="potentiometre/potentiometre.html"><strong aria-hidden="true">27.</strong> Potentiomètre</a></li><li class="chapter-item expanded "><a href="photoresistance/photoresistance.html"><strong aria-hidden="true">28.</strong> Photorésistance</a></li><li class="chapter-item expanded "><a href="controle_sortie_par_entree_analogique.html"><strong aria-hidden="true">29.</strong> Exemples</a></li><li class="chapter-item expanded affix "><li class="part-title">Communication OSC</li><li class="chapter-item expanded "><a href="osc/osc.html"><strong aria-hidden="true">30.</strong> Open Sound Control (OSC)</a></li><li class="chapter-item expanded "><a href="microosc/microosc.html"><strong aria-hidden="true">31.</strong> MicroOsc</a></li><li class="chapter-item expanded affix "><li class="part-title">OSC SLIP</li><li class="chapter-item expanded "><a href="osc_slip/osc_slip.html"><strong aria-hidden="true">32.</strong> OSC SLIP avec MicroOsc</a></li><li class="chapter-item expanded "><a href="pd/osc_slip.html"><strong aria-hidden="true">33.</strong> OSC SLIP avec Pure Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pd/relais_osc_slip_udp.html"><strong aria-hidden="true">33.1.</strong> Relais OSC UDP avec PD</a></li><li class="chapter-item expanded "><a href="pd/relais_osc_slip_midi.html"><strong aria-hidden="true">33.2.</strong> Relais MIDI avec PD</a></li></ol></li><li class="chapter-item expanded "><a href="max/max_osc_slip.html"><strong aria-hidden="true">34.</strong> OSC SLIP avec Max</a></li><li class="chapter-item expanded "><a href="osc_slip_web/osc_slip_web.html"><strong aria-hidden="true">35.</strong> OSC SLIP Web</a></li><li class="chapter-item expanded affix "><li class="part-title">OSC UDP</li><li class="chapter-item expanded "><div><strong aria-hidden="true">36.</strong> OSC UDP avec MicroOsc</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.</strong> OSC UDP: Pure Data</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">38.</strong> OSC UDP: Cycling '74 Max</div></li><li class="chapter-item expanded "><a href="vcv_rack/vcv_rack_osc.html"><strong aria-hidden="true">39.</strong> OSC UDP: VCV Rack</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">40.</strong> OSC UDP: Unity</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">41.</strong> OSC UDP: TouchDesigner</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">42.</strong> OSC UDP: Web</div></li><li class="chapter-item expanded affix "><li class="part-title">Les sorties analogiques</li><li class="chapter-item expanded "><a href="sortie_analogique/sortie_analogique.html"><strong aria-hidden="true">43.</strong> Sortie analogique</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">44.</strong> Exemples</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="chandelle/chandelle.html"><strong aria-hidden="true">44.1.</strong> Chandelle</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Les bandes de DEL</li><li class="chapter-item expanded "><a href="bande_del/bande_del.html"><strong aria-hidden="true">45.</strong> Bande de DEL</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">46.</strong> Exemples</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="pong_1d/pong_1d.html"><strong aria-hidden="true">46.1.</strong> Pong 1D</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">47.</strong> Contrôler une bande de DEL par OSC</div></li><li class="chapter-item expanded affix "><li class="part-title">Déploiement</li><li class="chapter-item expanded "><div><strong aria-hidden="true">48.</strong> Raspberry PI</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ressource-éducative-libre-rel-sur-lintégration-de-lélectronique-aux-espaces-immersifs"><a class="header" href="#ressource-éducative-libre-rel-sur-lintégration-de-lélectronique-aux-espaces-immersifs">Ressource éducative libre (REL) sur l'intégration de l'électronique aux espaces immersifs</a></h1>
<p>Ce projet a été initié en 2022 par Thomas Ouellet Fredericks avec la collaboration de Guillaume Arseneault.</p>
<p>Sa réalisation a été rendue possible grâce à un financement de la <a href="https://fabriquerel.org/rel/">fabrique REL</a>.</p>
<h3 id="licence"><a class="header" href="#licence">Licence</a></h3>
<p><a href="https://tim-montmorency.com/rel-electro-immersif/">Ressource éducative libre (REL) sur l'intégration de l'électronique aux espaces immersifs</a>, sous la responsabilité de <a href="http://t-o-f.info">Thomas O Fredericks</a>, est partagée sous la licence <a href="creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1">Attribution - Pas d’Utilisation Commerciale 4.0</a>
<img src="./cc_by_nc.png" alt="CC BY NC" /></p>
<h2 id="rel-vivante"><a class="header" href="#rel-vivante">REL vivante</a></h2>
<p>Ce site Web est une ressource éducative libre <strong>vivante</strong>. C'est à dire qu'elle a été conçue pour grandir et évoluer de façon continue.</p>
<h2 id="conventions-de-documentation"><a class="header" href="#conventions-de-documentation">Conventions de documentation</a></h2>
<p>Les noms de variables qui sont destinées à être créées par l'utilisateur doivent être précédés de <em>mon</em> ou <em>ma</em> pour les différencier des noms réservés du langange de programmation.</p>
<p>Exemples :</p>
<pre><code class="language-arduino">int maBrocheDel = 10;
</code></pre>
<pre><code class="language-arduino">void monTraiterMessage( microOscMessage monMessageOsc ) {
	...
}
</code></pre>
<pre><code class="language-arduino">MicroOsc monMicroOsc;
</code></pre>
<h2 id="références"><a class="header" href="#références">Références</a></h2>
<ul>
<li>SparkFun</li>
<li><a href="./pdf/arduino_a_l_ecole-2022.pdf">Arduino à l'école 2022 (PDF)</a></li>
<li><a href="https://eskimon.fr/">Le blog d'Eskimon</a></li>
<li><a href="https://zestedesavoir.com/tutoriels/686/arduino-premiers-pas-en-informatique-embarquee/">Arduino : premiers pas en informatique embarquée • Tutoriels • Zeste de Savoir</a></li>
<li><a href="./pdf/bd_soudure.pdf">SOUDER C'EST FACILE (PDF)</a></li>
<li><a href="./pdf/16hz_the_illustrated_arduino.pdf">The Illustrated Arduino de 16Hz (PDF)</a></li>
</ul>
<h2 id="technologies-utilisées-pour-la-réalisation-de-cette-ressource"><a class="header" href="#technologies-utilisées-pour-la-réalisation-de-cette-ressource">Technologies utilisées pour la réalisation de cette ressource</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/mdBook/">mdBook</a> pour convertir les textes du format Markdown au format HTML.</li>
<li><a href="https://docs.github.com/en/actions">GitHub Actions</a> pour automatiser le déploiement des fichiers sources au site <a href="https://tim-montmorency.com/rel-electro-immersif/">tim-montmorency.com/rel-electro-immersif</a>.</li>
<li>Du JavaScript sur mesure pour ajouter automatiquement la description des figures sous celles-ci.</li>
<li><a href="https://github.com/biati-digital/glightbox">GLightbox</a> pour permettre l'intégration de la lecture des vidéos directement dans le site.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="le-courant-électrique"><a class="header" href="#le-courant-électrique">Le courant électrique</a></h1>
<p>Le courant électrique est un déplacement d’électrons dans un milieu conducteur.</p>
<p>Pour que ces électrons se déplacent il faut créer <strong>une différence du nombre d'électrons entre les deux extrémités du circuit électrique</strong>. C'est ce qu'on appelle une <strong>différence de potentiel</strong>.</p>
<h1 id="alimentation"><a class="header" href="#alimentation">Alimentation</a></h1>
<p>Pour créer cette différence de potentiel, on utilise une <strong>alimentation électrique</strong> qui peut prendre la forme d'une batterie, alimentation USB, panneau solaire, prise électrique , etc.</p>
<p><img src="batterie_aa_electrons.svg" alt="Illustration du débalancement des électrons dans une batterie AA" /></p>
<p>Une alimentation possède deux pôles. L'un <strong>positif</strong> (avec un potentiel <em>haut</em>) et l'autre <strong>négatif</strong> (avec un potentiel <em>bas</em>). </p>
<p><img src="alimentation_12v.svg" alt="Le câble et le connecteur de cette alimentation regroupe deux pôles" /></p>
<h1 id="boucle-électrique"><a class="header" href="#boucle-électrique">Boucle électrique</a></h1>
<p>Pour circuler, le courant doit suivre une boucle entre les deux pôles de l'alimentation.</p>
<p><img src="circuit_electrons.svg" alt="Les électrons voyagent en se tirant les uns derrières les autres comme les wagons d'un train" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="principales-grandeurs-électriques"><a class="header" href="#principales-grandeurs-électriques">Principales grandeurs électriques</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Grandeur</th><th>Symbole</th><th>Unité</th><th>Analogie</th></tr></thead><tbody>
<tr><td>Tension</td><td>U</td><td>Volts (V)</td><td>La <em>pression</em> qui génère la circulation des électrons</td></tr>
<tr><td>Intensité</td><td>I</td><td>Ampères (A)</td><td>La <em>quantité d’électrons</em> qui circule à un point</td></tr>
<tr><td>Résistance</td><td>R</td><td>Ohms (Ω)</td><td>Réduit la circulation des électrons (réduit la pression et la quantité)</td></tr>
<tr><td>Puissance</td><td>P</td><td>Watts (W)</td><td>La puissance résultant de la <em>pression</em> multipliée par la <em>quantité</em></td></tr>
</tbody></table>
</div>
<h1 id="analogie-de-leau"><a class="header" href="#analogie-de-leau">Analogie de l'eau</a></h1>
<h2 id="pression-de-leau--tension-électrique"><a class="header" href="#pression-de-leau--tension-électrique">Pression de l'eau ≈ tension électrique</a></h2>
<p><img src="analogie_eau_tension.svg" alt="La pression de l'eau est similaire à la tension électrique" /></p>
<h2 id="quantité-deau--intensité-électrique"><a class="header" href="#quantité-deau--intensité-électrique">Quantité d'eau ≈ intensité électrique</a></h2>
<p><img src="analogie_eau_intensite.svg" alt="La quantité d'eau est similaire à l'intensité électrique" /></p>
<h2 id="Étranglement-de-tuyau--intensité-électrique"><a class="header" href="#Étranglement-de-tuyau--intensité-électrique">Étranglement de tuyau ≈ intensité électrique</a></h2>
<p><img src="analogie_eau_resistance.svg" alt="Un étranglement dans le tuyau est similaire à l'intensité électrique" /></p>
<h1 id="relations-mathématiques-entre-les-principales-grandeurs-électriques"><a class="header" href="#relations-mathématiques-entre-les-principales-grandeurs-électriques">Relations mathématiques entre les principales grandeurs électriques</a></h1>
<p><img src="grandeurs_electriques_relations.svg" alt="Relations mathématiques entre les principales grandeurs électriques" /></p>
<h1 id="exemples"><a class="header" href="#exemples">Exemples</a></h1>
<p><img src="analogie_eau_exemple.svg" alt="Exemple des relations entre les principales grandeurs électriques" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schémas-de-circuit"><a class="header" href="#schémas-de-circuit">Schémas de circuit</a></h1>
<p>Un schéma de circuit est une représentation schématique de la connectique d’un circuit électrique. Les composants électriques sont représentés en tant que symboles pour faciliter leur reproduction et leur identification. Ce qui est important est de représenter comment les éléments sont reliés entre eux et non leur disposition exacte dans l’espace. </p>
<h2 id="symboles-dalimentation"><a class="header" href="#symboles-dalimentation">Symboles d'alimentation</a></h2>
<h3 id="un-symbole-qui-regroupent-les-deux-pôles"><a class="header" href="#un-symbole-qui-regroupent-les-deux-pôles">Un symbole qui regroupent les deux pôles</a></h3>
<p><img src="schemas_circuits/symbole_alimentation_batterie.svg" alt="Un symbole représentant une batterie" /></p>
<p><img src="schemas_circuits/symbole_alimentation_cc.svg" alt="Un symbole représentant une alimentation à courant continu" /></p>
<h3 id="deux-symboles-séparés-qui-représentent-les-deux-pôles-de-la-même-alimentation"><a class="header" href="#deux-symboles-séparés-qui-représentent-les-deux-pôles-de-la-même-alimentation">Deux symboles séparés qui représentent les deux pôles de la même alimentation</a></h3>
<p><img src="schemas_circuits/symbole_alimentation_paire_v+.svg" alt="Une paire de symboles qui représente les deux pôles d'une même alimentation générique" /></p>
<p><img src="schemas_circuits/symbole_alimentation_paire_5v.svg" alt="Une paire de symboles qui représente les deux pôles d'une même alimentation 5V" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platine-dexpérimentation-breadboard"><a class="header" href="#platine-dexpérimentation-breadboard">Platine d'expérimentation (<em>breadboard</em>)</a></h1>
<p>Une platine d’expérimentation (<em>breadboard</em> en anglais) permet de réaliser des prototypes de circuits électroniques sans soudure et donc de pouvoir réutiliser les composants.</p>
<p><img src="platine_experimentation/allumer_del_arduino_sans_platine.svg" alt="L'utilisation de la platine d'expérimentation pour tester des circuits" /></p>
<p>À gauche, dans l'image ci-haut, nous trouvons le circuit électrique pour allumer une lumière DEL à partir de la carte Arduino. Par contre, il est impossible de relier les composants sans faire de soudure. C’est pour cela que nous utilisons la platine d’expérimentation. </p>
<h2 id="connexions"><a class="header" href="#connexions">Connexions</a></h2>
<p>Certains des trous de la platine d'expérimentation sont connectés entre eux. Ces connexions sont indiquées par des lignes dans l'illustration suivante.</p>
<p><img src="platine_experimentation/platine_experimentation_connexions_internes.svg" alt="Connexions internes de la paltine d'expérimentation" /></p>
<ul>
<li>Tous les trous dans une rangée intérieure de 5 sont reliés entre eux. </li>
<li>Les trous des colonnes extérieures sont reliés entre eux. Ils sont réservés à l'alimentation :
<ul>
<li>Colonne rouge pour le pôle positif (+).</li>
<li>Colonne bleue pour le pôle négatif (-).</li>
</ul>
</li>
</ul>
<h2 id="bien-placer-les-composants-sur-la-platine-dexpérimentation"><a class="header" href="#bien-placer-les-composants-sur-la-platine-dexpérimentation">Bien placer les composants sur la platine d'expérimentation</a></h2>
<p>Les broches (pattes) des composants doivent être insérés dans des trous qui sont <strong>non reliés électriquement</strong>, c'est à dire <strong>isolée</strong> électriquement. </p>
<p>Dans la figure suivante :</p>
<ul>
<li>Le <strong>X</strong> indique une erreur où un composant dont les broches sont insérées dans des trous reliés électriquement.</li>
<li>Les <strong>✓</strong> indiquent des bonnes connexions où chaque broche du composant est isolé électriquement. </li>
</ul>
<p><img src="platine_experimentation/platine_experimentation_connexions_valides_del.svg" alt="Exemples de connexions valides d'une DEL" /></p>
<p>Dans la figure suivante :</p>
<ul>
<li>Le <strong>X</strong> indique une erreur où un composant dont les broches sont insérées dans des trous reliés électriquement.</li>
<li>Les <strong>✓</strong> indiquent des bonnes connexions où chaque broche du composant est isolé électriquement. </li>
</ul>
<p><img src="platine_experimentation/platine_experimentation_connexions_valides_exemples.svg" alt="Exemples de connexions valides" /></p>
<h2 id="se-servir-dune-carte-arduino-pour-alimenter-une-platine-dexpérimentation"><a class="header" href="#se-servir-dune-carte-arduino-pour-alimenter-une-platine-dexpérimentation">Se servir d'une carte Arduino pour alimenter une platine d'expérimentation</a></h2>
<h3 id="pôles-de-la-carte-arduino-nano"><a class="header" href="#pôles-de-la-carte-arduino-nano">Pôles de la carte Arduino Nano</a></h3>
<p>Sur certains modèles de carte Arduino Nano, le pôle positif (+) n’est malheureusement pas imprimé sur la carte. Cependant, on retrouve dans la documentation des broche que c’est la broche au dessus de l'étiquette «RST». </p>
<p>Le pôle négatif (-) est indiqué avec l'étiquette «GND» imprimée sur la carte. </p>
<p><img src="platine_experimentation/arduino_nano_poles_alimentation.svg" alt="Pôles d'alimentation de la carte Arduino Nano" /></p>
<h3 id="Étape-1"><a class="header" href="#Étape-1">Étape 1</a></h3>
<p>Branchez un câble (orange ou rouge) dans la rangée de la broche du positif (+) de la carte Arduino. Ce câble transporte maintenant le positif (+).</p>
<p>Branchez un câble (brun ou noir) dans la rangée de la broche du négatif (-) de la carte Arduino. Ce câble transporte maintenant le négatif (-)</p>
<p><img src="platine_experimentation/alimentation_platine_experimentation_1.svg" alt="Étape 1 de l'alimentation de la platine d'expérimentation" /></p>
<h3 id="Étape-2"><a class="header" href="#Étape-2">Étape 2</a></h3>
<p>Brancher le câble qui transporte le positif (+) dans la colonne + rouge de la platine d’expérimentation.</p>
<p>Brancher le câble qui transporte le négatif (-) dans la conne – bleue de la platine d’expérimentation.</p>
<p><img src="platine_experimentation/alimentation_platine_experimentation_2.svg" alt="Étape 2 de l'alimentation de la platine d'expérimentation" /></p>
<h3 id="Étape-3"><a class="header" href="#Étape-3">Étape 3</a></h3>
<p>Reliez les deux autres colonnes de la patine d'expériementation.</p>
<p><img src="platine_experimentation/alimentation_platine_experimentation_3.svg" alt="Étape 3 de l'alimentation de la platine d'expérimentation" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erreur-fatale--court-circuit"><a class="header" href="#erreur-fatale--court-circuit">Erreur fatale : court circuit</a></h1>
<p>Ici le pôle positif (+) et le pôle négatif (-) sont connectés dans la même colonne d'alimentation! Cette erreur fatale risque d'endommager l'alimentation USB de l'ordinateur!</p>
<p><img src="erreur_fatale_1.SVG" alt="Erreur fatale : court circuit" /></p>
<h1 id="erreur-fatale--inverser-les-pôles--et--"><a class="header" href="#erreur-fatale--inverser-les-pôles--et--">Erreur fatale : inverser les pôles + et -</a></h1>
<p>Ici le pôle positif (+) et le pôle négatif (-) sont inversés! Cette erreur fatale risque de détruire tous les composants!</p>
<p><img src="erreur_fatale_2.SVG" alt="Erreur fatale : inverser les pôles + et -" /></p>
<h1 id="quoi-faire-en-cas-derreur-fatale"><a class="header" href="#quoi-faire-en-cas-derreur-fatale">Quoi faire en cas d'erreur fatale</a></h1>
<p><img src="erreur_fatale_quoi_faire.SVG" alt="Erreur fatale 3 : inverser les pôles + et -" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diode-électroluminescente-del"><a class="header" href="#diode-électroluminescente-del">Diode électroluminescente (DEL)</a></h1>
<p>La diode électroluminescente (DEL) est un <em>actionneur</em> qui transforme un signal électrique en lumière. Elle est appelée «LED» en anglais. </p>
<p>En utilisant divers matériaux semi-conducteurs, on fait varier la couleur de la lumière émise par la DEL. Il existe enfin une grande variété de formes de DEL.</p>
<p>Le courant électrique ne peut traverser la diode que dans le sens de l’anode vers la cathode.</p>
<p><img src="del/del.svg" alt="Une DEL" /></p>
<p>La DEL a deux pôles</p>
<ul>
<li>Anode : pôle positif</li>
<li>Cathode : pôle négatif</li>
</ul>
<p><img src="del/del_anode_cathode.svg" alt="Anode et cathode d'une DEL " /></p>
<h2 id="limiter-lintensité-du-courant"><a class="header" href="#limiter-lintensité-du-courant">Limiter l'intensité du courant</a></h2>
<p><strong>Attention</strong>: il faut limiter l'intensité du courant qui traverse la DEL. </p>
<p>Pour une DEL rouge standard:</p>
<ul>
<li>La DEL crée une chute de tension (<em>voltage drop</em>) d’environ 2.1 Volts.</li>
<li>L'intensité qui traverse la DEL doit être d'environ 0.02 Ampères (20 mA). </li>
<li>L’utilisation d’une résistance est obligatoire pour réduire l'intensité et ne pas griller la DEL.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="résistance"><a class="header" href="#résistance">Résistance</a></h1>
<p><img src="resistance/resistance_photo.svg" alt="Une resistance" /></p>
<p>Une résistance est un composant électrique dont la principale caractéristique est d'opposer une plus ou moins grande résistance mesurée en ohms (Ω) à la circulation du courant électrique.</p>
<p>Une résistance est un milieu peu conducteur; les électrons peinent à s’y déplacer. Leur énergie se dissipe alors en général sous forme de chaleur. C’est ce principe utilisé pour les bouilloires électriques ou les ampoules à filaments.
La valeur de la résistance se mesure en ohms (Ω) et elle est déterminée par ses bandes de couleurs.</p>
<p><img src="resistance/resistance_schema.svg" alt="Schéma européen à gauche et américan à droite d'une résistance" /></p>
<h1 id="calculer-la-valeur-dune-résistance"><a class="header" href="#calculer-la-valeur-dune-résistance">Calculer la valeur d’une résistance</a></h1>
<p>Pour connaître la valeur en ohms (Ω) d'une résitance, il faut convertir le code couleurs des 2 ou 3 premiers anneaux pour ensuite  multiplier par le code de l'anneau suivant. La tolérance, représentée par le dernier anneau correspond à l’imprécision de la valeur en ohms. Plus elle est petite, plus la résistance est de meilleur qualité.</p>
<p><img src="resistance/resistance_calcul_code_couleur.svg" alt="Schéma européen à gauche et américan à droite d'une résistance" /></p>
<p>Exemple : rouge (2), rouge(2), brun (x10) = 22 * 10 = 220 Ω = 0.22 kΩ</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alimenter-une-del-avec-une-batterie"><a class="header" href="#alimenter-une-del-avec-une-batterie">Alimenter une DEL avec une batterie</a></h1>
<p>Un schéma de circuit représente sous une forme plus précise les connexions des composants d’un circuit.</p>
<p>Le schéma et l’image ci-bas montrent tous les deux comment allumer une DEL avec une résistance et une batterie 9V. </p>
<p><img src="alimenter_del_avec_une_batterie.svg" alt="Schéma et image d'une DEL alimentée par une batterie" /></p>
<p><img src="alimenter_del/alimenter_del_batterie_9v.gif" alt="Animation de l'alimentation d'une DEL par une batterie" /></p>
<h2 id="identification-de-lalimentation"><a class="header" href="#identification-de-lalimentation">Identification de l'alimentation</a></h2>
<p><img src="alimenter_del_avec_une_batterie_alimentation.svg" alt="L'alimentation dans le schéma et l'image" /></p>
<h2 id="identification-de-la-résistance"><a class="header" href="#identification-de-la-résistance">Identification de la résistance</a></h2>
<p><img src="alimenter_del_avec_une_batterie_resistance.svg" alt="La résistance dans le schéma et l'image" /></p>
<h2 id="identitfication-de-la-del"><a class="header" href="#identitfication-de-la-del">Identitfication de la DEL</a></h2>
<p><img src="alimenter_del_avec_une_batterie_del.svg" alt="La DEL dans le schéma et l'image" /></p>
<h1 id="alimenter-une-del-avec-la-platine-dexpérimentation"><a class="header" href="#alimenter-une-del-avec-la-platine-dexpérimentation">Alimenter une DEL avec la platine d'expérimentation</a></h1>
<p>Portez attention à la longueur des pattes de la DEL. Une patte est plus longue que l’autre. Une DEL ne s’allume que si elle est branchée dans le bon sens. </p>
<p><img src="del_longueur_pattes.svg" alt="Anode, cathode et longueur des pattes" /></p>
<p><img src="alimenter_del/alimenter_del_schema.svg" alt="Circuit pour alimenter une DEL" /></p>
<p><img src="alimenter_del/alimenter_del_schema_avec_images.svg" alt="Identification des composantes" /></p>
<p><img src="alimenter_del/alimenter_del_circuit_bb.svg" alt="Une disposition possible sur la platine d'expérimentation" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="micro-soudure"><a class="header" href="#micro-soudure">Micro-soudure</a></h1>
<h2 id="Équipement-essentiel"><a class="header" href="#Équipement-essentiel">Équipement essentiel</a></h2>
<p><img src="./micro-soudure/micro-soudure_fer.svg" alt="Fer à souder" /></p>
<p><img src="./micro-soudure/micro-soudure_bobine.svg" alt="Bobine de soudure d'étain" /></p>
<p><img src="./micro-soudure/micro-soudure_nettoyeur_pointe.svg" alt="Nettoyeur de pointe" /></p>
<p><img src="./micro-soudure/micro-soudure_pompe.svg" alt="Pompe à dessouder" /></p>
<p><img src="./micro-soudure/micro-soudure_pince_denuder.svg" alt="Pince à dénuder" /></p>
<p><img src="./micro-soudure/micro-soudure_pince_laterale.svg" alt="Pince à couper latérale de précision" /></p>
<p><img src="./micro-soudure/micro-soudure_pince_long_bec.svg" alt="Pince à long bec" /></p>
<h2 id="tutoriels"><a class="header" href="#tutoriels">Tutoriels</a></h2>
<ul>
<li><a href="./pdf/bd_soudure.pdf">Tutoriel sous form de bande dessinée: SOUDER C'EST FACILE</a></li>
<li><a href="https://vimeo.com/481700117/fe056befd2">Vidéo d'introduction sur la soudure par KidzLab</a></li>
</ul>
<h3 id="résumé-de-la-technique-de-pointe"><a class="header" href="#résumé-de-la-technique-de-pointe">Résumé de la technique de pointe</a></h3>
<p><img src="./micro-soudure/micro-soudure_technique.svg" alt="Résumé de la technique pour la micro-soudure" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multimètre"><a class="header" href="#multimètre">Multimètre</a></h1>
<h2 id="mesure-de-continuité"><a class="header" href="#mesure-de-continuité">Mesure de continuité</a></h2>
<ul>
<li><a href="https://learn.sparkfun.com/tutorials/how-to-use-a-multimeter/all#continuity">Mesurer la continuité avec un multimètre</a></li>
</ul>
<h2 id="mesure-de-résistance"><a class="header" href="#mesure-de-résistance">Mesure de résistance</a></h2>
<ul>
<li><a href="https://learn.sparkfun.com/tutorials/how-to-use-a-multimeter/all#measuring-resistance">Mesurer la résistance avec un multimètre</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modèles-de-cartes"><a class="header" href="#modèles-de-cartes">Modèles de cartes</a></h1>
<p><a href="https://makezine.com/comparison/boards"><img src="./arduino/cartes_modeles.svg" alt="Make: Boards Guide" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arduino-nano"><a class="header" href="#arduino-nano">Arduino Nano</a></h1>
<h2 id="broches"><a class="header" href="#broches">Broches</a></h2>
<p><img src="arduino_nano/arduino_nano_broches.svg" alt="Brancher la carte à l’ordinateur et choisir le port trouvé à l’étape précédent" /></p>
<h2 id="installer-le-pilote-de-la-carte-arduino-nano"><a class="header" href="#installer-le-pilote-de-la-carte-arduino-nano">Installer le pilote de la carte Arduino Nano</a></h2>
<ul>
<li><a href="https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all">Sparkfun : How to Install CH340 Drivers</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="identifier-le-port-de-la-carte"><a class="header" href="#identifier-le-port-de-la-carte">Identifier le port de la carte</a></h1>
<h1 id="identifier-le-port-de-la-carte-arduino-nano"><a class="header" href="#identifier-le-port-de-la-carte-arduino-nano">Identifier le port de la carte Arduino Nano</a></h1>
<p><img src="arduino-ide_configuration_nano/Slide1.SVG" alt="Procédure pour identifier le port de la carte Arduino" /></p>
<h1 id="configurer-le-logiciel-arduino-pour-la-carte-arduino-nano"><a class="header" href="#configurer-le-logiciel-arduino-pour-la-carte-arduino-nano">Configurer le logiciel Arduino pour la carte Arduino Nano</a></h1>
<p><img src="arduino-ide_configuration_nano/configuration1.svg" alt="Brancher la carte à l’ordinateur et choisir le port trouvé à l’étape précédent" /></p>
<p><img src="arduino-ide_configuration_nano/configuration2.svg" alt="Choisir le modèle de carte «Arduino Nano»" /></p>
<p><img src="arduino-ide_configuration_nano/configuration3.svg" alt="Choisir le vieux Bootloader" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blink-le-code-test-universel"><a class="header" href="#blink-le-code-test-universel">Blink: le code test universel</a></h1>
<p><img src="arduino-ide_test_blink/Slide1.SVG" alt="..." /></p>
<p><img src="arduino-ide_test_blink/Slide2.SVG" alt="..." /></p>
<p><img src="arduino-ide_test_blink/Slide3.SVG" alt="..." /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="le-code-arduino"><a class="header" href="#le-code-arduino">Le code Arduino</a></h1>
<h2 id="références-1"><a class="header" href="#références-1">Références</a></h2>
<ul>
<li><a href="https://www.arduino.cc/reference/en/">Référence Arduino sur Arduino.cc</a></li>
<li><a href="./pdf/arduino_programming_notebook-bryan_w_evans.pdf">Arduino Programming Notebook de Bryan W Evans (2017) en version PDF</a></li>
</ul>
<h2 id="code-minimal"><a class="header" href="#code-minimal">Code minimal</a></h2>
<pre><code class="language-arduino">
// VARIABLE GLOBALES

void setup() {
  // CODE À ROULER AU DÉMARRAGE

}

void loop() {
  // CODE À RÉPÉTER (LE PLUS RAPIDEMENT POSSIBLE)

}
</code></pre>
<p>Nous retrouvons deux fonctions dans le code minimal :</p>
<ul>
<li>setup()</li>
<li>loop()</li>
</ul>
<h3 id="setup"><a class="header" href="#setup">setup()</a></h3>
<p>La fonction setup() est appelée une seule fois lorsque le programme commence. C'est pourquoi c'est dans cette fonction que l'on va écrire le code qui n'a besoin d'être exécuté qu’une seule fois. C'est une  fonction d'initialisation. On y retrouvera la mise en place des différentes sorties et quelques autres réglages.</p>
<h3 id="loop"><a class="header" href="#loop">loop()</a></h3>
<p>Une fois que l'on a initialisé le programme, il faut ensuite créer le «cœur» du programme, autrement dit le programme en lui même. C'est dans la fonction loop() que l’on va écrire le contenu du programme. Il faut savoir que cettefonction est appelée en permanence, c'est-à-dire qu'elle est exécutée une fois, puis lorsque son exécution est terminée, on la réexécute, encore et encore. On parle de boucle infinie!</p>
<h2 id="déroulement-du-programme"><a class="header" href="#déroulement-du-programme">Déroulement du programme</a></h2>
<p><img src="arduino_code/Slide1.SVG" alt="..." /></p>
<h2 id="les-instructions"><a class="header" href="#les-instructions">Les instructions</a></h2>
<p><img src="arduino_code/Slide3.SVG" alt="..." /></p>
<h2 id="variables-de-base"><a class="header" href="#variables-de-base">Variables de base</a></h2>
<p><img src="arduino_code/Slide4.SVG" alt="..." /></p>
<h2 id="analyse-du-code-blink"><a class="header" href="#analyse-du-code-blink">Analyse du code «Blink»</a></h2>
<p><img src="arduino_code/Slide5.SVG" alt="..." /></p>
<h2 id="ressources"><a class="header" href="#ressources">Ressources</a></h2>
<ul>
<li><a href="https://fr.flossmanuals.net/arduino/programmer-arduino/">FLOSS Manuals: Programmer-Arduino / Arduino</a></li>
</ul>
<h2 id="bien-coder"><a class="header" href="#bien-coder">Bien coder</a></h2>
<p><a href="https://fr.flossmanuals.net/arduino/comment-bien-structurer-son-code/">FLOSS Manuals: Comment-Bien-Structurer-Son-Code / Arduino</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="déboguer"><a class="header" href="#déboguer">Déboguer</a></h1>
<h2 id="ouvrir-et-configurer-le-moniteur-série"><a class="header" href="#ouvrir-et-configurer-le-moniteur-série">Ouvrir et configurer le moniteur série</a></h2>
<p><img src="arduino_deboguer/arduino_serie_ouvrir.svg" alt="Ouvrir et configurer le moniteur série" /></p>
<h2 id="fonctions-pour-déboguer-avec-serial"><a class="header" href="#fonctions-pour-déboguer-avec-serial">Fonctions pour déboguer avec Serial</a></h2>
<p><img src="arduino_deboguer/arduino_serie_fonctions.svg" alt="Fonctions pour déboguer avec Serial" /></p>
<h2 id="exemple-denvoi-dun-message"><a class="header" href="#exemple-denvoi-dun-message">Exemple d'envoi d'un message</a></h2>
<p><img src="arduino_deboguer/arduino_serie_allo.svg" alt="Envoi du message «Allo»" /></p>
<h2 id="le-code-ascii-utilisé-pour-le-débogage"><a class="header" href="#le-code-ascii-utilisé-pour-le-débogage">Le code ASCII utilisé pour le débogage</a></h2>
<p><img src="arduino_deboguer/arduino_serie_ascii.svg" alt="Le code ASCII " /></p>
<h2 id="exemple--envoyer-continuellement-la-valeur-dune-entrée-numérique"><a class="header" href="#exemple--envoyer-continuellement-la-valeur-dune-entrée-numérique">Exemple : envoyer continuellement la valeur d'une entrée numérique</a></h2>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 4;

void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'INTERRUPTEUR EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE
  int maValeurInterrupteur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION

  Serial.print( maValeurInterrupteur ); // ENVOYER LA VALEUR
  Serial.println();  // TERMINER LE MESSAGE
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesurer-le-temps-avec-millis"><a class="header" href="#mesurer-le-temps-avec-millis">Mesurer le temps avec millis()</a></h1>
<p>La fonction millis() permet de résoudre ce problème. Elle retourne le temps en millisecondes depuis le début de démarrage de votre Arduino. </p>
<p>Jusqu'à présent, vous avez déclaré des variables comme étant des int. Un int est un nombre de 16 bits, il contient des valeurs comprises entre -32 768 et 32 767. Si l'Arduino compte en millisecondes, vous manquerez d'espace en moins d'une minute. </p>
<p>Le type de données long peut contenir un nombre de 32 bits (entre -2 147 483 648 et 2 147 483 647). Comme vous ne pouvez pas exécuter le temps à rebours pour obtenir des nombres négatifs, nous utiliser le type unsigned long pour stocker le temps. Lorsqu'un type de données est appelé non signé, il est que positif. Cela vous permet de compter avec des valeurs encore plus grandes. Un unsigned long peut compter jusqu'à 4 294 967 295. C’est assez d’espace pour stocker le temps pendant près de 50 jours. En comparant le millis() actuel à une valeur spécifique, vous pouvez voir si un certain temps s'est écoulé.</p>
<p>Déclarer un variable pour récupérer le temps:</p>
<pre><code class="language-cpp">unsigned long tempsEcoule;
</code></pre>
<p>Mettre le temps dans la variable <code>tempsEcoule</code>:</p>
<pre><code class="language-cpp">tempsEcoule = millis();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sortie-numérique"><a class="header" href="#sortie-numérique">Sortie numérique</a></h1>
<p>Il est possible de régler la tension présente à la plupart des broches de la carte Arduino. </p>
<p>Cette tension peut être réglée à deux niveaux :</p>
<ul>
<li><code>HIGH</code> : règle la tension de sortie à 5V (pôle positif)</li>
<li><code>LOW</code> : règle la tension de sortie à 0V (pôle négatif/GND)</li>
</ul>
<p>Pour régler la tension électrique de sortie d'une broche, nous utilisons la paire de fonctions suivantes :</p>
<ol>
<li>Configurer la broche <code>numeroBoche</code> en mode sortie avec <code>OUTPUT</code> :</li>
</ol>
<pre><code class="language-arduino">pinMode( numeroBoche , OUTPUT );
</code></pre>
<ol start="2">
<li>Régler la tension avec l’une des commandes suivantes :
Pour règler la tension de sortie à 5V (pôle positif)</li>
</ol>
<pre><code class="language-cpp">digitalWrite( numeroBoche, HIGH );
</code></pre>
<p>Pour règler la tension de sortie à 0V (pôle négatif/GND)</p>
<pre><code class="language-cpp">digitalWrite( numeroBoche, LOW );
</code></pre>
<h2 id="debogage-dune-sortie-numérique"><a class="header" href="#debogage-dune-sortie-numérique">Debogage d'une sortie numérique</a></h2>
<p>Dans le code suivant, nous déboguons la sortie numérique 13 : </p>
<pre><code class="language-arduino">int maBroche = 13;
int maValeur = LOW ; // VALEUR DÉSIRÉE DE LA SORTIE NUMÉRIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(115200); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBroche , OUTPUT); // CONFIGURER LA BROCHE EN SORTIE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 250; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 250 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...

    // ALTERNER LA VALEUR DÉSIRÉE DE LA SORTIE NUMÉRIQUE 
    if ( maValeur == LOW ) maValeur = HIGH; // SI LOW, METTRE À HIGH
    else maValeur = LOW; // SINON, METTRE À LOW

    // APLLIQUER LA VALEUR DÉSIRÉE À LA SORTIE NUMÉRIQUE
    digitalWrite( maBroche , maValeur );
    
    Serial.print( &quot;Envoi sur la broche &quot; ); // ENVOYER UNE EN-TÊTE DE MESSAGE
    Serial.print( maBroche ); // ENVOYER LE NUMÉRO DE LA BROCHE
    Serial.print( &quot; de la valeur (0=LOW, 1=HIGH) : &quot; ); // ENVOYER UN SÉPARATEUR ENTRE LE NUMÉRO DE LA BROCHE ET SA VALEUR
    Serial.print( maValeur ); // ENVOYER LA VALEUR
    Serial.println();  // TERMINER LE MESSAGE


  }
}
</code></pre>
<p><img src="sortie_numerique/./debogage_sortie_numerique_moniteur_serie.png" alt="Résultat du débogage de la sortie numérique dans le moniteur série" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contrôler-une-del"><a class="header" href="#contrôler-une-del">Contrôler une DEL</a></h1>
<p><img src="arduino_exemple_del/arduino_allumer_del_resume.svg" alt="Fiche synthèse pour allumer une DEL" /></p>
<h2 id="segment-de-circuit"><a class="header" href="#segment-de-circuit">Segment de circuit</a></h2>
<p><img src="arduino_exemple_del/Slide1.SVG" alt="Segment de circuit pour contrôler une DEL" /></p>
<h2 id="circuit-complet"><a class="header" href="#circuit-complet">Circuit complet</a></h2>
<p><img src="arduino_exemple_del/Slide2.SVG" alt="Circuit complet pour contrôler une DEL" /></p>
<h3 id="comparaison-avec-le-circuit-dalimentation-simple"><a class="header" href="#comparaison-avec-le-circuit-dalimentation-simple">Comparaison avec le circuit d'alimentation simple</a></h3>
<p><img src="arduino_exemple_del/Slide3.SVG" alt="Comparaison du circuit d'alimentation simple à gauche avec celui de contrôle à droite" /></p>
<h2 id="fonctions-pertinentes"><a class="header" href="#fonctions-pertinentes">Fonctions pertinentes</a></h2>
<p><img src="arduino_code/pinModeOutput.svg" alt="Configuer la broche # en tant que sortie numérique" /></p>
<p><img src="arduino_code/digitalWriteHigh.svg" alt="Activer 5V à la broche #" /></p>
<p><img src="arduino_code/digitalWriteLow.svg" alt="Activer 0V à la broche #" /></p>
<h2 id="fonction-additionnelle"><a class="header" href="#fonction-additionnelle">Fonction additionnelle</a></h2>
<p><img src="arduino_code/delay.svg" alt="Bloquer/Arrêter le code pour un certains nombre de millisecondes" /></p>
<h2 id="code-complet"><a class="header" href="#code-complet">Code complet</a></h2>
<pre><code class="language-cpp">const int sortieNumeriqueDel = 3;

void setup() {
  pinMode(sortieNumeriqueDel, OUTPUT);
}

void loop() {
  digitalWrite(sortieNumeriqueDel, HIGH);  
  delay(1000);               
  digitalWrite(sortieNumeriqueDel, LOW);    
  delay(1000);              
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrée-numérique"><a class="header" href="#entrée-numérique">Entrée numérique</a></h1>
<p>Jusqu'à maintenant, nous avons traité des sorties (<code>OUTPUT</code>). Grâce à la commande <code>digitalWrite()</code> on peut contrôler la tension électrique d'un broche :</p>
<ul>
<li>haute tension : <code>HIGH</code></li>
<li>basse tension : <code>LOW</code> </li>
</ul>
<p>Nous avons utilisé jusqu’ici cette différence de potentiel pour allumer des DEL.</p>
<p>Si une broche est configurée en entrée (<code>INPUT</code>), nous pouvons effectuer la mesure numérique de la tension électrique. Cette mes
s’effectue sure une échelle à deux niveaux :</p>
<ul>
<li>haute tension : <code>HIGH</code> présence d’une tension plus grande que 3.5V</li>
<li>basse tension : <code>LOW</code> présence d’une tension sous 1.5 V</li>
</ul>
<p>En fonction du signal reçu, le microcontrôleur pourra effectuer une tâche prévue (allumer la lumière lorsqu'un capteur de mouvement détecte une présence, par exemple). </p>
<p>Pour effectuer la mesure numérique de la tension électrique présente à une broche, nous utilisons la paire de fonctions suivantes :</p>
<ol>
<li>Configurer la broche <code>numeroBoche</code> en mode entrée avec <code>INPUT_PULLUP</code> :</li>
</ol>
<pre><code class="language-cpp">pinMode( numeroBoche , INPUT_PULLUP );
</code></pre>
<ol start="2">
<li>Effectuer la mesure de la tension à la broche <code>numeroBoche</code> et sauvegarder la valeur dans une variable :</li>
</ol>
<pre><code class="language-cpp">int mesureDeTension;
mesureDeTension = digitalRead( numeroBoche );
</code></pre>
<h2 id="debogage-dune-entrée-numérique"><a class="header" href="#debogage-dune-entrée-numérique">Debogage d'une entrée numérique</a></h2>
<p>Dans le code suivant, nous déboguons l'entrée numérique 2 : </p>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 2;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMERIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(115200); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'ENTRÉE NUMERIQUE EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 20 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
     
    int maNouvelleValeur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION
    
    if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
      Serial.print( &quot;Valeur numerique de la broche &quot; ); // ENVOYER UNE EN-TÊTE DE MESSAGE
      Serial.print( maBrocheEntreeNumerique ); // ENVOYER LE NUMÉRO DE LA BROCHE
      Serial.print( &quot; : &quot; ); // ENVOYER UN SÉPARATEUR ENTRE LE NUMÉRO DE LA BROCHE ET SA VALEUR
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
    }
    
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

  }
}
</code></pre>
<p><img src="entree_numerique/./debogage_entree_numerique_moniteur_serie.png" alt="Résultat du débogage analogique dans le moniteur série" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupteur"><a class="header" href="#interrupteur">Interrupteur</a></h1>
<p><img src="interrupteur/interrupteur_resume.svg" alt="Fiche synthèse pour l'interrupteur" /></p>
<p><img src="interrupteur/interrupteur_branchement.svg" alt="..." /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bouton-poussoir"><a class="header" href="#bouton-poussoir">Bouton poussoir</a></h1>
<p><img src="interrupteur/bouton_poussoir_pcb_bb.svg" alt="Bouton poussoir" /></p>
<p><img src="interrupteur/bouton_poussoir_pcb_disposition.svg" alt="Comment placer un bouton poussoir sur une platine d'expérimentation" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bouton-darcade"><a class="header" href="#bouton-darcade">Bouton d'arcade</a></h1>
<h2 id="référence-du-produit"><a class="header" href="#référence-du-produit">Référence du produit</a></h2>
<p><a href="https://www.adafruit.com/product/3489">Arcade Button with LED - 30mm Translucent Red : ID 3489 : $2.50 : Adafruit Industries, Unique &amp; fun DIY electronics and kits</a></p>
<h2 id="microsoudure-du-bouton"><a class="header" href="#microsoudure-du-bouton">Microsoudure du bouton</a></h2>
<p><img src="bouton_arcade_soudure1.svg" alt="Poser des bulles de métal sur les quatre pattes du bouton d’arcade" /></p>
<p><img src="bouton_arcade_soudure2.svg" alt="Effectuer la microsoudure de deux câbles à une paire de pattes" /></p>
<p><img src="bouton_arcade_soudure3.svg" alt="Effectuer la microsoudure des deux autres pattes" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="une-entrée-numérique-contrôlant-un-sortie-numérique"><a class="header" href="#une-entrée-numérique-contrôlant-un-sortie-numérique">Une entrée numérique contrôlant un sortie numérique</a></h1>
<h2 id="allumer-ou-éteindre-une-del-à-partir-dun-interrupteur"><a class="header" href="#allumer-ou-éteindre-une-del-à-partir-dun-interrupteur">Allumer ou éteindre une DEL à partir d'un interrupteur</a></h2>
<pre><code class="language-arduino">int brocheDel = 3;
int brocheInterrupteur = 12;

void setup() {
  // put your setup code here, to run once:
  pinMode( brocheDel , OUTPUT);
  pinMode( brocheInterrupteur , INPUT_PULLUP);
}

void loop() {
  // put your main code here, to run repeatedly:
  int mesureDeTension = digitalRead( brocheInterrupteur); 
  if ( mesureDeTension == LOW ) {
    digitalWrite( brocheDel, HIGH);
  } else {
    digitalWrite( brocheDel, LOW);
  }
}
</code></pre>
<h2 id="contrôler-le-clignotement-dune-del-à-partir-dun-interrupteur"><a class="header" href="#contrôler-le-clignotement-dune-del-à-partir-dun-interrupteur">Contrôler le clignotement d'une DEL à partir d'un interrupteur</a></h2>
<pre><code class="language-arduino">int brocheDel = 3;
int brocheInterrupteur = 12;

void setup() {
  // put your setup code here, to run once:
  pinMode( brocheDel , OUTPUT);
  pinMode( brocheInterrupteur , INPUT_PULLUP);
}

void loop() {
  // put your main code here, to run repeatedly:
  int mesureDeTension = digitalRead( brocheInterrupteur); 
  if ( mesureDeTension == LOW ) {
    digitalWrite( brocheDel, HIGH);
    delay(250);
    digitalWrite( brocheDel, LOW);
    delay(250);
  } else {
    digitalWrite( brocheDel, LOW);
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intervalle-de-temps"><a class="header" href="#intervalle-de-temps">Intervalle de temps</a></h1>
<h2 id="chronométer-un-intervalle-de-temps-avec-millis"><a class="header" href="#chronométer-un-intervalle-de-temps-avec-millis">Chronométer un intervalle de temps avec millis()</a></h2>
<p>Créer une variable <strong>globale</strong> pour mettre en mémoire le temps de départ du chronomètre :</p>
<pre><code class="language-arduino">unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE
</code></pre>
<p>Pour calculer le temps écoulé nous utilisons le code suivant:</p>
<pre><code class="language-arduino">unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
</code></pre>
<p>Nous pouvons exécuter du code si le temps écoulé dépasse un intervalle de temps (20 millisecondes dans cet exemple):</p>
<pre><code class="language-arduino">unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES
if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI LE TEMPS ÉCOULÉ DÉPASSE L'INTERVALLE...
	// ...FAIRE QQCH 
}
</code></pre>
<p>Nous pouvons redémarrer le chronomètres avec le code suivant:</p>
<pre><code class="language-arduino">monChronoDepart = millis(); // REDÉMARRER LE CHRONOMÈTRE
</code></pre>
<h2 id="exécuter-de-façon-cyclique"><a class="header" href="#exécuter-de-façon-cyclique">Exécuter de façon cyclique</a></h2>
<p>Nous pouvons combiner le deux extraits de code précédents pour exécuter du code ET redémarrer le chronomètre de façon cyclique. Dans l'extrait suivant, le code entre les <code>{ }</code> est exécuté à chaque 20 millisecondes:</p>
<pre><code class="language-arduino">unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE

unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI LE TEMPS ÉCOULÉ DÉPASSE L'INTERVALLE...
	monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
	// ...FAIRE QQCH
}
</code></pre>
<h2 id="exemple--envoyer-la-valeur-dune-entrée-numérique-à-chaque-20-millisecondes"><a class="header" href="#exemple--envoyer-la-valeur-dune-entrée-numérique-à-chaque-20-millisecondes">Exemple : envoyer la valeur d'une entrée numérique à chaque 20 millisecondes</a></h2>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 4;
unsigned long monChronoDepart = 0;

void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'INTERRUPTEUR EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE
  

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES
  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI LE TEMPS ÉCOULÉ DÉPASSE L'INTERVALLE...
    monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
    
    int maValeurInterrupteur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION

    Serial.print( maValeurInterrupteur ); // ENVOYER LA VALEUR
    Serial.println();  // TERMINER LE MESSAGE
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="détecter-un-changement-de-valeur"><a class="header" href="#détecter-un-changement-de-valeur">Détecter un changement de valeur</a></h1>
<h2 id="organigramme-pour-lenvoi-de-la-valeur-dune-entrée-numérique-seulement-si-elle-change"><a class="header" href="#organigramme-pour-lenvoi-de-la-valeur-dune-entrée-numérique-seulement-si-elle-change">Organigramme pour l'envoi de la valeur d'une entrée numérique seulement si elle change</a></h2>
<p><img src="changement/interrupteur_changement_de_valeur.svg" alt="Organigramme pour l'envoi lors d'un changement" /></p>
<h2 id="extraits-de-code-pertinents"><a class="header" href="#extraits-de-code-pertinents">Extraits de code pertinents</a></h2>
<p>Pour détecter un changement de valeur, il faut : </p>
<ol>
<li>Créer un variable pour se souvenir de la valeur précédente:</li>
</ol>
<pre><code class="language-arduino">int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMÉRIQUE
</code></pre>
<ol start="2">
<li>Aller chercher la nouvelle valeur.</li>
<li>Comparer la nouvelle valeur avec la précédente:</li>
</ol>
<pre><code class="language-arduino">if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
	// FAIRE QQCH
}
</code></pre>
<ol start="4">
<li>Mettre en mémoire la nouvelle valeur:</li>
</ol>
<pre><code class="language-arduino">maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR
</code></pre>
<h2 id="exemple--envoyer-la-valeur-dune-entrée-numérique-seulement-si-elle-change"><a class="header" href="#exemple--envoyer-la-valeur-dune-entrée-numérique-seulement-si-elle-change">Exemple : envoyer la valeur d'une entrée numérique seulement si elle change</a></h2>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 4;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMÉRIQUE

void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'INTERRUPTEUR EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE
  int maNouvelleValeur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION
  if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE     
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
   }
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="envoi-optimal-de-valeur"><a class="header" href="#envoi-optimal-de-valeur">Envoi optimal de valeur</a></h1>
<p>Le code suivant envoie la valeur seulement si elle change et au maximum à chaque 20 millisecondes:</p>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 4;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMÉRIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'INTERRUPTEUR EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 20 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
     
    int maNouvelleValeur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION
    
    if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
    }
    
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrée-analogique"><a class="header" href="#entrée-analogique">Entrée analogique</a></h1>
<p><img src="entree_analogique/./entrees_analogiques_nano.svg" alt="Broches pouvant effectuer une lecture analogique" /></p>
<p>Pour effectuer la mesure analogique de la tension électrique présente à une broche, nous utilisons la paire de fonctions suivantes :</p>
<ol>
<li>Configurer la broche <code>maBrocheAnalogique</code> en mode entrée avec <code>INPUT</code> :</li>
</ol>
<pre><code class="language-arduino">pinMode( maBrocheAnalogique , INPUT );
</code></pre>
<ol start="2">
<li>Effectuer la lecture de la broche <code>maBrocheAnalogique</code> avec <code>analogRead()</code> :</li>
</ol>
<pre><code class="language-arduino">int maLectureAnalogique = analogRead( maBrocheAnalogique );
</code></pre>
<p>La fonction <code>analogRead()</code> mesure une tension entre 0V et 5V avec une résolution de 1024 seuils. 
La valeur retournée par <code>analogRead()</code> est toujours entre 0 et 1023.</p>
<h2 id="debogage-dune-entrée-analogique"><a class="header" href="#debogage-dune-entrée-analogique">Debogage d'une entrée analogique</a></h2>
<p>Dans le code suivant, nous déboguons l'entrée analogique A1 : </p>
<pre><code class="language-arduino">int maBrocheEntreeAnalogique = A1;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE ANALOGIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(115200); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeAnalogique , INPUT); // CONFIGURER LA BROCHE DE L'ENTRÉE ANALOGIQUE EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 20 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
     
    int maNouvelleValeur = analogRead( maBrocheEntreeAnalogique ); // LECTURE DE TENSION
    
    if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
      Serial.print( &quot;Valeur analogique : &quot; ); // ENVOYER UNE EN-TÊTE DE MESSAGE
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
    }
    
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

  }
}
</code></pre>
<p><img src="entree_analogique/./debogage_entree_analogique_moniteur_serie.png" alt="Résultat du débogage analogique dans le moniteur série" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="potentiomètre"><a class="header" href="#potentiomètre">Potentiomètre</a></h1>
<p><img src="potentiometre/./potentiometre_explication.svg" alt="Le potentiomètre" /></p>
<h2 id="connexion"><a class="header" href="#connexion">Connexion</a></h2>
<p>Connectez le <strong>OUT</strong> du potentiomètre à une <a href="potentiometre/../entree_analogique/entree_analogique.html">entrée analogique</a> de l'Arduino.</p>
<p><img src="potentiometre/./potentiometre_schema.svg" alt="Schéma du potentiomètre à gauche et identification des broches à droite (le 5V et le GND peuvent être échangés)" /></p>
<h2 id="microsoudure-du-potentiomètre"><a class="header" href="#microsoudure-du-potentiomètre">Microsoudure du potentiomètre</a></h2>
<p><img src="potentiometre/./potentiometre_soudure1.svg" alt="Un potentiomètre 100k" /></p>
<p><img src="potentiometre/./potentiometre_soudure2.svg" alt="Poser des bulles de métal sur les trois pattes du potentiomètre" /></p>
<p><img src="potentiometre/./potentiometre_soudure3.svg" alt="Effectuer la microsoudure de trois câbles aux pattes" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="photorésistance"><a class="header" href="#photorésistance">Photorésistance</a></h1>
<p><img src="photoresistance/./photoresistance1.svg" alt="" /></p>
<h2 id="connexion-avec-un-diviseur-de-tension"><a class="header" href="#connexion-avec-un-diviseur-de-tension">Connexion avec un diviseur de tension</a></h2>
<p>La photorésistance nécessite un circuit de diviseur de tension pour être connectée à l'Arduino. Connectez le <strong>OUT</strong> à une <a href="photoresistance/../entree_analogique/entree_analogique.html">entrée analogique</a> de l'Arduino.</p>
<p><img src="photoresistance/./photoresistance_diviseur_tension.svg" alt="Idendification (à gauche) et schéma (à droite) du circuit du diviseur de tension (le 5V et le GND peuvent être échangés et la photorésistance n'a pas de sens)" /></p>
<h2 id="microsoudure-de-la-photorésistance"><a class="header" href="#microsoudure-de-la-photorésistance">Microsoudure de la photorésistance</a></h2>
<p><img src="photoresistance/./photoresistance2.svg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="une-entrée-analogique-contrôlant-des-sorties-de-type-numérique-et-analogique"><a class="header" href="#une-entrée-analogique-contrôlant-des-sorties-de-type-numérique-et-analogique">Une entrée analogique contrôlant des sorties de type numérique et analogique</a></h1>
<p><a href="https://arduino.developpez.com/tutoriels/arduino-a-l-ecole/?page=projet-9-les-inputs-analogiques#LXVII-D">Cours pour débuter sur Arduino</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-sound-control-osc"><a class="header" href="#open-sound-control-osc">Open Sound Control (OSC)</a></h1>
<p>L'<em>Open Sound Control</em> (OSC) est un protocole de communication inter-applications. Contrairement à ce qu'indique son nom, il ne concerne pas uniquement le son, mais offre un système d'organisation générique mais uniformisé de l'information pertinent au contrôle de n'importe quel système, multimédia ou pas. L'OSC a été développé à UC Berkeley Center for New Music and Audio Technology (CNMAT).</p>
<h2 id="pourquoi-losc"><a class="header" href="#pourquoi-losc">Pourquoi l'OSC?</a></h2>
<p>La plupart des protocoles (COBS, JSON, FUDI, etc.) permettent une trop grande latitude dans la manière d'organiser les données, et s'appuient donc sur des architectures personnalisées spécifiques à chaque développeur. L'OSC impose une structure particulière de l'information que toutes les applications doivent supporter ce qui rend toute communication plus universelle : tout le monde parle la même langue!</p>
<p>L'OSC fournit également une vérification (primitive) des erreurs de transmission, ce qui est très important lorsque l'on travaille avec flux susceptibles au bruit!</p>
<h2 id="client-et-serveur"><a class="header" href="#client-et-serveur">Client et serveur</a></h2>
<ul>
<li>Une application qui envoie de l'OSC est un <strong>client OSC</strong>. </li>
<li>Une application qui reçoit de l'OSC est un <strong>serveur OSC</strong>. </li>
<li>Habituellement, toutes les applications qui supportent l'OSC sont <em>client OSC</em> et <em>serveur OSC</em> (elles peuvent donc supporter la réception et l'envoi de messages OSC).</li>
</ul>
<h2 id="unité-de-transmission"><a class="header" href="#unité-de-transmission">Unité de transmission</a></h2>
<ul>
<li>L'unité de transmission de l'OSC est le <strong>message</strong> ou le <strong>bundle</strong>. Un <strong>bundle</strong> contient un ou plusieurs messages et un <strong>timetag</strong>.</li>
<li>L'OSC est unidirectionnel et n'offre pas d'accusé de réception (on ne sait pas si le destinataire a reçu le message).</li>
</ul>
<h2 id="paquetage"><a class="header" href="#paquetage">Paquetage</a></h2>
<p>L'OSC ne définit pas la mise en paquet des messages. </p>
<p>Les deux types de paquets les plus communs sont:</p>
<ul>
<li><strong>UDP</strong> (le mode par défaut) pour la communication par réseau ou interne de l'ordinateur</li>
<li><strong>SLIP</strong> (souvent nommé <strong>OSC SLIP</strong>) pour la communication par série (USB) avec des microcontrôleurs plus vieux</li>
</ul>
<h3 id="par-udp"><a class="header" href="#par-udp">Par UDP</a></h3>
<p>De façon générale, l'OSC est envoyé sur un réseau par <em>UDP</em>. </p>
<p>Pour envoyer un message, il faut spécifier l'adresse UDP du destinataire. Cette adresse se compose de deux parties:</p>
<ul>
<li>IP de la machine adressée.</li>
<li>Port du client OSC.</li>
</ul>
<p>Pour recevoir un message , il faut simplement spécifier le port de réception.</p>
<h3 id="par-slip"><a class="header" href="#par-slip">Par SLIP</a></h3>
<p>Le <em>SLIP</em> ne permet pas d'adresser les messages à des destinataires spécifiques. Seule l'application qui est connectée au port série peut envoyer et recevoir des messages (qu'elle peut relayer par la suite par UDP si nécessaire).</p>
<h2 id="exemples-darchitectures"><a class="header" href="#exemples-darchitectures">Exemples d'architectures</a></h2>
<h3 id="un-client-sur-une-machine---un-serveur-sur-une-autre-machine"><a class="header" href="#un-client-sur-une-machine---un-serveur-sur-une-autre-machine">Un client sur une machine -&gt; un serveur sur une autre machine</a></h3>
<p><img src="osc/./OSC_unidirectionnel.png" alt="Un client qui envoie des message à un serveur" /></p>
<h3 id="une-machine---une-autre-machine"><a class="header" href="#une-machine---une-autre-machine">Une machine &lt;-&gt; une autre machine</a></h3>
<p><img src="osc/./OSC_bidirectionnel.png" alt="Deux clients/serveurs" /></p>
<h3 id="un-client---un-serveur-sur-la-même-machine"><a class="header" href="#un-client---un-serveur-sur-la-même-machine">Un client -&gt; un serveur sur la même machine</a></h3>
<p>L'architecture suivante  permet d'envoyer un message entre deux applications différentes sur la même machine (ou à l'intérieur de la même application). L'adresse IP <strong>127.0.0.1</strong> veut dire «la machine elle-même».</p>
<p><img src="osc/./OSC_mono.png" alt="Un client qui envoie des message à un serveur local (sur la même machine)" /></p>
<h2 id="composition-dun-bundle-osc"><a class="header" href="#composition-dun-bundle-osc">Composition d'un bundle OSC</a></h2>
<p>Un bundle OSC contient plusieurs messages OSC. Il sert surtout à s'assurer que plusieurs messages arrivent simultanément au destinataire. </p>
<h2 id="composition-dun-message-osc"><a class="header" href="#composition-dun-message-osc">Composition d'un message OSC</a></h2>
<p>Un message OSC est composé des éléments suivants:</p>
<ul>
<li>une <strong>adresse</strong></li>
<li>un ou plusieurs <strong>arguments</strong></li>
</ul>
<h3 id="adresse"><a class="header" href="#adresse">Adresse</a></h3>
<p>L'adresse indique quel est le paramètre que l'on veut modifier. Elle peut être composée de n'importe quelle lettre et chiffre. Par contre, voici quelques recommandations à suivre lorsque vous concevez votre propre serveur OSC:</p>
<ul>
<li>Une adresse doit toujours commencer par <code>/</code></li>
<li>Chaque <code>/</code> subdivise l'adresse en hiérarchie symbolique. Plus une subdivision se trouve au début, plus est elle haute dans hiérarchie. Prenons comme exemple <code>/A/B</code> : <code>A</code> englobe <code>B</code> et <code>B</code> fait partie de <code>A</code>.</li>
<li>Tous les <em>espaces</em> doivent être remplacés par des <code>_</code></li>
</ul>
<p>Quelques exemples: </p>
<pre><code>/application/fenetre/bouton
/torse/bras/main/doigt/index
/renoise/pattern_name
</code></pre>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p>Chaque argument possède un type. Il existe quatre types de base :</p>
<ul>
<li><em>int</em> : nombre entier à 32 bit.</li>
<li><em>float</em> : nombre à virgule à 32 bit.</li>
<li><em>string</em> : chaîne de caractères.</li>
<li><em>blob</em> : un tableau d'octets (byte).</li>
</ul>
<p>Un message OSC peut mélanger plusieurs types d'arguments différents et peut contenir n'importe quel nombre d'arguments. </p>
<p>Quelques exemples: </p>
<pre><code>/application/fenetre/bouton 1
/torse/bras/main/doigt/index 0.324
/renoise/pattern_name intro 43
</code></pre>
<p>Voici quelques recommandations à suivre lorsque vous concevez votre propre serveur OSC:</p>
<ul>
<li>Essayez de réduire le nombre d'arguments au profit d'un adressage plus complet. Cela respecte mieux la hiérarchie de l'adressage et plusieurs serveurs OSC ne supportent qu'un seul argument à la fois. Par exemple, utilisez <code>/piste/0/vol 1.</code> a un seul argument plutôt que <code>/piste/vol 0 1.</code> à deux arguments.</li>
<li>Utilisez autant que possible des nombres réels normalisées entre <code>0.</code> et <code>1.</code> pour plus de compatibilité.</li>
</ul>
<h3 id="annexe-dapplications-supportant-losc"><a class="header" href="#annexe-dapplications-supportant-losc">Annexe d'applications supportant l'OSC</a></h3>
<ul>
<li>https://sensors2.org/osc/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microosc"><a class="header" href="#microosc">MicroOsc</a></h1>
<p><strong>MicroOsc</strong> est une bibliothèque pour Arduino permettant à la plaquette de communiquer en OSC par SLIP ou UDP.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><img src="microosc/./arduino_ide_gerer_bilbiotheques.png" alt="Ouverture du gestionnaire de bibliothèques" /></p>
<p><img src="microosc/./arduino_ide_installer_microosc.png" alt="Recherche et installation de la bibliothèque MicroOsc" /></p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>La documentation (en anglais) se trouve sur le <a href="https://github.com/thomasfredericks/MicroOsc">GitHub de la bibliothèque MicroOsc</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip"><a class="header" href="#osc-slip">OSC SLIP</a></h1>
<h2 id="prenons-comme-exemple-le-circuit-suivant"><a class="header" href="#prenons-comme-exemple-le-circuit-suivant">Prenons comme exemple le circuit suivant</a></h2>
<p><img src="osc_slip/./bouton_arcade_photocell_potentiometre.svg" alt="Circuit avec un bouton d'arcade, une photorésistance et un potentiometre" /></p>
<h2 id="code-osc-slip-avec-microosc"><a class="header" href="#code-osc-slip-avec-microosc">Code OSC SLIP avec MicroOsc</a></h2>
<pre><code class="language-Arduino">// MicroOscSlip_demo
// by Thomas O Fredericks
// 2022-10-26

// HARDWARE REQUIREMENTS
// ==================
// Potentiometer connected to analog pin A0
// Photocell connected to analog pin A1
// Switch connected to pin 2
// LED connected to pin 3

// REQUIRED LIBRARIES
// ==================
// MicroOsc

// REQUIRED CONFIGURATION
// ======================
// Set Serial baud to 115200


#include &lt;MicroOscSlip.h&gt;
// The number 64 between the &lt; &gt; below  is the maximum number of bytes reserved for incomming messages.
// Outgoing messages are written directly to the output and do not need more reserved bytes.
MicroOscSlip&lt;64&gt; myMicroOsc(&amp;Serial);

unsigned long myChronoStart = 0;

const int myPotPin = A0;
int myPotPreviousValue;

const int myPhotoPin = A1;
int myPhotoPreviousValue;

const int myButtonPin = 2;
int myButtonPreviousValue;

const int myLedPin = 3;

void setup() {
  // INITIATE SERIAL COMMUNICATION
  Serial.begin(115200);
  pinMode( myPotPin , INPUT);  // ANALOG INPUT
  pinMode( myPhotoPin , INPUT);  // ANALOG INPUT
  pinMode( myButtonPin , INPUT_PULLUP);  // DIGITAL INPUT
  pinMode( myLedPin , OUTPUT); // DIGITAL OUTPUT
}

// FUNCTION THAT IS CALLED FOR EVERY RECEIVED MESSAGE
void myReceiveOscMessage( MicroOscMessage &amp; myOscMessage ) {
  if ( myOscMessage.fullMatch(&quot;/led&quot;) ) { // IF THE ADDRESS IS /led
    int myLedValue = myOscMessage.nextAsInt(); // GET VALUE AS INT
    digitalWrite( myLedPin , myLedValue); // SET LED VALUE TO LED
  }
}

void loop() {
  myMicroOsc.receiveMessages( myReceiveOscMessage );

  unsigned long myChronoElapsed = millis() - myChronoStart;
  unsigned long myChronoInterval = 50;
  if ( myChronoElapsed &gt;= myChronoInterval) {
    myChronoStart = millis(); // RESTART CHRONO

    // POTENTIOMETER
    int myPotValue = analogRead(myPotPin); // READ CURRENT VALUE
    if ( myPotValue != myPotPreviousValue ) myMicroOsc.sendInt( &quot;/pot&quot; , myPotValue  );
    myPotPreviousValue = myPotValue; // STORE CURRENT VALUE
    
    // PHOTOCELL
    int myPhotoValue = analogRead(myPhotoPin); // READ CURRENT VALUE
    if ( myPhotoValue != myPhotoPreviousValue ) myMicroOsc.sendInt( &quot;/photo&quot;  , myPhotoValue  );
    myPhotoPreviousValue = myPhotoValue; // STORE CURRENT VALUE

    // BUTTON
    int myButtonValue = digitalRead(myButtonPin); // READ CURRENT VALUE
    if ( myButtonValue != myButtonPreviousValue ) myMicroOsc.sendInt( &quot;/button&quot;  ,myButtonValue  );
    myButtonPreviousValue = myButtonValue; // STORE CURRENT VALUE

  }
  
}
</code></pre>
<h2 id="scénarios-de-connectique"><a class="header" href="#scénarios-de-connectique">Scénarios de connectique</a></h2>
<p>Il existe plusieurs scénarios de connectique possible. Les trois scénarios suivants sont détaillés dans les prochaines pages.</p>
<h3 id="avec-une-application-qui-supporte-directement-losc-slip"><a class="header" href="#avec-une-application-qui-supporte-directement-losc-slip">Avec une application qui supporte directement l'OSC SLIP</a></h3>
<p><img src="osc_slip/./osc_slip_connectique_directe.svg" alt="Scénario de connectique à une application qui supporte directement l'OSC SLIP" /></p>
<h3 id="avec-une-application-qui-supporte-losc-upd-à-laide-dun-relais-osc-slip--osc-udp"><a class="header" href="#avec-une-application-qui-supporte-losc-upd-à-laide-dun-relais-osc-slip--osc-udp">Avec une application qui supporte l'OSC UPD à l'aide d'un relais OSC SLIP ⇄ OSC UDP</a></h3>
<p><img src="osc_slip/./osc_slip_connectique.svg" alt="Schématisation de la chaîne de connectique OSC SLIP ⇄ OSC UDP" /></p>
<h3 id="avec-une-application-qui-supporte-le-midi-à-laide-dun-relais-osc-slip--midi"><a class="header" href="#avec-une-application-qui-supporte-le-midi-à-laide-dun-relais-osc-slip--midi">Avec une application qui supporte le MIDI à l'aide d'un relais OSC SLIP ⇄ MIDI</a></h3>
<p><img src="osc_slip/./osc_slip_connectique_midi.svg" alt="Schématisation de la chaîne de connectique OSC SLIP ⇄ MIDI" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip-dans-pure-data"><a class="header" href="#osc-slip-dans-pure-data">OSC SLIP dans Pure Data</a></h1>
<h2 id="installation-de-pure-data"><a class="header" href="#installation-de-pure-data">Installation de Pure Data</a></h2>
<p>Téléchargez la version appropriée pour votre système ici (si possible la version avec installateur) : <a href="https://puredata.info/downloads/pure-data">puredata.info/downloads/pure-data</a></p>
<h2 id="installation-des-objets-additionnels-pour-losc-slip-dans-pure-data"><a class="header" href="#installation-des-objets-additionnels-pour-losc-slip-dans-pure-data">Installation des objets additionnels pour l'OSC SLIP dans Pure Data</a></h2>
<p>Pour faire fonctionner l'OSC SLIP il est nécessaire d'ajouter des collections d'objets à Pure Data:</p>
<ul>
<li>mrpeach</li>
<li>comport</li>
<li>cyclone (pas absolument nécessaire mais très utile)</li>
</ul>
<p><img src="pd/./pd_installer_objets_supplementaires.svg" alt="Ouvrez le menu d'installation des objets supplémentaires" /></p>
<p><img src="pd/./pd_installer_mrpeach.svg" alt="Installez mrpeach" /></p>
<p><img src="pd/./pd_installation_mrpeach_reussie.svg" alt="Installation de mrpeach réussie (notez que parfois le logiciel ne confirme pas l'installation réussie)" /></p>
<p><img src="pd/./pd_installation_cyclone.svg" alt="Installez cyclone" /></p>
<p><img src="pd/./pd_installation_cyclone_reussie.svg" alt="Installation de cyclone réussie (notez que parfois le logiciel ne confirme pas l'installation réussie)" /></p>
<p><img src="pd/./pd_installation_comport.svg" alt="Installez comport" /></p>
<p><img src="pd/./pd_installation_comport_reussie.svg" alt="Installation de comport réussie (notez que parfois le logiciel ne confirme pas l'installation réussie)" /></p>
<h2 id="patcher-pour-le-traitement-de-losc-slip-directement-dans-pure-data"><a class="header" href="#patcher-pour-le-traitement-de-losc-slip-directement-dans-pure-data">Patcher pour le traitement de l'OSC SLIP directement dans Pure Data</a></h2>
<p><a href="pd/./osc_slip_direct.pd"><img src="pd/./osc_slip_direct.png" alt="Exemple osc_slip_direct.pd (cliquez pour télécharger)" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relais-osc-slip--osc-udp-avec-pure-data"><a class="header" href="#relais-osc-slip--osc-udp-avec-pure-data">Relais OSC SLIP ⇄ OSC UDP avec Pure Data</a></h1>
<p>Cette section propose une solution pour connecter une carte Arduino qui communique en SLIP avec n'importe quelle application qui communique en OSC UDP.</p>
<p><img src="pd/../osc_slip/osc_slip_connectique.svg" alt="Scénario de connectique OSC SLIP ⇄ OSC UDP" /></p>
<h2 id="prérequis"><a class="header" href="#prérequis">Prérequis</a></h2>
<p>Cette solution nécessite l'installation de <strong>Pure Data</strong> et d'y ajouter des objets pour l'OSC SLIP : voir la section <a href="pd/./osc_slip.html">OSC SLIP avec Pure Data</a>.</p>
<h2 id="le-patcher-pure-data"><a class="header" href="#le-patcher-pure-data">Le patcher Pure Data</a></h2>
<p><a href="pd/./osc_slip_relay_udp.pd"><img src="pd/./pd_osc_slip_relay_udp.svg" alt="osc_slip_relay_udp.pd (cliquez pour télécharger)" /></a>	</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relais-osc-slip--midi-avec-pure-data"><a class="header" href="#relais-osc-slip--midi-avec-pure-data">Relais OSC SLIP ⇄ MIDI avec Pure Data</a></h1>
<p>Cette section propose une solution pour connecter une carte Arduino qui communique en SLIP avec n'importe quelle application MIDI.</p>
<p><img src="pd/../osc_slip/osc_slip_connectique_midi.svg" alt="Schématisation de la chaîne de connectique OSC SLIP ⇄ MIDI" /></p>
<h2 id="prérequis-1"><a class="header" href="#prérequis-1">Prérequis</a></h2>
<p>Cette solution nécessite l'installation de <strong>Pure Data</strong> et d'y ajouter des objets pour l'OSC SLIP : voir la section <a href="pd/./osc_slip.html">OSC SLIP avec Pure Data</a>.</p>
<h2 id="configuration-midi-de-pure-data"><a class="header" href="#configuration-midi-de-pure-data">Configuration MIDI de Pure Data</a></h2>
<p><img src="pd/./pd_ouvrir_parametres_midi.svg" alt="Ouvrir les paramètres MIDI" /></p>
<p><img src="pd/./pd_configurer_midi_loopmidi.svg" alt="Configuration MIDI pour l'utilisation de loopMIDI" /></p>
<h2 id="patcher-pour-le-relais-de-messages-osc-slip---midi"><a class="header" href="#patcher-pour-le-relais-de-messages-osc-slip---midi">Patcher pour le relais de messages OSC SLIP &lt;-&gt; MIDI</a></h2>
<p><a href="pd/./osc_slip_midi.pd"><img src="pd/./pd_osc_slip_midi.svg" alt="Exemple osc_slip_midi.pd (cliquez pour télécharger)" /></a></p>
<h2 id="exemple-denvoi-et-de-réception-du-midi-dans-vcv-rack"><a class="header" href="#exemple-denvoi-et-de-réception-du-midi-dans-vcv-rack">Exemple d'envoi et de réception du MIDI dans VCV Rack</a></h2>
<p><img src="pd/./pd_osc_slip_midi_vcv_rack.svg" alt="Exemple d'envoi et de réception du MIDI dans VCV Rack" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip-avec-max"><a class="header" href="#osc-slip-avec-max">OSC SLIP avec Max</a></h1>
<h2 id="installation-de-max"><a class="header" href="#installation-de-max">Installation de Max</a></h2>
<p>Téléchargez la version appropriée pour votre système ici (si possible la version avec installateur) : <a href="https://cycling74.com/downloads">cycling74.com/downloads</a></p>
<h2 id="installation-des-objets-additionnels-pour-losc-slip-dans-max"><a class="header" href="#installation-des-objets-additionnels-pour-losc-slip-dans-max">Installation des objets additionnels pour l'OSC SLIP dans Max</a></h2>
<p>Pour faire fonctionner l'OSC SLIP il est nécessaire d'ajouter une collection d'objets à Max:</p>
<ul>
<li>CNMAT</li>
</ul>
<p><img src="max/./max_installation_cnmat.png" alt="Installation de la bibliothèque(package) CNMAT dans Max" /></p>
<h2 id="patcher-pour-le-traitement-de-losc-slip-directement-dans-max"><a class="header" href="#patcher-pour-le-traitement-de-losc-slip-directement-dans-max">Patcher pour le traitement de l'OSC SLIP directement dans Max</a></h2>
<p><a href="max/./osc_slip_direct.maxpat"><img src="max/./osc_slip_direct_max_patcher.png" alt="Exemple osc_slip_direct.maxpat (cliquez pour télécharger)" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip-web"><a class="header" href="#osc-slip-web">OSC SLIP Web</a></h1>
<h2 id="configuration-arrduino"><a class="header" href="#configuration-arrduino">Configuration Arrduino</a></h2>
<p>Téléversez le code <em>MicroOscSlip_demo</em> sur votre Arduino et réalisez le circuit tel qu'indiqué à la page <a href="osc_slip_web/../osc_slip/osc_slip.html">OSC SLIP avec MicroOsc</a></p>
<h2 id="installation-de-nodejs"><a class="header" href="#installation-de-nodejs">Installation de Node.js</a></h2>
<p><img src="osc_slip_web/./installation_nodejs.png" alt="Installation de Node.js" /></p>
<h2 id="téléchargement-du-code-slipwebdemozip"><a class="header" href="#téléchargement-du-code-slipwebdemozip">Téléchargement du code slipWebDemo.zip</a></h2>
<p><a href="osc_slip_web/./slipWebDemo.zip"><img src="osc_slip_web/./telecharger_slipWebDemo.png" alt="CLiquez pour télécharger slipWebDemo.zip" /></a></p>
<p><img src="osc_slip_web/./extraire_slipWebDemo.png" alt="Décompressez le code" /></p>
<h2 id="configuration-et-démarrage-de-slipwebdemo"><a class="header" href="#configuration-et-démarrage-de-slipwebdemo">Configuration et démarrage de «slipWebDemo</a></h2>
<p><img src="osc_slip_web/./Diapositive1.SVG" alt="Démarrez l'invite de commande" /></p>
<p><img src="osc_slip_web/./Diapositive2.SVG" alt="Démarrez le script Node.js «slipDemo.js»" /></p>
<p><img src="osc_slip_web/./Diapositive4.SVG" alt="Configurez le code avec le bon port" /></p>
<p><img src="osc_slip_web/./Diapositive5.SVG" alt="Redémarrez le script et ouvrez le navigateur Web à la bonne adresse" /></p>
<p><img src="osc_slip_web/./Diapositive3.SVG" alt="Pour arrêter un script, tapez Ctrl+c 1 ou 2  fois" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-avec-vcv-rack"><a class="header" href="#osc-avec-vcv-rack">OSC avec VCV Rack</a></h1>
<p>Il existe quelques modules OSC pour VCV Rack, mais nous trouvons que le module <strong>cvOSCcv</strong> est le plus configurable. </p>
<h2 id="installation-de-cvosccv"><a class="header" href="#installation-de-cvosccv">Installation de cvOSCcv</a></h2>
<p>En date du 4 octobre 2022, le module <strong>cvOSCcv</strong> n'est plus disponible dans le <a href="https://library.vcvrack.com/">gestionnaire de librairies de VCV Rack</a>. </p>
<p>Heureusement, l'adaption pour la version 2 est mode béta sur le <a href="https://github.com/j4s0n-c/trowaSoft-VCV/releases">GitHub de cvOSCcv</a>. Ouvrez la section <em>Assets</em> de la dernière version (<em>release</em>) et téléchargez la version pour votre OS.
<img src="vcv_rack/./github_cvosccv.png" alt="Téléchargement de la dernière version béta de cvOSCcv dans les Assets de la dernière version" /></p>
<p>Pour installer <strong>cvOSCcv</strong>, copiez le dossier <em>trowaSoft</em> dans le dossier <em>plugins</em> des documents de VCV Rack 2 (<em>Vos Documents &gt; Rack2 &gt; plugins</em>).</p>
<p><img src="vcv_rack/./install_cvosccv_rack2_plugins.png" alt="Copier le dosssier «trowaSoft» dans le dossier «Mes Documents &gt; Rack2 &gt; plugins»" /></p>
<p>Redémarrez VCV Rack et vous devriez trouver <strong>cvOSCcv</strong> dans la liste des modules:
<img src="vcv_rack/./cvosccv_dans_la_liste_des_modules.png" alt="Recherche de «cvOSCcv» dans la liste des modules dans VCV Rack" /></p>
<h3 id="configuration-de-cvosccv"><a class="header" href="#configuration-de-cvosccv">Configuration de cvOSCcv</a></h3>
<p><img src="vcv_rack/./cvosccv_configuration_generale.svg" alt="Configuration générale" /></p>
<p><img src="vcv_rack/./cvosccv_adresses.svg" alt="Configurer les adresses des messages" /></p>
<p><img src="vcv_rack/./cvosccv_configurer_reception_messages.svg" alt="Configuration de la réception de messages analogiques" /></p>
<p><img src="vcv_rack/./cvosccv_configurer_reception_message_numerique.svg" alt="Configuration de la réception du messages numérique" /></p>
<p><img src="vcv_rack/./cvosccv_configurer_envoi_messages.svg" alt="Configuration de l'envoi de messages" /></p>
<p><img src="vcv_rack/./cvosccv_demarrer.svg" alt="Démarrer la connexion OSC" /></p>
<p><img src="vcv_rack/./cvosccv_visualisation_messages.svg" alt="Visualisation des messages OSC" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sortie-analogique-pwm-modulation-de-largeur-dimpulsion"><a class="header" href="#sortie-analogique-pwm-modulation-de-largeur-dimpulsion">Sortie analogique (PWM: modulation de largeur d'impulsion)</a></h1>
<p>Un sortie analogique permet de <strong>simuler</strong> une variation de tension électrique. Par exemple, un sortie analogique peut être utilisée pour faire varier la luminosité d'une DEL et effectuer des effets de fondu.</p>
<p>Pour <strong>simuler</strong> cette variation de tension, nous utilisons la modulation de largeur d'impulsion, <em>Pulse Width Modulation (PWM)</em> en anglais. Il s'agit de faire alterner à grande fréquence les périodes hautes (allumée) et basses (éteinte) de la broche.  En d'autre termes, cela signifie que la DEL clignote très très vite. Tellement vite que l'oeil ne percevra qu'une lumière continue qui varie d'intensité. </p>
<p><img src="sortie_analogique/./Diapositive2.SVG" alt="Simulation de variation de tension à l'aide de modulation de largeur d'impulsion" /></p>
<p>Pour effectuer une sortie analogique, nous utilisons la paire de fonctions suivantes :</p>
<ol>
<li>Configurer la broche <code>maBrochePWM</code> en mode sortie avec <code>OUTPUT</code> :</li>
</ol>
<pre><code class="language-arduino">pinMode( maBrochePWM , OUTPUT );
</code></pre>
<ol start="2">
<li>Contrôler la modulation de largeur d'impulsion, qui est entre 0 et 255, de la broche <code>maBrochePWM</code> avec <code>analogWrite()</code> :</li>
</ol>
<pre><code class="language-arduino">int maValeurPWM = 255; // VALEUR ENTRE 0 et 255
analogWrite( maBrochePWM, maValeurPWM );
</code></pre>
<h2 id="broches-1"><a class="header" href="#broches-1">Broches</a></h2>
<p>Les broches capables de supporter modulation de largeur d'impulsions sont identifiées par un «~» ou le mot «PWM». Il s'agit des broches 3, 5, 6, 9, 10 et 11 pour l'Arduino Nano.
<img src="sortie_analogique/./Diapositive1.SVG" alt="Broches qui peuvent être configurées en sortie analogique" /></p>
<h2 id="debogage-dune-sortie-analogique"><a class="header" href="#debogage-dune-sortie-analogique">Debogage d'une sortie analogique</a></h2>
<p><img src="sortie_analogique/./debogage_sortie_analogique.png" alt="Circuit d'une DEL branchée à la broche 9" /></p>
<p>Le code suivant permet de déboguer la sortie nummérique à l'aide d'une DEL branchée à la broche 9. À chaque 30 millisecondes, la largeur d'impulsion est augmentée de 5. Lorsque la valeur dépasse 255, elle retombe à 0.</p>
<pre><code class="language-arduino">int maBrochePWM = 9;
int maValeurPWM = 0;

unsigned long monChrono;

void setup() {
  Serial.begin(115200);
  
  pinMode( maBrochePWM , OUTPUT);
}

void loop() {
  if ( millis() - monChrono &gt;= 30 ) {
    monChrono = millis();
    
    maValeurPWM = maValeurPWM + 5;
    if ( maValeurPWM &gt; 255 ) maValeurPWM = 0;

    analogWrite( maBrochePWM , maValeurPWM );

    Serial.print(&quot;analogWrite(&quot;);
    Serial.print(maBrochePWM);
    Serial.print(&quot;,&quot;);
    Serial.print(maValeurPWM);
    Serial.print(&quot;)&quot;);
    Serial.println();
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chandelle"><a class="header" href="#chandelle">Chandelle</a></h1>
<p>Dans cet exemple, nous simulons une chandelle en faisant varier aléatoirement l'intensité d'une DEL. </p>
<h2 id="aléatoire"><a class="header" href="#aléatoire">Aléatoire</a></h2>
<p>La fonction <code>random()</code> permet de générer un entier <code>int</code> entre un minimum et un maximum. Il est très important de remarquer que  que la valeur maximale est exclue des valeurs possibles; si le miminum est 0 et le maximum est 5, les valeurs possibles sont 0,1,2,3,4 (sans le 5).</p>
<p>Exemple d'utilisation de <code>random()</code>:</p>
<pre><code class="language-arduino">int monMin = 0;
int monMax = 255;
int maValeurAleatoire = random( monMin , monMax );
</code></pre>
<h2 id="circuit"><a class="header" href="#circuit">Circuit</a></h2>
<h3 id="composants"><a class="header" href="#composants">Composants</a></h3>
<ul>
<li>Un Arduino avec une sortie analogique</li>
<li>Une DEL</li>
<li>Une résistance pour limiter l'intensité du courant qui traverse la DEL</li>
</ul>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>La DEL doit être connectée à une sortie analogique de l'Arduino</li>
</ul>
<h3 id="schéma"><a class="header" href="#schéma">Schéma</a></h3>
<p><img src="chandelle/./debogage_sortie_analogique.png" alt="Une DEL branchée à une sortie analogique de l'Arduino" /></p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-arduino">int maBrocheDel = 9;

unsigned long monChrono;

void setup() {
  pinMode(maBrocheDel, OUTPUT);
}

void loop() {

  if ( millis() - monChrono &gt;= 20 ) {
    monChrono = millis();

    int monMin = 0;
    int monMax = 256;
    int maValeurAleatoire = random( monMin , monMax );

    analogWrite(maBrocheDel, maValeurAleatoire);

  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bande-de-del"><a class="header" href="#bande-de-del">Bande de DEL</a></h1>
<h2 id="préparation"><a class="header" href="#préparation">Préparation</a></h2>
<p><img src="bande_del/./Diapositive1.SVG" alt="Couper une bande de DEL" /></p>
<p><img src="bande_del/./Diapositive2.SVG" alt="Enlevez soigneusement le revêtement sur la partie cuivrée coupée" /></p>
<p><img src="bande_del/./Diapositive3.SVG" alt="Effectuez la soudure de 3 connexions : GND, DI et +12v" /></p>
<p><img src="bande_del/./Diapositive4.SVG" alt="Ajoutez une deuxième connexion au GND (pour un total de 4 connexions)" /></p>
<h2 id="broches-2"><a class="header" href="#broches-2">Broches</a></h2>
<p>Le modèle de bande de DEL que nous utilisons est le WS281X (le X indique que le dernier chiffre n’est pas important). Elle fonctionne avec une tension d'alimentation à 12V.</p>
<p>Elle est aussi connue sous le nom de <strong>NeoPixel</strong>, parce qu’elle a été popularisé en Amérique par la compagnie Adafruit qui la baptisé ainsi. Adafruit fournit <a href="https://www.adafruit.com/category/168">plusieurs modèles de NeoPixel</a>. Cependant, les NeoPixels fonctionnent à 5V. Toutefois le système de contrôle est identique à celui de la bande de DEL que nous utilisons.</p>
<p>Les NeoPixels possèdent 3 broches qui doivent toutes être connectées :</p>
<ul>
<li>GND</li>
<li>Alimentation (5V, 12V ou 24V selon les modèles)</li>
<li>Entrée de données (<em>Data In</em>)</li>
</ul>
<p>Les WS281X 12V possèdent 4 broches (la broche supplémentaire est optionnelle) :</p>
<ul>
<li><strong>GND</strong></li>
<li><strong>+12V</strong> pour l'alimentation</li>
<li><strong>DI</strong> pour l'entrée de données</li>
<li><strong>BI</strong> qui est optionnel et utilisé seulement en cas de bris d'un segment</li>
</ul>
<h2 id="ordre-des-couleurs-des-del"><a class="header" href="#ordre-des-couleurs-des-del">Ordre des couleurs des DEL</a></h2>
<p>Pour chaque modèle de bande de DEL, les couleurs sont disposées dans un certain ordre: RGB, GRB, BGR, etc. <strong>Dans notre cas, l'ordre est : RGB</strong></p>
<h2 id="branchement"><a class="header" href="#branchement">Branchement</a></h2>
<p><img src="bande_del/./Diapositive5.SVG" alt="Alimentez la bande de DEL avec l’alimentation 12v" /></p>
<h3 id="bonnes-pratiques"><a class="header" href="#bonnes-pratiques">Bonnes pratiques</a></h3>
<p>Adafruit recommande les bonnes pratiques de connexion suivantes : <a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/best-practices">Best Practices | Adafruit NeoPixel Überguide | Adafruit Learning System</a></p>
<h2 id="bibliothèques"><a class="header" href="#bibliothèques">Bibliothèques</a></h2>
<p><strong>Les bibliothèques de DEL supportent souvent plusieurs modèles. Assurez-vous que vous sélectionnez le bon modèle dans le code!</strong> </p>
<p>Les deux bibliothèques les plus populaires sont:</p>
<ul>
<li><a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/the-magic-of-neopixels">Adafruit NeoPixel</a> : NeoPixel est plus simple à utiliser mais moins performante.</li>
<li><a href="https://github.com/FastLED/FastLED">FastLED</a> : FastLED est plus performante, mais plus compliquée à utiliser. Cette bibliothèque présente aussi les meilleurs exemples.</li>
</ul>
<h2 id="bibliothèque-fastled"><a class="header" href="#bibliothèque-fastled">Bibliothèque FastLED</a></h2>
<p><img src="bande_del/./Diapositive6.SVG" alt="Installation de la bibliothèque FastLED et où trouver les exemples" /></p>
<p>Exemples intéressants à essayer:</p>
<ul>
<li>Cylon</li>
<li>TwinkleFox</li>
<li>Fire2021</li>
<li>DemoReel100</li>
</ul>
<p>Dans <strong>chaque</strong> exemple, vous devez vous assurer que la configuration est adéquate :</p>
<ul>
<li>Que le DATA_PIN ou LED_PIN corresponde à la broche Arduino qui est connectée à la broche DI de la bande.</li>
<li>Que NUM_LEDS corresponde au nombre de DEL de votre bande</li>
<li>Que COLOR_ORDER corresponde à l’ordre des couleurs RGB</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pong-1d-pong-à-une-dimension"><a class="header" href="#pong-1d-pong-à-une-dimension">Pong 1D (Pong à une dimension)</a></h1>
<h2 id="quest-ce-que-pong-2d"><a class="header" href="#quest-ce-que-pong-2d">Qu'est-ce que Pong (2D)?</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=CKzWAxMfZRA">Data Driven Gamer: Pong (Atari, 1972 arcade, 60fps) - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=84Ymt9BAq5s">Atari Pong Table Electromechanical Game Debut @ IAAPA 2017 (Calinfer / UNIS) - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=6bm7fLcj5UI">Let's Play - The PainStation - YouTube</a></li>
</ul>
<h2 id="exemple-de-jeu-de-pong-1d"><a class="header" href="#exemple-de-jeu-de-pong-1d">Exemple de jeu de Pong 1D</a></h2>
<p>Ce projet est basé sur <a href="https://create.arduino.cc/projecthub/mircemk/diy-arduino-1d-pong-game-with-ws2812-led-strip-a2418b">DIY Arduino 1D Pong Game with WS2812 LED Strip</a>. Le code original a été écrit par B.Stultiens en 2015. La version présentée ici a été légèrement modifiée pour en régler un bogue et pour en retirrer le code audio.</p>
<p>Le projet nécessite:</p>
<ul>
<li>1 bande de DEL d'au moins 32 pixels</li>
<li>la bibliothèque NeoPixel pour contrôler la bande de DEL</li>
<li>2 interrupteurs pour démarrer et frapper la balle</li>
<li><em>Optionnel</em>: 2 autres interrupteurs peuvent être ajoutés pour permettre l'activation des bonus de jeu</li>
</ul>
<p>Une simulation peut être testée en ligne ici : <a href="https://pi-pico.preview.wokwi.com/arduino/projects/345886566467502674">https://pi-pico.preview.wokwi.com/arduino/projects/345886566467502674</a></p>
<h3 id="installation-de-la-bibliothèque-adafruit-neopixel"><a class="header" href="#installation-de-la-bibliothèque-adafruit-neopixel">Installation de la bibliothèque Adafruit NeoPixel</a></h3>
<p><img src="pong_1d/./arduino_bibliotheque_installation_neopixel.svg" alt="Installation de la bibliothèque Adafruit NeoPixel" /></p>
<h3 id="le-circuit"><a class="header" href="#le-circuit">Le circuit</a></h3>
<p><img src="pong_1d/./pong_1d.svg" alt="Circuit minimal du Pong 1D" /></p>
<h3 id="le-code"><a class="header" href="#le-code">Le code</a></h3>
<p>N'oubliez pas de modifier la configuration matérielle pour qu'elle corresponde à votre circuit:</p>
<ul>
<li><strong>PIN_WSDATA</strong>: Le numéro de la broche Arduino reliée à la broche DI de la bande de DEL</li>
<li><strong>NPIXELS</strong>: Le nombre de pixels dans botre bande de DEL</li>
<li><strong>PIN_BUT_RS</strong>: Le numéro de la broche Arduino reliée au bouton de droite</li>
<li><strong>PIN_BUT_LS</strong>: Le numéro de la broche Arduino reliée au bouton de gauche</li>
<li><strong>ZONE_SIZE</strong>: La taille des buts</li>
<li><strong>TIME_SPEED_MIN</strong>: La vitesse de la balle</li>
</ul>
<pre><code class="language-arduino">/*
   Arduino 1D Pong Game with (60) WS2812B LEDs

   Copyright (C) 2015  B.Stultiens (modified by Thomas O Fredericks in 2022)

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope sthat it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/
#include &quot;Adafruit_NeoPixel.h&quot;

// HARDWARE CONFIGURATION
#define PIN_WSDATA		10		// LED strip data in pin
#define NPIXELS      64    // Number of pixels to handle

#define PIN_BUT_RS		3		// Right start/hit button pin
#define PIN_BUT_LS		2		// Left start/hit button pin

#define PIN_BUT_RP    4   // Optionnal right power-up button
#define PIN_BUT_LP    6   // Optionnal left power-up button

// BALL SPEED
#define TIME_SPEED_MIN    10

// ZONE AND WIN CONFIGURATION
#define ZONE_SIZE		7		// Bounce-back zone size
#define WIN_POINTS    10    // Points needed to win
#define SHOW_LO			12		// Score dots intensity background
#define SHOW_HI			48		// Score dots intensity foreground


#define NELEM(x)    (sizeof(x) / sizeof((x)[0]))

Adafruit_NeoPixel one_d = Adafruit_NeoPixel(NPIXELS, PIN_WSDATA, NEO_GRB | NEO_KHZ800);

// Events from buttons and timers
#define EV_BUT_LS_PRESS		0x01
#define EV_BUT_RS_PRESS		0x02
#define EV_BUT_LP_PRESS		0x04
#define EV_BUT_RP_PRESS		0x08
#define EV_TIMER		0x10
#define EV_TIMEOUT		0x20


#define TIME_DEBOUNCE		8
#define TIME_IDLE		40
#define TIME_START_TIMEOUT	20000		// Go idle if nothing happens
#define TIME_RESUME_TIMEOUT	7500		// Auto-fire after timeout
#define TIME_BALL_BLINK		150
#define TIME_SPEED_INTERVAL	3
#define TIME_POINT_BLINK	233
#define TIME_WIN_BLINK		85
#define TIME_LOCKOUT		250		// Prevent fast button-press to max. 4 times/s



enum {
  ST_IDLE = 0,
  ST_START_L,
  ST_START_R,
  ST_MOVE_LR,
  ST_MOVE_RL,
  ST_ZONE_L,
  ST_ZONE_R,
  ST_POINT_L,
  ST_POINT_R,
  ST_RESUME_L,
  ST_RESUME_R,
  ST_WIN_L,
  ST_WIN_R,
};

static uint32_t oldtime;	// Previous' loop millis() value
static uint8_t thestate;	// Game state

static uint8_t bstate_ls;	// Button states
static uint8_t bstate_rs;
static uint8_t bstate_lp;
static uint8_t bstate_rp;
static uint8_t debtmr_ls;	// Button debounce timers
static uint8_t debtmr_rs;
static uint8_t debtmr_lp;
static uint8_t debtmr_rp;
static uint16_t timer;		// General timer
static uint16_t timeout;	// Timeout timer (auto-start and goto idle)

static uint16_t lockout_l;	// Lockout timer to prevent pushing too often
static uint16_t lockout_r;
static uint8_t ballblinkstate;	// Blinking ball at edge on/off
static uint8_t pointblinkcount;	// Blinking point when a side scores
static uint8_t ballpos;		// Current position of the ball
static uint16_t speed;		// Time between ball moves
static uint8_t speedup;		// Faster and faster replies counter
static uint8_t points_l;	// Score
static uint8_t points_r;
static uint8_t zone_l;		// Hit back zone
static uint8_t zone_r;
static uint8_t boost_l;		// Set if user boosted speed last round
static uint8_t boost_r;
static uint8_t boosted;		// Set if any user boosted until the ball reaches opposite side

static uint8_t tuneidx;		// Index to the running tune

/*
   Return the current state of a button.
   Returns non-zero on button pressed.
*/
static inline uint8_t button_is_down(uint8_t pin)
{
  switch (pin) {
    case PIN_BUT_LS:	return !debtmr_ls &amp;&amp; !bstate_ls;
    case PIN_BUT_RS:	return !debtmr_rs &amp;&amp; !bstate_rs;
    case PIN_BUT_LP:	return !debtmr_lp &amp;&amp; !bstate_lp;
    case PIN_BUT_RP:	return !debtmr_rp &amp;&amp; !bstate_rp;
  }
  return 0;
}

/*
   Debounce a button and return an event at the rising edge of the detection.
   The rising edge ensures that there is no delay from pressing the button and
   the event propagating. It is a prerequisite that the input line is not
   glitchy.
   A release event may be generated if the routine is slightly modified.
*/
static inline uint8_t do_debounce(uint8_t tdiff, uint8_t *bstate, uint8_t *debtmr, uint8_t pin, uint8_t ev)
{
  if (0 == *debtmr) {
    uint8_t state = digitalRead(pin);
    if (state != *bstate) {
      *debtmr = TIME_DEBOUNCE;
      if (!(*bstate = state))
        return ev;	// Event on High-to-Low transition of input
      // else
      //  return release_event_value
    }
  } else {
    if (*debtmr &gt;= tdiff)
      *debtmr -= tdiff;
    else
      *debtmr = 0;
  }
  return 0;
}

/*
   Timer countdown and return an event on timer reaching zero.
*/
static inline uint8_t do_timer(uint8_t tdiff, uint16_t *tmr, uint8_t ev)
{
  if (0 != *tmr) {
    if (*tmr &gt;= tdiff)
      *tmr -= tdiff;	// Timer countdown
    else
      *tmr = 0;
    // Set event when done counting
    if (0 == *tmr)
      return ev;
  }
  return 0;
}


/*
   Draw the left and right zones where the ball may be hit back.
*/
static void draw_sides()
{
  for (uint8_t i = 0; i &lt; zone_l - 1; i++) {
    one_d.setPixelColor(i, 0, 64, 64);
  }
  one_d.setPixelColor(0, 0, 64, 64);
  for (uint8_t i = 0; i &lt; zone_r - 1; i++) {
    one_d.setPixelColor(NPIXELS - 1 - i, 0, 64, 64);
  }
  one_d.setPixelColor(NPIXELS - 1, 0, 64, 64);
}

/*
   Draw the ball with a tail of five pixels in diminishing intensity.
*/
static void draw_ball(int8_t dir, uint8_t pos)
{
  uint8_t c = 255;
  for (uint8_t i = 0; i &lt; 5 &amp;&amp; pos &gt;= 0 &amp;&amp; pos &lt; NPIXELS; i++) {
    one_d.setPixelColor(pos, c, c, 0);
    c &gt;&gt;= 1;
    pos -= dir;
  }
}

/*
   Draw the playing field consisting of the zones and the points scored so far.
*/
static void draw_course(uint8_t v)
{
  one_d.clear();
  draw_sides();
  if (v) {
    for (uint8_t i = 0; i &lt; points_l; i++) {
      one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * i + 0), v, 0, 0);
      one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * i + 1), v, 0, 0);
    }
    for (uint8_t i = 0; i &lt; points_r; i++) {
      one_d.setPixelColor(NPIXELS / 2 + (2 * i + 0), 0, v, 0);
      one_d.setPixelColor(NPIXELS / 2 + (2 * i + 1), 0, v, 0);
    }
  }
}

/*
   Animate the game idle situation with following content:
   - A rainbow pattern
   - Ball bouncing left-right-left-right
   - Score animation
*/
static uint16_t ai_h;
static uint8_t ai_state;
static uint8_t ai_pos;

static void animate_idle_init(void)
{
  ai_h = 0;
  ai_state = 0;
}

#define H_STEPS	1542

static void animate_idle(void)
{
  switch (ai_state) {
    case 0:
    case 1:
    case 2:
    case 3:
      /* Rainbow pattern */
      for (uint8_t i = 0; i &lt; NPIXELS; i++) {
        uint16_t h = ai_h + (i &lt;&lt; 4);
        if (h &gt;= H_STEPS)
          h -= H_STEPS;
        uint32_t rgbcolor = one_d.ColorHSV(h, 255, 128);
        one_d.setPixelColor(i, rgbcolor);
      }
      ai_h += H_STEPS / 60;
      if (ai_h &gt;= H_STEPS) {
        ai_h -= H_STEPS;
        ai_pos = 0;
        ai_state++;
      }
      break;
    case 4:
    case 6:
      /* Ball left-to-right */
      draw_course(0);
      draw_ball(1, ai_pos++);
      if (ai_pos &gt;= NPIXELS) {
        ai_state++;
      }
      break;
    case 5:
    case 7:
      /* Ball right-to-left */
      draw_course(0);
      draw_ball(-1, --ai_pos);
      if (!ai_pos) {
        ai_state++;
      }
      break;
    case 8:
    case 10:
      /* Score blinkenlights */
      draw_course(0);
      for (uint8_t i = 0; i &lt; ai_pos; i++) {
        one_d.setPixelColor(NPIXELS / 2 - 1 - i, 255, 0, 0);
        one_d.setPixelColor(NPIXELS / 2 + i, 0, 255, 0);
      }
      if (++ai_pos &gt;= NPIXELS / 2) {
        ai_state++;
        ai_pos = 0;
      }
      break;

    case 9:
    case 11:
      draw_course(0);
      for (uint8_t i = 0; i &lt; NPIXELS / 2 - ai_pos; i++) {
        one_d.setPixelColor(NPIXELS / 2 - 1 - i, 255, 0, 0);
        one_d.setPixelColor(NPIXELS / 2 + i, 0, 255, 0);
      }
      if (++ai_pos &gt;= NPIXELS / 2) {
        ai_state++;
        ai_pos = 0;
      }
      break;

    default:
      ai_state = 0;
      break;
  }
  one_d.show();
}

/*
   Animate a winner. Flash the winning side's points.
*/
static uint8_t aw_state;
static void animate_win_init()
{
  aw_state = 0;
}

static uint8_t animate_win(uint8_t side)
{
  uint32_t clr;
  uint8_t pos;

  if (side) {
    clr = Adafruit_NeoPixel::Color(0, 255, 0);
    pos = NPIXELS / 2;
  } else {
    clr = Adafruit_NeoPixel::Color(255, 0, 0);
    pos = 0;
  }

  one_d.clear();
  if (aw_state &lt; 20) {
    if (aw_state &amp; 0x01) {
      for (uint8_t i = 0; i &lt; NPIXELS / 2; i++) {
        one_d.setPixelColor(pos + i, clr);
      }
    }
  } else if (aw_state &lt; 50) {
    for (uint8_t i = 0; i &lt; aw_state - 20; i++) {
      one_d.setPixelColor(pos + i, clr);
    }
  } else if (aw_state &lt; 80) {
    for (uint8_t i = aw_state - 50; i &lt; NPIXELS / 2; i++) {
      one_d.setPixelColor(pos + i, clr);
    }
  } else if (aw_state &lt; 110) {
    for (uint8_t i = 0; i &lt; aw_state - 80; i++) {
      one_d.setPixelColor(NPIXELS / 2 - 1 - i + pos, clr);
    }
  } else if (aw_state &lt; 140) {
    for (uint8_t i = aw_state - 110; i &lt; NPIXELS / 2; i++) {
      one_d.setPixelColor(NPIXELS / 2 - 1 - i + pos, clr);
    }
  }
  one_d.show();
  return ++aw_state &lt; 140;
}

/*
   Active game states suppress fast button pushes
*/
static uint8_t is_game_state(uint8_t s)
{
  switch (s) {
    case ST_MOVE_LR:	// If you press too soon
    case ST_MOVE_RL:
    case ST_ZONE_R:		// In the zone
    case ST_ZONE_L:
    case ST_POINT_L:	// Just got a point, delay resume
    case ST_POINT_R:
    case ST_WIN_R:		// Delay to activate the win sequence
    case ST_WIN_L:
      return 1;
    default:
      return 0;
  }
}

/*
   Set the timer to the speed of the ball and the current boost-state
*/
static inline void speed_to_timer()
{
  if (boosted)
    timer = speed * 3 / 4;
  else
    timer = speed;
  if (timer &lt; 2)
    timer = 2;
}

/*
   State transition routine. Setup prerequisites for the new state to function
   properly.
   - Handle a state's exit actions
   - Handle a state's entry actions
*/
static void set_state(uint8_t newstate)
{
  /* State exit actions */
  switch (thestate) {
    case ST_IDLE:
    case ST_WIN_L:
    case ST_WIN_R:
      points_l = points_r = 0;
      boost_l = boost_r = 0;
      zone_l = zone_r = ZONE_SIZE;
      speedup = 0;
      boosted = 0;
      break;

    case ST_START_L:
    case ST_POINT_L:
    case ST_RESUME_L:
      ballpos = 0;
      /* Serve speed not too fast */
      speed = TIME_SPEED_MIN + 5 * TIME_SPEED_INTERVAL;
      speedup = 0;
      break;

    case ST_START_R:
    case ST_POINT_R:
    case ST_RESUME_R:
      ballpos = NPIXELS - 1;
      /* Serve speed not too fast */
      speed = TIME_SPEED_MIN + 5 * TIME_SPEED_INTERVAL;
      speedup = 0;
      break;

    case ST_ZONE_L:
      /* Calculate the speed for the return */
      speed = TIME_SPEED_MIN + TIME_SPEED_INTERVAL * ballpos;
      if (++speedup / 2 &gt;= speed)
        speed = 2;
      else
        speed -= speedup / 2;
      boosted = 0;
      break;

    case ST_ZONE_R:
      /* Calculate the speed for the return */
      speed = TIME_SPEED_MIN + TIME_SPEED_INTERVAL * (NPIXELS - 1 - ballpos);
      if (++speedup / 2 &gt;= speed)
        speed = 2;
      else
        speed -= speedup / 2;
      boosted = 0;
      break;
  }

  thestate = newstate;
  /* State entry actions */
  switch (thestate) {
    case ST_IDLE:
      boost_l = boost_r = 0;
      zone_l = zone_r = ZONE_SIZE;
      animate_idle_init();
      timer = TIME_IDLE;
      break;

    case ST_START_L:
    case ST_START_R:
      draw_course(SHOW_HI);
      one_d.show();
      timer = TIME_BALL_BLINK;
      timeout = TIME_START_TIMEOUT;
      ballblinkstate = 0;
      ballpos = thestate == ST_START_L ? 0 : NPIXELS - 1;
      break;

    case ST_MOVE_LR:
    case ST_MOVE_RL:
      speed_to_timer();
      break;

    case ST_POINT_L:
    case ST_POINT_R:
      pointblinkcount = 7;
      /* Recover the zone next round */
      if (!boost_l &amp;&amp; zone_l &lt; ZONE_SIZE)
        zone_l++;
      if (!boost_r &amp;&amp; zone_r &lt; ZONE_SIZE)
        zone_r++;
      timer = TIME_POINT_BLINK;
      if (boost_l)
        boost_l--;
      if (boost_r)
        boost_r--;
      // Ensure we get to the score display before continuing
      lockout_l  = lockout_r = TIME_LOCKOUT;
      break;

    case ST_RESUME_L:
    case ST_RESUME_R:
      draw_course(SHOW_HI);
      one_d.show();
      timer = TIME_BALL_BLINK;
      timeout = TIME_RESUME_TIMEOUT;
      ballblinkstate = 0;
      break;

    case ST_WIN_L:
    case ST_WIN_R:
      // Ensure we get to the winner display before continuing
      lockout_l  = lockout_r = 2 * TIME_LOCKOUT;
      animate_win_init();
      timer = TIME_WIN_BLINK;
      tuneidx = 0;
      break;
  }
}

/*
   Arduino setup
*/
void setup()
{
  PORTB = PORTC = PORTD = 0xff;	// Enable all pull-ups so we don't have undef inputs hanging

  pinMode(PIN_BUT_LS, INPUT_PULLUP);
  pinMode(PIN_BUT_RS, INPUT_PULLUP);
  pinMode(PIN_BUT_LP, INPUT_PULLUP);
  pinMode(PIN_BUT_RP, INPUT_PULLUP);


  one_d.begin();		// Setup IO
  one_d.show();		// All leds off

  thestate = ST_IDLE;
  set_state(ST_IDLE);	// To run both exit and entry actions

  /*
     Setup sound hardware with Timer1 manually. The disabled interrupts
     in the pixel-update causes interference in the timing resulting in
     clicks in the sound output.
  */
  TCCR1A = 0;
  TCCR1B = _BV(WGM12) | _BV(CS10);
  OCR1A = 13;	// Just a value
  TCNT1 = 0;
}

/*
   Main program, called constantly and forever.

   - Handle timing and generate events
   - Run the game's state machine
*/
#define chk_ev(ev)	(events &amp; (ev))

void loop()
{
  uint32_t now;
  uint8_t tdiff = (now = millis()) - oldtime;
  uint8_t events = 0;

  /* Handle buttons and timers on (just about) every millisecond */
  if (tdiff) {
    oldtime = now;
    events |= do_debounce(tdiff, &amp;bstate_ls, &amp;debtmr_ls, PIN_BUT_LS, EV_BUT_LS_PRESS);
    events |= do_debounce(tdiff, &amp;bstate_rs, &amp;debtmr_rs, PIN_BUT_RS, EV_BUT_RS_PRESS);
    events |= do_debounce(tdiff, &amp;bstate_lp, &amp;debtmr_lp, PIN_BUT_LP, EV_BUT_LP_PRESS);
    events |= do_debounce(tdiff, &amp;bstate_rp, &amp;debtmr_rp, PIN_BUT_RP, EV_BUT_RP_PRESS);
    events |= do_timer(tdiff, &amp;timer, EV_TIMER);
    events |= do_timer(tdiff, &amp;timeout, EV_TIMEOUT);
    do_timer(tdiff, &amp;lockout_l, 0);
    do_timer(tdiff, &amp;lockout_r, 0);
  }

  if (is_game_state(thestate)) {
    // If the lockout timer is running, squash the button event
    if (lockout_l)
      events &amp;= ~EV_BUT_LS_PRESS;
    if (lockout_r)
      events &amp;= ~EV_BUT_RS_PRESS;
  }

  // A button press activates the lockout timer
  if (chk_ev(EV_BUT_LS_PRESS))
    lockout_l = TIME_LOCKOUT;
  if (chk_ev(EV_BUT_RS_PRESS))
    lockout_r = TIME_LOCKOUT;

  switch (thestate) {
    // Nothing to do
    case ST_IDLE:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_START_L);
      } else if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_START_R);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_IDLE;
        animate_idle();
      }
      break;

    // Game is started, waiting for left player to serve the ball
    case ST_START_L:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_MOVE_LR);
      } else if (chk_ev(EV_TIMEOUT)) {
        set_state(ST_IDLE);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // Game is started, waiting for right player to serve the ball
    case ST_START_R:
      if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_MOVE_RL);
      } else if (chk_ev(EV_TIMEOUT)) {
        set_state(ST_IDLE);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // Ball is moving left-to-right outside the playback zone
    case ST_MOVE_LR:
      if (chk_ev(EV_TIMER)) {

        speed_to_timer();
        draw_course(SHOW_LO);
        draw_ball(1, ballpos);
        one_d.show();
        ballpos++;
        if (NPIXELS - 1 - ballpos &lt;= zone_r)
          set_state(ST_ZONE_R);
      }
      break;

    // Ball is moving right-to-left outside the playback zone
    case ST_MOVE_RL:
      if (chk_ev(EV_TIMER)) {

        speed_to_timer();
        draw_course(SHOW_LO);
        draw_ball(-1, ballpos);
        one_d.show();
        ballpos--;
        if (ballpos &lt;= zone_l)
          set_state(ST_ZONE_L);
      }
      break;

    // Ball is in the left playback zone, waiting for hit/score
    case ST_ZONE_L:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_MOVE_LR);
        // Changing speed is done after the state-change's exit/entry action
        if (zone_l &gt; 1 &amp;&amp; button_is_down(PIN_BUT_LP)) {
          zone_l--;
          boosted = 1;
          speed_to_timer();
          boost_l++;
        }
      } else if (chk_ev(EV_TIMER)) {
        if (!ballpos) {
          if (++points_r &gt;= WIN_POINTS)
            set_state(ST_WIN_R);
          else
            set_state(ST_POINT_R);
        } else {
          speed_to_timer();
          ballpos--;
        }
        draw_course(SHOW_LO);
        draw_ball(-1, ballpos);
        one_d.show();
      }
      break;

    // Ball is in the right playback zone, waiting for hit/score
    case ST_ZONE_R:
      if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_MOVE_RL);
        // Changing speed is done after the state-change's exit/entry action
        if (zone_r &gt; 1 &amp;&amp; button_is_down(PIN_BUT_RP)) {
          zone_r--;
          speed_to_timer();
          boosted = 1;
          boost_r++;
        }
      } else if (chk_ev(EV_TIMER)) {
        if (ballpos == NPIXELS - 1) {

          if (++points_l &gt;= WIN_POINTS)
            set_state(ST_WIN_L);
          else
            set_state(ST_POINT_L);
        } else {
          speed_to_timer();
          ballpos++;
        }
        draw_course(SHOW_LO);
        draw_ball(1, ballpos);
        one_d.show();
      }
      break;

    // Left player scored, animate point
    case ST_POINT_L:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_RESUME_L);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_POINT_BLINK;
        draw_course(SHOW_HI);
        if (!(pointblinkcount &amp; 0x01)) {
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 0), 0, 0, 0);
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 1), 0, 0, 0);
        } else {
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 0), 255, 0, 0);
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 1), 255, 0, 0);
        }
        one_d.show();
        if (!--pointblinkcount)
          set_state(ST_RESUME_L);
      }
      break;

    // Right player scored, animate point
    case ST_POINT_R:
      if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_RESUME_R);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_POINT_BLINK;
        draw_course(SHOW_HI);
        if (!(pointblinkcount &amp; 0x01)) {
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 0), 0, 0, 0);
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 1), 0, 0, 0);
        } else {
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 0), 0, 255, 0);
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 1), 0, 255, 0);
        }
        one_d.show();
        if (!--pointblinkcount)
          set_state(ST_RESUME_R);
      }
      break;

    // Left player previously scored and must serve again (or timeout to auto-serve)
    case ST_RESUME_L:
      if (chk_ev(EV_BUT_LS_PRESS | EV_TIMEOUT)) {
        set_state(ST_MOVE_LR);

      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // Right player previously scored and must serve again (or timeout to auto-serve)
    case ST_RESUME_R:
      if (chk_ev(EV_BUT_RS_PRESS | EV_TIMEOUT)) {
        set_state(ST_MOVE_RL);

      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // A player won the game, animate the winning side
    case ST_WIN_L:
    case ST_WIN_R:

      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_START_L);
      } else if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_START_R);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_WIN_BLINK;
        if (!animate_win(thestate == ST_WIN_R))
          set_state(ST_IDLE);
      }
      break;

    // If we get confused, start at idle...
    default:
      set_state(ST_IDLE);
      break;
  }



}

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
         <script type="text/javascript">
              // LIGHT BOX FOR VIDEOS
              // https://github.com/biati-digital/glightbox
              const main = document.getElementsByTagName('main')[0];
              var collectionOrNodes = main.getElementsByTagName('a');
              var a = Array.prototype.slice.call( collectionOrNodes );
              //console.log("Elements in main: "+a.length);
              a.forEach(function(currentElement){ 
                
                if ( currentElement.href.includes("youtube.com") || currentElement.href.includes("vimeo.com" ) ) {
                    currentElement.classList.add("glightboxed")
                }
                
                 });


                    var lightbox = GLightbox({
                        selector: '.glightboxed',
                        touchNavigation: true,
                        loop: false,
                        autoplayVideos: false,
                    });
                    lightbox.on('open', (target) => {
                        console.log('lightbox opened');
                    });
          </script>
          <script type="text/javascript">
              function altTextToImageCaption() {
                  let imgs = document.getElementsByTagName('img');
                  for (var i = 0; i < imgs.length; i++) {
                    var att = imgs[i].attributes.getNamedItem('alt');
                    if (!att) continue;
                    var alt = att.value;
                    if (!alt) continue;
                    //if (!alt.startsWith('Fig ')) continue;
                    var cap = document.createElement('div');
                    cap.setAttribute('class', 'imageCaption');
                    cap.appendChild(document.createTextNode(alt));
                    imgs[i].parentNode.insertBefore(cap, imgs[i].nextSibling);
                  }
                }
                altTextToImageCaption();
          </script>

    </body>
</html>
