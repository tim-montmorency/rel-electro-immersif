<!DOCTYPE HTML>
<html lang="fr" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
            <link rel="stylesheet" href="glightbox/dist/css/glightbox.min.css" />
           <script src="glightbox/dist/js/glightbox.min.js"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="couverture.html"><strong aria-hidden="true">1.</strong> Couverture</a></li><li class="chapter-item expanded "><a href="rel-electro-immersif.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="osc_espace_immersif/osc_espace_immersif.html"><strong aria-hidden="true">3.</strong> Objectif final</a></li><li class="chapter-item expanded affix "><li class="part-title">Électronique</li><li class="chapter-item expanded "><a href="electricite/electricite.html"><strong aria-hidden="true">4.</strong> Électricité</a></li><li class="chapter-item expanded "><a href="schemas_circuits/schemas_circuits.html"><strong aria-hidden="true">5.</strong> Schémas de circuit</a></li><li class="chapter-item expanded "><a href="platine_experimentation/platine_experimentation.html"><strong aria-hidden="true">6.</strong> Platine d'expérimentation</a></li><li class="chapter-item expanded "><a href="erreurs_fatales/erreurs_fatales.html"><strong aria-hidden="true">7.</strong> Erreurs fatales</a></li><li class="chapter-item expanded "><a href="del/del.html"><strong aria-hidden="true">8.</strong> DEL</a></li><li class="chapter-item expanded "><a href="resistance/resistance.html"><strong aria-hidden="true">9.</strong> Résistance</a></li><li class="chapter-item expanded "><a href="alimenter_del/alimenter_del.html"><strong aria-hidden="true">10.</strong> Alimenter une DEL</a></li><li class="chapter-item expanded "><a href="micro-soudure/micro-soudure.html"><strong aria-hidden="true">11.</strong> Micro-soudure</a></li><li class="chapter-item expanded "><a href="multimetre/multimetre.html"><strong aria-hidden="true">12.</strong> Multimètre</a></li><li class="chapter-item expanded affix "><li class="part-title">Cartes Arduino</li><li class="chapter-item expanded "><a href="arduino_cartes/arduino_cartes.html"><strong aria-hidden="true">13.</strong> Modèles de cartes</a></li><li class="chapter-item expanded "><a href="arduino_nano/arduino_nano.html"><strong aria-hidden="true">14.</strong> Cartes Arduino Nano</a></li><li class="chapter-item expanded affix "><li class="part-title">Arduino IDE</li><li class="chapter-item expanded "><a href="arduino-ide/fenetre_principale.html"><strong aria-hidden="true">15.</strong> Fenêtre principale</a></li><li class="chapter-item expanded "><a href="arduino-ide_configuration_nano/arduino-ide_configuration_nano.html"><strong aria-hidden="true">16.</strong> Configuration du port</a></li><li class="chapter-item expanded "><a href="arduino-ide_test_blink/arduino-ide_test_blink.html"><strong aria-hidden="true">17.</strong> Blink: le code test universel</a></li><li class="chapter-item expanded affix "><li class="part-title">Algorithmie I</li><li class="chapter-item expanded "><a href="arduino_code/arduino_code.html"><strong aria-hidden="true">18.</strong> Le code Arduino</a></li><li class="chapter-item expanded "><a href="arduino_millis/arduino_millis.html"><strong aria-hidden="true">19.</strong> Mesurer le temps</a></li><li class="chapter-item expanded "><a href="intervalle/intervalle.html"><strong aria-hidden="true">20.</strong> Intervalle de temps</a></li><li class="chapter-item expanded affix "><li class="part-title">Les sorties numériques</li><li class="chapter-item expanded "><a href="sortie_numerique/sortie_numerique.html"><strong aria-hidden="true">21.</strong> Sortie numérique</a></li><li class="chapter-item expanded "><a href="arduino_exemple_del/arduino_exemple_del.html"><strong aria-hidden="true">22.</strong> Contrôle d'une DEL</a></li><li class="chapter-item expanded affix "><li class="part-title">Algorithmie II</li><li class="chapter-item expanded "><a href="arduino_deboguer/arduino_deboguer.html"><strong aria-hidden="true">23.</strong> Déboguage série ASCII</a></li><li class="chapter-item expanded affix "><li class="part-title">Les entrées numériques</li><li class="chapter-item expanded "><a href="entree_numerique/entree_numerique.html"><strong aria-hidden="true">24.</strong> Entrée numérique</a></li><li class="chapter-item expanded "><a href="interrupteur/interrupteur.html"><strong aria-hidden="true">25.</strong> Interrupteur</a></li><li class="chapter-item expanded "><a href="bouton_poussoir/bouton_poussoir.html"><strong aria-hidden="true">26.</strong> Bouton poussoir</a></li><li class="chapter-item expanded "><a href="bouton_arcade/bouton_arcade.html"><strong aria-hidden="true">27.</strong> Bouton d'arcade</a></li><li class="chapter-item expanded affix "><li class="part-title">Algorithmie III</li><li class="chapter-item expanded "><a href="changement/changement.html"><strong aria-hidden="true">28.</strong> Changement de valeur</a></li><li class="chapter-item expanded "><a href="envoi_optimal_de_valeur/envoi_optimal_de_valeur.html"><strong aria-hidden="true">29.</strong> Envoi optimal de valeur</a></li><li class="chapter-item expanded affix "><li class="part-title">Les entrées analogiques</li><li class="chapter-item expanded "><a href="entree_analogique/entree_analogique.html"><strong aria-hidden="true">30.</strong> Entrée analogique</a></li><li class="chapter-item expanded "><a href="potentiometre/potentiometre.html"><strong aria-hidden="true">31.</strong> Potentiomètre</a></li><li class="chapter-item expanded "><a href="photoresistance/photoresistance.html"><strong aria-hidden="true">32.</strong> Photorésistance</a></li><li class="chapter-item expanded affix "><li class="part-title">Les sorties analogiques</li><li class="chapter-item expanded "><a href="sortie_analogique/sortie_analogique.html"><strong aria-hidden="true">33.</strong> Sortie analogique</a></li><li class="chapter-item expanded "><a href="chandelle/chandelle.html"><strong aria-hidden="true">34.</strong> Simuler une chandelle</a></li><li class="chapter-item expanded affix "><li class="part-title">OSC</li><li class="chapter-item expanded "><a href="osc/osc.html"><strong aria-hidden="true">35.</strong> Open Sound Control (OSC)</a></li><li class="chapter-item expanded "><a href="microosc/microosc.html"><strong aria-hidden="true">36.</strong> MicroOsc</a></li><li class="chapter-item expanded "><a href="osc_slip/osc_slip.html"><strong aria-hidden="true">37.</strong> OSC SLIP avec MicroOsc</a></li><li class="chapter-item expanded affix "><li class="part-title">OSC SLIP</li><li class="chapter-item expanded "><a href="pd/osc_slip.html"><strong aria-hidden="true">38.</strong> OSC SLIP : Pure Data (PD)</a></li><li class="chapter-item expanded "><a href="max/max_osc_slip.html"><strong aria-hidden="true">39.</strong> OSC SLIP : Cycling '74 Max</a></li><li class="chapter-item expanded "><a href="osc_slip_web/osc_slip_web.html"><strong aria-hidden="true">40.</strong> OSC SLIP : Web/Node.js</a></li><li class="chapter-item expanded affix "><li class="part-title">OSC UDP</li><li class="chapter-item expanded "><a href="pd/relais_osc_slip_udp.html"><strong aria-hidden="true">41.</strong> Relais SLIP⇄UDP avec PD</a></li><li class="chapter-item expanded "><a href="max/relais_osc_slip_udp.html"><strong aria-hidden="true">42.</strong> Relais SLIP⇄UDP avec Max</a></li><li class="chapter-item expanded "><a href="pd/pd_osc_udp.html"><strong aria-hidden="true">43.</strong> OSC UDP : Pure Data</a></li><li class="chapter-item expanded "><a href="max/max_osc_udp.html"><strong aria-hidden="true">44.</strong> OSC UDP : Cycling '74 Max</a></li><li class="chapter-item expanded "><a href="vcv_rack/vcv_rack_osc.html"><strong aria-hidden="true">45.</strong> OSC UDP : VCV Rack</a></li><li class="chapter-item expanded "><a href="osc_udp_unity/osc_udp_unity.html"><strong aria-hidden="true">46.</strong> OSC UDP : Unity</a></li><li class="chapter-item expanded "><a href="touchdesigner/td_osc_udp.html"><strong aria-hidden="true">47.</strong> OSC UDP : TouchDesigner</a></li><li class="chapter-item expanded affix "><li class="part-title">Les bandes de DEL</li><li class="chapter-item expanded "><a href="bande_del/bande_del.html"><strong aria-hidden="true">48.</strong> Bande de DEL</a></li><li class="chapter-item expanded "><a href="pong_1d/pong_1d.html"><strong aria-hidden="true">49.</strong> Pong 1D</a></li><li class="chapter-item expanded "><a href="bande_del_osc/bande_del_osc.html"><strong aria-hidden="true">50.</strong> Contrôle par OSC</a></li><li class="chapter-item expanded affix "><li class="part-title">Déploiement</li><li class="chapter-item expanded "><a href="raspberry_pi/raspberry_pi.html"><strong aria-hidden="true">51.</strong> Raspberry PI</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div id="ToC"></div>
                        <h1 id="couverture"><a class="header" href="#couverture">Couverture</a></h1>
<p><img src="./couverture.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notes-de-cours-sur-lintégration-de-lélectronique-aux-espaces-immersifs"><a class="header" href="#notes-de-cours-sur-lintégration-de-lélectronique-aux-espaces-immersifs">Notes de cours sur l'intégration de l'électronique aux espaces immersifs</a></h1>
<h2 id="description"><a class="header" href="#description">Description</a></h2>
<p>Cette ressource éducative libre (REL) regroupe des <strong>notes de cours</strong> sur l'intégration de l'électronique aux espaces immersifs dans un contexte de création multimédia. Elle traite de l’intégration de capteurs et actionneurs dans un grand espace où l'ordinateur multimédia, qui doit coordonner les aspects audiovisuels (les projections visuelles, les éclairages, les effets et les diffusions sonores), est distant.</p>
<p>Ces notes de cours peuvent être particulièrement utiles dans le cadre d'un cours d'enseignement supérieur dans une discipline qui traite d'art et d'électronique.</p>
<h2 id="version"><a class="header" href="#version">Version</a></h2>
<p>Cette documentation est publiée sur un support adapté à la mise à jour et à la contribution par la communauté. </p>
<p><strong>Toute personne est invitée à contribuer au code source à l'adresse suivante : <a href="https://github.com/tim-montmorency/rel-electro-immersif">github.com/tim-montmorency/rel-electro-immersif</a></strong>.</p>
<p>La publication la plus à jour, c'est-à-dire celle en développement, sera toujours disponible à l'adresse suivante : <a href="https://tim-montmorency.com/rel-electro-immersif/">tim-montmorency.com/rel-electro-immersif</a>.</p>
<p>À des fins d'archivage, des versions statiques sont sporadiquement publiées :</p>
<ul>
<li>Version 1 (1er mars 2023) : <a href="https://tim-montmorency.com/rel-electro-immersif/v1">tim-montmorency.com/rel-electro-immersif/v1</a>.</li>
</ul>
<h2 id="format"><a class="header" href="#format">Format</a></h2>
<p>Ces notes ont été formatées pour être directement projetées sur grand écran dans le cadre d'une classe. Les éléments visuels ont été privilégiés et le texte y est épuré et agrandi pour permettre une meilleure lecture de loin. </p>
<p>Le contenu a été subdivisé en sections non imbriquées pour que le contenu soit plus accessible et puisse servir de référence aux étudiants tout au long de leur formation ou par la suite.</p>
<p><strong>Il n'est pas recommandé d'imprimer ce document puisqu'il n'a pas été prévu pour cette utilisation et plusieurs fonctionnalités et avantages de ce format seront perdus.</strong></p>
<h2 id="crédits"><a class="header" href="#crédits">Crédits</a></h2>
<p>Ce projet a été initié en 2022 par <a href="http://t-o-f.info">Thomas O Fredericks</a> avec la collaboration de Guillaume Arseneault, tous les deux professeurs au département de <a href="https://www.cmontmorency.qc.ca/programmes/nos-programmes-detudes/techniques/techniques-dintegration-multimedia/description-du-programme/">Techniques d'intégration multimédia</a> du <a href="https://www.cmontmorency.qc.ca/">Collège Montmorency</a>.</p>
<p>Le suivi de projet au Collège Montmorency a été effectué par :</p>
<ul>
<li>Valérie Jacques, spécialiste en moyens et techniques d'enseignement aux affaires étudiantes.</li>
<li>Géraldine Lussier, conseillère pédagogique au bureau de la réussite et de l'innovation pédagogique.</li>
</ul>
<p>La réalisation de cette ressource a été rendue possible grâce à un financement de la <a href="https://fabriquerel.org/rel/">fabrique REL</a>.</p>
<h2 id="licence"><a class="header" href="#licence">Licence</a></h2>
<p><img src="./licence.svg" alt="" /></p>
<p>Pour citer cette première version de la REL, veuillez utiliser la formule suivante :</p>
<p><code>Fredericks, T. O. et Arseneault, G. (2023). Notes de cours sur l’intégration de l’électronique aux espaces immersifs. Collège Montmorency. CC BY-NC.</code></p>
<h2 id="conventions-de-documentation"><a class="header" href="#conventions-de-documentation">Conventions de documentation</a></h2>
<p>Les noms de variables qui sont destinées à être créées par l'utilisateur doivent être précédés de <em>mon</em> ou <em>ma</em> pour les différencier des noms réservés du langage de programmation.</p>
<p>Exemples :</p>
<pre><code class="language-arduino">int maBrocheDel = 10;
</code></pre>
<pre><code class="language-arduino">void monTraiterMessage( microOscMessage monMessageOsc ) {
	...
}
</code></pre>
<pre><code class="language-arduino">MicroOsc monMicroOsc;
</code></pre>
<h2 id="technologies-utilisées-pour-la-réalisation-de-cette-ressource"><a class="header" href="#technologies-utilisées-pour-la-réalisation-de-cette-ressource">Technologies utilisées pour la réalisation de cette ressource</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/mdBook/">mdBook</a> pour convertir les textes du format Markdown au format HTML.</li>
<li><a href="https://docs.github.com/en/actions">GitHub Actions</a> pour automatiser le déploiement des fichiers sources au site <a href="https://tim-montmorency.com/rel-electro-immersif/">tim-montmorency.com/rel-electro-immersif</a>.</li>
<li><a href="https://fritzing.org/">Fritzing</a> pour les dessins de circuits.</li>
<li>Du JavaScript sur mesure pour ajouter automatiquement la description des figures sous celles-ci et pour ajouter une petite table des matières lorsque le contenu l'exige.</li>
<li><a href="https://github.com/biati-digital/glightbox">GLightbox</a> pour permettre l'intégration de la lecture des vidéos directement dans le site.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objectif-final"><a class="header" href="#objectif-final">Objectif final</a></h1>
<h2 id="description-de-lobjectif-final"><a class="header" href="#description-de-lobjectif-final">Description de l'objectif final</a></h2>
<p>Toute la matière de cette REL a été choisie et ordonnée pour diriger l'apprenant dans la réalisation d'un objectif final. Cet objectif est présenté ici, tout au début, pour donner un sens, une direction et une présentation de l'étendue des savoirs contenus dans cette ressource.</p>
<p><img src="osc_espace_immersif/./integration_electro_espace.png" alt="Comment intégrer l'électronique à un espace immersif?" /></p>
<p>Cette REL propose une solution pour l'intégration de l'électronique aux espaces immersifs dans un contexte de création multimédia. C'est-à-dire l’intégration de capteurs et actionneurs dans un grand espace où l'ordinateur multimédia, qui doit coordonner les aspects audiovisuels (les projections visuelles, les éclairages, les effets et les diffusions sonores), est distant. </p>
<p>La solution proposée essaie de rester peu onéreuse et accessible tout en demeurant fiable (en éliminant les sources d’erreurs potentielles des communications) et très compatible avec les outils de création multimédia.</p>
<p>À cette fin, l’environnement de développement choisi est Arduino IDE, le modèle de carte l’Arduino Nano et le protocole de communication l’Open Sound Control (OSC).</p>
<p>À noter que cette documentation est entièrement compatible avec des cartes qui communiquent par Wi-Fi ou par Ethernet comme les cartes équipées d'ESP32. Les cartes Arduino ESP32 sont en effet à privilégier à long terme, mais elles sont plus difficiles à maitriser. Leur utilisation sera intégrée à cette ressource ultérieurement.</p>
<h2 id="connectique-osc-de-lobjectif-final"><a class="header" href="#connectique-osc-de-lobjectif-final">Connectique OSC de l'objectif final</a></h2>
<p>Le schéma suivant présente le système de connexion et de communication choisi :
<img src="osc_espace_immersif/./osc_espace_immersif_connectique.svg" alt="Connectique OSC pour un espace immersif" /></p>
<h2 id="circuit-électronique-de-lobjectif-final"><a class="header" href="#circuit-électronique-de-lobjectif-final">Circuit électronique de l'objectif final</a></h2>
<h3 id="illustration-du-circuit-électronique"><a class="header" href="#illustration-du-circuit-électronique">Illustration du circuit électronique</a></h3>
<p>L'illustration suivante présente le circuit que les étudiants devront réaliser pour l'intégration aux espaces immersifs :
<img src="osc_espace_immersif/./osc_espace_immersif_illustration.png" alt="Illustration du circuit pour l'intégration de l'électronique à un espace immersif" /></p>
<h3 id="schéma-du-circuit-électronique"><a class="header" href="#schéma-du-circuit-électronique">Schéma du circuit électronique</a></h3>
<p>De façon générale, les schémas de circuit seront privilégiés. Le schéma suivant représente le même circuit que l'illustration ci-haut :
<img src="osc_espace_immersif/./osc_espace_immersif_schema.png" alt="Schéma du circuit pour l'intégration de l'électronique à un espace immersif" /></p>
<h2 id="code-arduino-de-lobjectif-final"><a class="header" href="#code-arduino-de-lobjectif-final">Code Arduino de l'objectif final</a></h2>
<p>Pour assurer la connexion avec l’espace immersif, voici le code qui sera exécuté sur l’Arduino :</p>
<pre><code class="language-arduino">// MicroOsc_Demo_SLIP
// by Thomas O Fredericks
// 2023-02-20

// WHAT IS DOES
// ======================
// OSC communication example.
//
// OSC messages received by the Arduino :
// - /led int -&gt; turn off (0) or on (1) a LED 
// - /pwm int -&gt; set the pwm (0-255) of the arcade button LED 
//
// OSC messages sent by the Arduino :
// - /pot int -&gt; sends the value of a potentiometer 
// - /photo int -&gt; sends the value of a photocell
// - /button int -&gt; sends the value of a button

// HARDWARE REQUIREMENTS
// ==================
// - POTENTIOMETER connected to analog pin A0
// - POTOCELL (with voltage resistor) connected to analog pin A1
// - Illuminated arcade BUTTON with it's switch connected to pin 2
//   and it's LED connected to pin 3 (will be PWM modulated)
// - LED (and matching resistor) connected to pin 5 (will be turned off or on)

// REQUIRED LIBRARIES
// ==================
// - MicroOsc

// REQUIRED CONFIGURATION
// ======================
// - Set the baud of your computer's serial connection to 115200



#include &lt;MicroOscSlip.h&gt;

// THE NUMBER 64 BETWEEN THE &lt; &gt; SYMBOLS  BELOW IS THE MAXIMUM NUMBER OF BYTES RESERVED FOR INCOMMING MESSAGES.
// MAKE SURE THIS NUMBER OF BYTES CAN HOLD THE SIZE OF THE MESSAGE YOUR ARE RECEIVING IN ARDUINO.
// OUTGOING MESSAGES ARE WRITTEN DIRECTLY TO THE OUTPUT AND DO NOT NEED ANY RESERVED BYTES.
MicroOscSlip&lt;64&gt; myMicroOsc(&amp;Serial);  // CREATE AN INSTANCE OF MicroOsc FOR SLIP MESSAGES

unsigned long myChronoStart = 0;  // VARIABLE USED TO LIMIT THE SPEED OF THE loop() FUNCTION.

// POTENTIOMETER
int myPotPin = A0;
int myPotStoredValue = 0;

// PHOTOCELL
int myPhotoPin = A1;
int myPhotoStoredValue = 0;

// BUTTON
int myButtonPin = 2;
int myButtonSotredValue = 0;

// BUTON LED
int myButtonLedPin = 3;  // PIN MUST SUPPORT PWM

// LED
int myLedPin = 5;

/********
  SETUP
*********/
void setup() {
  Serial.begin(115200);                // START SERIAL COMMUNICATION
  pinMode(myPotPin, INPUT);            // POTENTIOMETER: ANALOG INPUT
  pinMode(myPhotoPin, INPUT);          // PHOTOCELL: ANALOG INPUT
  pinMode(myButtonPin, INPUT_PULLUP);  // BUTTON: DIGITAL INPUT
  pinMode(myButtonLedPin, OUTPUT);     // LED: DIGITAL OUTPUT
  pinMode(myLedPin, OUTPUT);           // LED: DIGITAL OUTPUT
}

/****************
  ON OSC MESSAGE
*****************/
void myOnOscMessageReceived(MicroOscMessage&amp; oscMessage) {
  
  if (oscMessage.checkOscAddress(&quot;/led&quot;)) {  // IF THE ADDRESS IS /led
    int newValue = oscMessage.nextAsInt();  // GET NEW VALUE AS INT
    digitalWrite(myLedPin, newValue);       // SET LED OUTPUT TO VALUE (DIGITAL: OFF/ON)
    
  } else if (oscMessage.checkOscAddress(&quot;/buttonLed&quot;)) {  // IF THE ADDRESS IS /buttonLed
    int newValue = oscMessage.nextAsInt();  // GET NEW VALUE AS INT
    analogWrite(myButtonLedPin, newValue);       // SET LED OUTPUT TO VALUE (ANALOG/PWM: 0-255)

  }
  
}

/****************
  POTENTIOMETER UPDATE
****************/
void myPotUpdateValueAndSendIfChanged() {
  int newValue = analogRead(myPotPin);             // READ NEW VALUE
  if (newValue != myPotStoredValue) {              // IF NEW VALUE DIFFERENT THAN STORED VALUE
    myPotStoredValue = newValue;                   // STORE NEW VALUE
    myMicroOsc.sendInt(&quot;/pot&quot;, myPotStoredValue);  // SEND UPDATED VALUE
  }
}

/*********************
  PHOTOCELL UPDATE
**********************/
void myPhotoUpdateValueAndSendIfChanged() {
  int newValue = analogRead(myPhotoPin);               // READ CURRENT VALUE
  if (newValue != myPhotoStoredValue) {                // IF NEW VALUE DIFFERENT THAN STORED VALUE
    myPhotoStoredValue = newValue;                     // STORE NEW VALUE
    myMicroOsc.sendInt(&quot;/photo&quot;, myPhotoStoredValue);  // SEND UPDATED VALUE
  }
}

/*********************
  BUTTON UPDATE
**********************/
void myButtonUpdateValueAndSendIfChanged() {
  int newValue = digitalRead(myButtonPin);               // READ CURRENT VALUE
  if (newValue != myButtonSotredValue) {                 // IF NEW VALUE DIFFERENT THAN STORED VALUE
    myButtonSotredValue = newValue;                      // STORE NEW VALUE
    myMicroOsc.sendInt(&quot;/button&quot;, myButtonSotredValue);  // SEND UPDATED VALUE
  }
}

/*******
  LOOP
********/
void loop() {

  myMicroOsc.onOscMessageReceived(myOnOscMessageReceived);  // TRIGGER OSC RECEPTION

  if (millis() - myChronoStart &gt;= 50) {  // IF 50 MS HAVE ELLAPSED
    myChronoStart = millis();            // RESTART CHRONO

    myPotUpdateValueAndSendIfChanged();  // POTENTIOMETER UPDATE

    myPhotoUpdateValueAndSendIfChanged();  // PHOTOCELL UPDATE

    myButtonUpdateValueAndSendIfChanged();  // BUTTON UPDATE
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lélectricité"><a class="header" href="#lélectricité">L'électricité</a></h1>
<h2 id="le-courant-électrique"><a class="header" href="#le-courant-électrique">Le courant électrique</a></h2>
<p>Le courant électrique est un déplacement d’électrons dans un milieu conducteur.</p>
<p>Pour que ces électrons se déplacent, il faut créer <strong>une différence du nombre d'électrons entre les deux extrémités du circuit électrique</strong>. C'est ce qu'on appelle une <strong>différence de potentiel</strong>. </p>
<h2 id="alimentation"><a class="header" href="#alimentation">Alimentation</a></h2>
<p>Pour créer cette différence de potentiel, on utilise une <strong>alimentation électrique</strong> qui peut prendre la forme d'une batterie, alimentation USB, panneau solaire, prise électrique , etc. </p>
<p><img src="electricite/batterie_aa_electrons.svg" alt="Illustration du débalancement des électrons dans une batterie AA (JIMBLOM, s. d.)" /></p>
<p>Une alimentation possède deux pôles. L'un <strong>positif</strong> (avec un potentiel <em>haut</em>) et l'autre <strong>négatif</strong> (avec un potentiel <em>bas</em>). </p>
<p><img src="electricite/alimentation_12v.svg" alt="Une alimentation 12V à courant continu (CC)" /></p>
<h2 id="boucle-électrique"><a class="header" href="#boucle-électrique">Boucle électrique</a></h2>
<p>Pour circuler, le courant doit suivre une boucle entre les deux pôles de l'alimentation.</p>
<p><img src="electricite/circuit_electrons.svg" alt="Les électrons voyagent en se tirant les uns derrières les autres comme les wagons d'un train (JIMBLOM, s. d.)" /></p>
<h2 id="principales-grandeurs-électriques"><a class="header" href="#principales-grandeurs-électriques">Principales grandeurs électriques</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Grandeur</th><th>Symbole</th><th>Unité</th><th>Analogie</th></tr></thead><tbody>
<tr><td>Tension</td><td>U</td><td>Volts (V)</td><td>La <em>pression</em> qui génère la circulation des électrons</td></tr>
<tr><td>Intensité</td><td>I</td><td>Ampères (A)</td><td>La <em>quantité d’électrons</em> qui circule à un point</td></tr>
<tr><td>Résistance</td><td>R</td><td>Ohms (Ω)</td><td>Réduit la circulation des électrons (réduit la pression et la quantité)</td></tr>
<tr><td>Puissance</td><td>P</td><td>Watts (W)</td><td>La puissance résultant de la <em>pression</em> multipliée par la <em>quantité</em></td></tr>
</tbody></table>
</div>
<h2 id="analogie-de-leau"><a class="header" href="#analogie-de-leau">Analogie de l'eau</a></h2>
<h3 id="pression-de-leau--tension-électrique"><a class="header" href="#pression-de-leau--tension-électrique">Pression de l'eau ≈ tension électrique</a></h3>
<p><img src="electricite/./analogie_eau_tension.svg" alt="La pression de l'eau est similaire à la tension électrique (CTAYLOR, s. d.)" /></p>
<h3 id="quantité-deau--intensité-électrique"><a class="header" href="#quantité-deau--intensité-électrique">Quantité d'eau ≈ intensité électrique</a></h3>
<p><img src="electricite/./analogie_eau_intensite.svg" alt="La quantité d'eau est similaire à l'intensité électrique (CTAYLOR, s. d.)" /></p>
<h3 id="Étranglement-de-tuyau--intensité-électrique"><a class="header" href="#Étranglement-de-tuyau--intensité-électrique">Étranglement de tuyau ≈ intensité électrique</a></h3>
<p><img src="electricite/./analogie_eau_resistance.svg" alt="Un étranglement dans le tuyau est similaire à l'intensité électrique (CTAYLOR, s. d.)" /></p>
<h2 id="relations-mathématiques-entre-les-principales-grandeurs-électriques"><a class="header" href="#relations-mathématiques-entre-les-principales-grandeurs-électriques">Relations mathématiques entre les principales grandeurs électriques</a></h2>
<p><img src="electricite/./grandeurs_electriques_relations.svg" alt="Relations mathématiques entre les principales grandeurs électriques (adapté de CTAYLOR, s. d.)" /></p>
<p><img src="electricite/./analogie_eau_exemple.svg" alt="Exemple des relations entre les principales grandeurs électriques (CTAYLOR, s. d.)" /></p>
<h2 id="vidéo-complémentaire"><a class="header" href="#vidéo-complémentaire">Vidéo complémentaire</a></h2>
<ul>
<li>C’est pas sorcier. (2015, 7 septembre). Électricité – C’est pas sorcier [vidéo]. YouTube. <a href="https://www.youtube.com/watch?v=efQW-ZmpyZs">https://www.youtube.com/watch?v=efQW-ZmpyZs</a></li>
</ul>
<h2 id="références-et-sources-des-images"><a class="header" href="#références-et-sources-des-images">Références et sources des images</a></h2>
<ul>
<li>CTAYLOR. (s. d.). Voltage, Current, Resistance, and Ohm’s Law. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/voltage-current-resistance-and-ohms-law/all">https://learn.sparkfun.com/tutorials/voltage-current-resistance-and-ohms-law/all</a></li>
<li>JIMBLOM. (s. d.). What is Electricity ? Sparkfun. <a href="https://learn.sparkfun.com/tutorials/what-is-electricity">https://learn.sparkfun.com/tutorials/what-is-electricity</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schémas-de-circuits"><a class="header" href="#schémas-de-circuits">Schémas de circuits</a></h1>
<p>Un schéma de circuit est une représentation schématique de la connectique d’un circuit électrique. Les composants électriques sont représentés en tant que symboles pour faciliter leur reproduction et leur identification. Ce qui est important est de représenter comment les éléments sont reliés entre eux et non leur disposition exacte dans l’espace. </p>
<h2 id="symboles-dalimentation"><a class="header" href="#symboles-dalimentation">Symboles d'alimentation</a></h2>
<h3 id="un-symbole-qui-regroupe-les-deux-pôles"><a class="header" href="#un-symbole-qui-regroupe-les-deux-pôles">Un symbole qui regroupe les deux pôles</a></h3>
<p><img src="schemas_circuits/./symbole_alimentation_batterie.svg" alt="Un symbole représentant une batterie" /></p>
<p><img src="schemas_circuits/./symbole_alimentation_cc.svg" alt="Un symbole représentant une alimentation à courant continu" /></p>
<h3 id="deux-symboles-séparés-qui-représentent-les-deux-pôles-de-la-même-alimentation"><a class="header" href="#deux-symboles-séparés-qui-représentent-les-deux-pôles-de-la-même-alimentation">Deux symboles séparés qui représentent les deux pôles de la même alimentation</a></h3>
<p><img src="schemas_circuits/./symbole_alimentation_paire_v+.svg" alt="Une paire de symboles qui représente les deux pôles d'une même alimentation générique" /></p>
<p><img src="schemas_circuits/./symbole_alimentation_paire_5v.svg" alt="Une paire de symboles qui représente les deux pôles d'une même alimentation 5V" /></p>
<h2 id="infomation-complémentaire-sur-la-lecture-de-schémas"><a class="header" href="#infomation-complémentaire-sur-la-lecture-de-schémas">Infomation complémentaire sur la lecture de schémas</a></h2>
<ul>
<li>JIMBLOM. (s. d.). How to Read a Schematic. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/how-to-read-a-schematic">https://learn.sparkfun.com/tutorials/how-to-read-a-schematic</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="platine-dexpérimentation-breadboard"><a class="header" href="#platine-dexpérimentation-breadboard">Platine d'expérimentation (<em>breadboard</em>)</a></h1>
<p>Une platine d’expérimentation (<em>breadboard</em> en anglais) permet de réaliser des prototypes de circuits électroniques sans soudure et donc de pouvoir réutiliser les composants.</p>
<p><img src="platine_experimentation/./allumer_del_arduino_sans_platine.svg" alt="L'utilisation de la platine d'expérimentation pour tester des circuits" /></p>
<p>À gauche, dans l'image ci-haut, nous trouvons le circuit électrique pour allumer une lumière DEL à partir de la carte Arduino. Par contre, il est impossible de relier les composants sans faire de soudure. C’est pour cela que nous utilisons la platine d’expérimentation. </p>
<h2 id="connexions"><a class="header" href="#connexions">Connexions</a></h2>
<p>Certains des trous de la platine d'expérimentation sont connectés entre eux. Ces connexions sont indiquées par des lignes dans l'illustration suivante.</p>
<p><img src="platine_experimentation/./platine_experimentation_connexions_internes.svg" alt="Connexions internes de la paltine d'expérimentation" /></p>
<ul>
<li>Tous les trous dans une rangée intérieure de 5 sont reliés entre eux. </li>
<li>Les trous des colonnes extérieures sont reliés entre eux. Ils sont réservés à l'alimentation :
<ul>
<li>Colonne rouge pour le pôle positif (+).</li>
<li>Colonne bleue pour le pôle négatif (-).</li>
</ul>
</li>
</ul>
<h2 id="bien-placer-les-composants-sur-la-platine-dexpérimentation"><a class="header" href="#bien-placer-les-composants-sur-la-platine-dexpérimentation">Bien placer les composants sur la platine d'expérimentation</a></h2>
<p>Les broches (pattes) des composants doivent être insérées dans des trous qui sont <strong>non reliés électriquement</strong>, c'est à dire <strong>isolés</strong> électriquement. </p>
<p>Dans la figure suivante :</p>
<ul>
<li>Le <strong>X</strong> indique une erreur où un composant dont les broches sont insérées dans des trous reliés électriquement.</li>
<li>Les <strong>✓</strong> indiquent des bonnes connexions où chaque broche du composant est isolée électriquement. </li>
</ul>
<p><img src="platine_experimentation/./platine_experimentation_connexions_valides_del.svg" alt="Exemples de connexions valides d'une DEL" /></p>
<p>Dans la figure suivante :</p>
<ul>
<li>Le <strong>X</strong> indique une erreur où un composant dont les broches sont insérées dans des trous reliés électriquement.</li>
<li>Les <strong>✓</strong> indiquent des bonnes connexions où chaque broche du composant est isolée électriquement. </li>
</ul>
<p><img src="platine_experimentation/./platine_experimentation_connexions_valides_exemples.svg" alt="Exemples de connexions valides" /></p>
<h2 id="se-servir-dune-carte-arduino-pour-alimenter-une-platine-dexpérimentation"><a class="header" href="#se-servir-dune-carte-arduino-pour-alimenter-une-platine-dexpérimentation">Se servir d'une carte Arduino pour alimenter une platine d'expérimentation</a></h2>
<h3 id="pôles-de-la-carte-arduino-nano"><a class="header" href="#pôles-de-la-carte-arduino-nano">Pôles de la carte Arduino Nano</a></h3>
<p>Sur certains modèles de carte Arduino Nano, le pôle positif (+) n’est malheureusement pas imprimé sur la carte. Cependant, la documentation indique que la broche du pôle positif (+) est adjacente à la broche étiquettée «RST». </p>
<p>Le pôle négatif (-) est indiqué avec l'étiquette «GND» imprimée sur la carte. </p>
<p><img src="platine_experimentation/./arduino_nano_poles_alimentation.svg" alt="Pôles d'alimentation de la carte Arduino Nano" /></p>
<h3 id="Étape-1"><a class="header" href="#Étape-1">Étape 1</a></h3>
<p>Brancher un câble (orange ou rouge) dans la rangée de la broche du positif (+) de la carte Arduino. Ce câble transporte maintenant le positif (+).</p>
<p>Brancher un câble (brun ou noir) dans la rangée de la broche du négatif (-) de la carte Arduino. Ce câble transporte maintenant le négatif (-).</p>
<p><img src="platine_experimentation/./alimentation_platine_experimentation_1.svg" alt="Étape 1 de l'alimentation de la platine d'expérimentation" /></p>
<h3 id="Étape-2"><a class="header" href="#Étape-2">Étape 2</a></h3>
<p>Brancher le câble qui transporte le positif (+) dans la colonne <strong>+</strong> rouge de la platine d’expérimentation.</p>
<p>Brancher le câble qui transporte le négatif (-) dans la colonne <strong>–</strong> bleue de la platine d’expérimentation.</p>
<p><img src="platine_experimentation/./alimentation_platine_experimentation_2.svg" alt="Étape 2 de l'alimentation de la platine d'expérimentation" /></p>
<h3 id="Étape-3"><a class="header" href="#Étape-3">Étape 3</a></h3>
<p>Relier les deux autres colonnes de la patine d'expériementation.</p>
<p><img src="platine_experimentation/./alimentation_platine_experimentation_3.svg" alt="Étape 3 de l'alimentation de la platine d'expérimentation" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erreur-fatale--court-circuit"><a class="header" href="#erreur-fatale--court-circuit">Erreur fatale : court circuit</a></h1>
<p>Ici, le pôle positif (+) et le pôle négatif (-) sont connectés dans la même colonne d'alimentation; cette erreur fatale risque d'endommager l'alimentation USB de l'ordinateur! </p>
<p><img src="erreurs_fatales/./erreur_fatale_1.SVG" alt="Erreur fatale : court circuit" /></p>
<h1 id="erreur-fatale--inverser-les-pôles--et--"><a class="header" href="#erreur-fatale--inverser-les-pôles--et--">Erreur fatale : inverser les pôles + et -</a></h1>
<p>Ici, le pôle positif (+) et le pôle négatif (-) sont inversés! Cette erreur fatale risque de détruire tous les composants! </p>
<p><img src="erreurs_fatales/./erreur_fatale_2.SVG" alt="Erreur fatale : inverser les pôles + et -" /></p>
<h1 id="quoi-faire-en-cas-derreur-fatale"><a class="header" href="#quoi-faire-en-cas-derreur-fatale">Quoi faire en cas d'erreur fatale?</a></h1>
<p><img src="erreurs_fatales/./erreur_fatale_quoi_faire.SVG" alt="Débrancher l'USB en cas d'erreur fatale" /> </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diode-électroluminescente-del"><a class="header" href="#diode-électroluminescente-del">Diode électroluminescente (DEL)</a></h1>
<p>La diode électroluminescente (DEL) est un <em>actionneur</em> qui transforme un signal électrique en lumière. Elle est appelée «LED» en anglais. </p>
<p>En utilisant divers matériaux semi-conducteurs, on fait varier la couleur de la lumière émise par la DEL. Il existe enfin une grande variété de formes de DEL.</p>
<p>Le courant électrique ne peut traverser la diode que dans le sens de l’anode vers la cathode.</p>
<p><img src="del/./del.svg" alt="Une DEL" /></p>
<p>La DEL a deux pôles :</p>
<ul>
<li>Anode : pôle positif.</li>
<li>Cathode : pôle négatif.</li>
</ul>
<p><img src="del/./del_anode_cathode.svg" alt="Anode et cathode d'une DEL " /></p>
<h2 id="limiter-lintensité-du-courant"><a class="header" href="#limiter-lintensité-du-courant">Limiter l'intensité du courant</a></h2>
<p><strong>Attention</strong> : il faut limiter l'intensité du courant qui traverse la DEL. </p>
<p>Pour une DEL rouge standard :</p>
<ul>
<li>La DEL crée une chute de tension (<em>voltage drop</em>) d’environ 2.1 Volts.</li>
<li>L'intensité qui traverse la DEL doit être d'environ 0.02 Ampères (20 mA). </li>
<li>L’utilisation d’une résistance est obligatoire pour réduire l'intensité et ne pas griller la DEL.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="résistance"><a class="header" href="#résistance">Résistance</a></h1>
<p><img src="resistance/./resistance_photo.svg" alt="Une résistance" /></p>
<p>Une résistance est un composant électrique dont la principale caractéristique est d'opposer une plus ou moins grande résistance mesurée en ohms (Ω) à la circulation du courant électrique.</p>
<p>Une résistance est un milieu peu conducteur; les électrons peinent à s’y déplacer. Leur énergie se dissipe alors en général sous forme de chaleur. C’est ce principe utilisé pour les bouilloires électriques ou les ampoules à filaments.
La valeur de la résistance se mesure en ohms (Ω) et elle est déterminée par ses bandes de couleurs.</p>
<p><img src="resistance/./resistance_schema.svg" alt="Schéma européen à gauche et américan à droite d'une résistance" /></p>
<h1 id="calculer-la-valeur-dune-résistance"><a class="header" href="#calculer-la-valeur-dune-résistance">Calculer la valeur d’une résistance</a></h1>
<p>Pour connaître la valeur en ohms (Ω) d'une résistance,  il faut convertir le code couleur des 2 ou 3 premiers anneaux pour ensuite  multiplier par le code de l'anneau suivant. La tolérance, représentée par le dernier anneau, correspond à l’imprécision de la valeur en ohms. Plus elle est petite, plus la résistance est de meilleure qualité.</p>
<p><img src="resistance/./resistance_calcul_code_couleur.svg" alt="Tableau pour la conversion des bandes de couleurs d'une résistance" /></p>
<p>Exemple : 
<code>rouge (2), rouge(2), brun (x10) = 22 * 10 = 220 Ω = 0.22 kΩ.</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alimenter-une-del"><a class="header" href="#alimenter-une-del">Alimenter une DEL</a></h1>
<h2 id="alimenter-une-del-avec-une-batterie"><a class="header" href="#alimenter-une-del-avec-une-batterie">Alimenter une DEL avec une batterie</a></h2>
<p>Un schéma de circuit représente sous une forme plus précise les connexions des composants d’un circuit.</p>
<p>Le schéma et l’image ci-bas montrent tous les deux comment allumer une DEL avec une résistance et une batterie 9V. </p>
<p><img src="alimenter_del/./alimenter_del_avec_une_batterie.svg" alt="Schéma et image d'une DEL alimentée par une batterie" /></p>
<p><img src="alimenter_del/./alimenter_del_batterie_9v.gif" alt="Animation de l'alimentation d'une DEL par une batterie (CTAYLOR, s. d.)" /></p>
<h3 id="identification-de-lalimentation"><a class="header" href="#identification-de-lalimentation">Identification de l'alimentation</a></h3>
<p><img src="alimenter_del/./alimenter_del_avec_une_batterie_alimentation.svg" alt="L'alimentation dans le schéma et l'image" /></p>
<h3 id="identification-de-la-résistance"><a class="header" href="#identification-de-la-résistance">Identification de la résistance</a></h3>
<p><img src="alimenter_del/./alimenter_del_avec_une_batterie_resistance.svg" alt="La résistance dans le schéma et l'image" /></p>
<h3 id="identitfication-de-la-del"><a class="header" href="#identitfication-de-la-del">Identitfication de la DEL</a></h3>
<p><img src="alimenter_del/./alimenter_del_avec_une_batterie_del.svg" alt="La DEL dans le schéma et l'image" /></p>
<h2 id="alimenter-une-del-avec-la-platine-dexpérimentation"><a class="header" href="#alimenter-une-del-avec-la-platine-dexpérimentation">Alimenter une DEL avec la platine d'expérimentation</a></h2>
<p>Portez attention à la longueur des pattes de la DEL. Une patte est plus longue que l’autre. Une DEL ne s’allume que si elle est branchée dans le bon sens. </p>
<p><img src="alimenter_del/./del_longueur_pattes.svg" alt="Anode, cathode et longueur des pattes" /></p>
<p><img src="alimenter_del/./alimenter_del_schema.svg" alt="Circuit pour alimenter une DEL" /></p>
<p><img src="alimenter_del/./alimenter_del_schema_avec_images.svg" alt="Identification des composantes" /></p>
<p><img src="alimenter_del/./alimenter_del_circuit_bb.svg" alt="Une disposition possible sur la platine d'expérimentation" /></p>
<h2 id="sources-des-images"><a class="header" href="#sources-des-images">Sources des images</a></h2>
<ul>
<li>CTAYLOR. (s. d.). Voltage, Current, Resistance, and Ohm’s Law. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/voltage-current-resistance-and-ohms-law/all">https://learn.sparkfun.com/tutorials/voltage-current-resistance-and-ohms-law/all</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="micro-soudure"><a class="header" href="#micro-soudure">Micro-soudure</a></h1>
<h2 id="Équipement-essentiel"><a class="header" href="#Équipement-essentiel">Équipement essentiel</a></h2>
<p><img src="micro-soudure/./soldering-iron.jpg" alt="Plusieurs modèles de fer à souder (JOEL_E_B, s. d.)" /></p>
<p><img src="micro-soudure/./micro-soudure_bobine.png" alt="Bobine de soudure 60/40 0.031&quot; (ADAFRUIT)" /></p>
<p><img src="micro-soudure/./brass_sponge.jpg" alt="Nettoyeur de pointe (JOEL_E_B, s. d.)" /></p>
<p><img src="micro-soudure/./solder_vacuum.jpg" alt="Pompe à dessouder (JOEL_E_B, s. d.)" /></p>
<p><img src="micro-soudure/./micro-soudure_pince_denuder.svg" alt="Pince à dénuder" /></p>
<p><img src="micro-soudure/./flush_cutters.jpg" alt="Pince à couper latérale de précision (flush cutters) (JOEL_E_B, s. d.)" /></p>
<p><img src="micro-soudure/./needle_nose.jpg" alt="Pince à long bec (JOEL_E_B, s. d.)" /></p>
<h2 id="technique"><a class="header" href="#technique">Technique</a></h2>
<p><img src="micro-soudure/./micro-soudure_technique.svg" alt="Résumé de la technique pour la micro-soudure (JOEL_E_B, s. d.)" /></p>
<h2 id="informations-complémentaires"><a class="header" href="#informations-complémentaires">Informations complémentaires</a></h2>
<ul>
<li>Altman, M. (s. d.). Souder c’est facile : voici comment faire (A. Nordgren, ill.; J. Keyzerm éd.; Snootlab, trad.). <a href="micro-soudure/../pdf/bd_soudure.pdf">bd_soudure.pdf</a></li>
<li>Earl. B. (2012, 6 septembre). Common Soldering Problems. Adafruit. <a href="https://learn.adafruit.com/adafruit-guide-excellent-soldering/preparation">https://learn.adafruit.com/adafruit-guide-excellent-soldering/preparation</a></li>
<li>Earl. B. (2012, 6 septembre). Making good solder joint. Adafruit. <a href="https://learn.adafruit.com/adafruit-guide-excellent-soldering/making-a-good-solder-joint">https://learn.adafruit.com/adafruit-guide-excellent-soldering/making-a-good-solder-joint</a></li>
<li>Earl. B. (2012, 6 septembre). Preparation. Adafruit. <a href="https://learn.adafruit.com/adafruit-guide-excellent-soldering/preparation">https://learn.adafruit.com/adafruit-guide-excellent-soldering/preparation</a></li>
<li>Earl. B. (2012, 6 septembre). Tools. Adafruit. <a href="https://learn.adafruit.com/adafruit-guide-excellent-soldering/preparation">https://learn.adafruit.com/adafruit-guide-excellent-soldering/tools</a></li>
<li>Montuelle, C. (s. d.). Introduction à la soudure électrique [vidéo]. Vimeo. <a href="https://vimeo.com/481700117/fe056befd2">https://vimeo.com/481700117/fe056befd2</a> </li>
</ul>
<h2 id="sources-des-images-1"><a class="header" href="#sources-des-images-1">Sources des images</a></h2>
<ul>
<li>ADAFRUIT. (s. d.). Mini Solder spool - 60/40 lead rosin-core solder 0.031&quot; diameter - 100g. <a href="https://www.flickr.com/photos/adafruit/39675740312">https://www.flickr.com/photos/adafruit/39675740312</a> </li>
<li>JOEL_E_B. (s. d.). How to Solder : Through-Hole Soldering. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/how-to-solder-through-hole-soldering/all">https://learn.sparkfun.com/tutorials/how-to-solder-through-hole-soldering/all</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multimètre"><a class="header" href="#multimètre">Multimètre</a></h1>
<p>Voici deux tutoriels sur comment utiliser le multimètre pour :</p>
<ul>
<li>Mesurer la continuité.</li>
<li>Mesurer la résistance.</li>
</ul>
<h2 id="mesurer-la-continuité"><a class="header" href="#mesurer-la-continuité">Mesurer la continuité</a></h2>
<ul>
<li>Nate. (s. d.). Continuity. Sparkfun.<a href="https://learn.sparkfun.com/tutorials/how-to-use-a-multimeter/all#continuity"> https://learn.sparkfun.com/tutorials/how-to-use-a-multimeter/all#continuity</a></li>
</ul>
<h2 id="mesurer-la-résistance"><a class="header" href="#mesurer-la-résistance">Mesurer la résistance</a></h2>
<ul>
<li>Nate. (s. d.). Measuring Resistance. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/how-to-use-a-multimeter/all#measuring-resistance">https://learn.sparkfun.com/tutorials/how-to-use-a-multimeter/all#measuring-resistance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modèles-de-cartes"><a class="header" href="#modèles-de-cartes">Modèles de cartes</a></h1>
<p>Il existe plusieurs modèles de cartes Arduino. Certains sont produits par la compagnie Arduino et d'autres sont des clones légaux (Arduino est en fait un clone d'une autre plateforme : <a href="http://www.wiring.org.co/">Wiring</a>). </p>
<p>Le modèle principalement utilisé dans cette documentation est l’Arduino Nano (microprocesseur ATMEGA328). On recommande aussi les modèles suivants qui sont plus onéreux, mais aussi plus puissants :</p>
<ul>
<li><a href="https://shop.m5stack.com/products/atom-poe-kit-with-w5500-hy601742e">ATOM PoE Kit with W5500 (HY601742E) | m5stack-store</a>  (microprocesseur ESP32).</li>
<li><a href="https://learn.adafruit.com/adafruit-huzzah32-esp32-feather">Overview | Adafruit HUZZAH32 - ESP32 Feather | Adafruit Learning System</a> (microprocesseur ESP32).</li>
</ul>
<p>Pour plus d'informations sur l'ensemble des cartes disponibles, consultez le <a href="https://makezine.com/comparison/boards">Make: Boards Guide</a>.</p>
<p><a href="https://makezine.com/comparison/boards"><img src="arduino_cartes/./cartes_modeles.svg" alt="Make: Boards Guide" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="les-cartes-arduino-nano"><a class="header" href="#les-cartes-arduino-nano">Les cartes Arduino Nano</a></h1>
<h2 id="sous-modèles-de-cartes-arduino-nano"><a class="header" href="#sous-modèles-de-cartes-arduino-nano">Sous-modèles de cartes Arduino Nano</a></h2>
<p>Il existe plusieurs sous-modèles de la carte Arduino Nano qui se différencient selon les options suivantes:</p>
<ul>
<li><strong>ATMEGA168</strong> ou <strong>ATMEGA328</strong> : les termes ATMEGA168 et ATMEGA328 indiquent la taille de la mémoire de l'Arduino Nano. Toujours choisir le modèle avec l'identifiant <strong>ATMEGA328</strong>.</li>
<li><strong>FTDI</strong> ou <strong>CH340</strong> : les termes FTDI et CH340 indiquent le modèle de la puce qui assure la communication entre l'Arduino et l'ordinateur. Bien que les puces FTDI soient de meilleure qualité, les puces CH340 sont moins dispendieuses et performent adéquatement. Le choix entre ces deux options va surtout déterminer le pilote à installer (voir plus bas). </li>
<li><strong>Connecteur USB</strong> : ici c'est un choix plus personnel, mais si possible, préférer le connecteur de type USB-C qui est plus solide.</li>
</ul>
<h2 id="broches-des-cartes-arduino-nano"><a class="header" href="#broches-des-cartes-arduino-nano">Broches des cartes Arduino Nano</a></h2>
<p><img src="arduino_nano/./arduino_nano_broches.png" alt="Les différents types de broches" /> </p>
<h2 id="installer-le-pilote-de-la-carte-arduino-nano"><a class="header" href="#installer-le-pilote-de-la-carte-arduino-nano">Installer le pilote de la carte Arduino Nano</a></h2>
<p>Si l'Arduino Nano utilise une puce CH340, les instructions suivantes pour installer le pilote doivent être suivies :</p>
<ul>
<li>BBOYHO et SANTAIMPERSONATOR. (s. d.). How to Install CH340 Drivers. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all">https://learn.sparkfun.com/tutorials/how-to-install-ch340-drivers/all</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fenêtre-principale-du-logiciel-arduino-ide"><a class="header" href="#fenêtre-principale-du-logiciel-arduino-ide">Fenêtre principale du logiciel Arduino IDE</a></h1>
<p>L'environnement de développement intégré Arduino, <em>Arduino Integrated development environment</em> en anglais, ou <strong>Arduino IDE</strong> est outil pour programmer les microcontrôleurs dédié à l'apprentissage.</p>
<p><img src="arduino-ide/./Slide1.SVG" alt="Fenêtre principale" /></p>
<p><img src="arduino-ide/./barre_haut_ide_arduino.svg" alt="Côté gauche du menu" /></p>
<p>Voici les fonctions des îcones du côté gauche du menu :</p>
<ol>
<li>Vérifier le programme et en identifier les erreurs.</li>
<li>Envoyer du programme à la carte Arduino.</li>
<li>Créer un nouveau document Arduino.</li>
<li>Ouvrir un document Arduino existant.</li>
<li>Enregistrer le document Arduino ouvert.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-du-port"><a class="header" href="#configuration-du-port">Configuration du port</a></h1>
<h2 id="identifier-le-port-de-la-carte-arduino-nano"><a class="header" href="#identifier-le-port-de-la-carte-arduino-nano">Identifier le port de la carte Arduino Nano</a></h2>
<p><img src="arduino-ide_configuration_nano/./Slide1.SVG" alt="Procédure pour identifier le port de la carte Arduino" /></p>
<h2 id="configurer-le-logiciel-arduino-pour-la-carte-arduino-nano"><a class="header" href="#configurer-le-logiciel-arduino-pour-la-carte-arduino-nano">Configurer le logiciel Arduino pour la carte Arduino Nano</a></h2>
<p><img src="arduino-ide_configuration_nano/./configuration1.svg" alt="Brancher la carte à l’ordinateur et choisir le port trouvé à l’étape précédente" /></p>
<p><img src="arduino-ide_configuration_nano/./configuration2.svg" alt="Choisir le modèle de carte «Arduino Nano»" /></p>
<p><img src="arduino-ide_configuration_nano/./configuration3.svg" alt="Choisir le vieux Bootloader" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blink-le-code-test-universel"><a class="header" href="#blink-le-code-test-universel">Blink: le code test universel</a></h1>
<h2 id="ouvrir-et-téléverser-lexemple-01-basics--blink"><a class="header" href="#ouvrir-et-téléverser-lexemple-01-basics--blink">Ouvrir et téléverser l'exemple «0.1 Basics &gt; Blink»</a></h2>
<p><img src="arduino-ide_test_blink/./Slide2.SVG" alt="Séquence pour téléverser «Blink»" /></p>
<h2 id="observer-la-del-qui-clignote"><a class="header" href="#observer-la-del-qui-clignote">Observer la DEL qui clignote</a></h2>
<p><img src="arduino-ide_test_blink/./Slide3.SVG" alt="La DEL «L» clignote" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="le-code-arduino"><a class="header" href="#le-code-arduino">Le code Arduino</a></h1>
<h2 id="documents-de-référence"><a class="header" href="#documents-de-référence">Documents de référence</a></h2>
<ul>
<li><a href="https://www.arduino.cc/reference/en/">Référence Arduino sur Arduino.cc</a></li>
<li><a href="arduino_code/../pdf/arduino_programming_notebook-bryan_w_evans.pdf">Arduino Programming Notebook de Bryan W Evans (2017) en version PDF</a></li>
</ul>
<h2 id="code-minimal"><a class="header" href="#code-minimal">Code minimal</a></h2>
<pre><code class="language-arduino">
// VARIABLE GLOBALES

void setup() {
  // CODE À ROULER AU DÉMARRAGE

}

void loop() {
  // CODE À RÉPÉTER (LE PLUS RAPIDEMENT POSSIBLE)

}
</code></pre>
<p>On retrouve deux fonctions dans le code minimal : </p>
<ul>
<li><code>setup()</code></li>
<li><code>loop()</code></li>
</ul>
<h3 id="setup"><a class="header" href="#setup">setup()</a></h3>
<p>La fonction setup() est appelée une seule fois lorsque le programme commence. C'est pourquoi c'est dans cette fonction que l'on va écrire le code qui n'a besoin d'être exécuté qu’une seule fois. C'est une  fonction d'initialisation. On y retrouvera la mise en place des différentes sorties et quelques autres réglages.</p>
<h3 id="loop"><a class="header" href="#loop">loop()</a></h3>
<p>Une fois que l'on a initialisé le programme, il faut ensuite créer le «cœur» du programme, autrement dit le programme en lui-même. C'est dans la fonction loop() que l’on va écrire le contenu du programme. Il faut savoir que cette fonction est appelée en permanence, c'est-à-dire qu'elle est exécutée une fois, puis lorsque son exécution est terminée, on l'exécute, encore et encore. On parle de boucle infinie!</p>
<h2 id="déroulement-du-programme"><a class="header" href="#déroulement-du-programme">Déroulement du programme</a></h2>
<p><img src="arduino_code/./Slide1.SVG" alt="Déroulement du programme" /></p>
<p>Le programme se déroule de la façon suivante :</p>
<ol>
<li>Prise en compte des instructions de l'en-tête déclarative.</li>
<li>Exécution au démarrage de la partie configuration définie par la fonction setup().</li>
<li>Exécution de la boucle qui s’exécute indéfiniment et le plus rapidement possible.</li>
</ol>
<h2 id="les-instructions"><a class="header" href="#les-instructions">Les instructions</a></h2>
<p>Les instructions sont des lignes de code qui disent au programme : « fais ceci, fais cela… » Ce sont donc les ordres qui seront exécutés par l'Arduino. Il est très important de respecter exactement la syntaxe ; faute de quoi, le code ne pourra pas être exécuté.</p>
<h3 id="les-points-virgules"><a class="header" href="#les-points-virgules">Les points-virgules</a></h3>
<p>Les points-virgules terminent les instructions. Si par exemple on dit dans notre programme : « appelle la fonction mangerLeChat », on doit mettre un point-virgule après l'appel de cette fonction.</p>
<p>Lorsque le code ne fonctionne pas, c'est souvent parce qu'il manque un point-virgule. Il faut donc être très attentif à ne pas les oublier !</p>
<h3 id="les-accolades--"><a class="header" href="#les-accolades--">Les accolades { }</a></h3>
<p>Les accolades sont les « conteneurs » du code du programme. Elles sont propres aux fonctions, aux conditions et aux boucles. Les instructions du programme sont écrites à l'intérieur de ces accolades.</p>
<h3 id="les-commentaires"><a class="header" href="#les-commentaires">Les commentaires</a></h3>
<p>Les commentaires sont des lignes de code qui seront ignorées par le programme. Elles ne servent à rien lors de l'exécution du programme. Ils permettent d'annoter et de commenter le programme.</p>
<p>Ligne unique de commentaire :</p>
<pre><code class="language-arduino">
// cette ligne est un commentaire sur UNE SEULE ligne
</code></pre>
<p>Ligne ou paragraphe sur plusieurs lignes :</p>
<pre><code class="language-arduino">/* cette ligne est un commentaire, sur PLUSIEURS lignes
qui sera ignoré par le programme, mais pas par celui qui lit le code ;) */
</code></pre>
<h3 id="les-fonctions"><a class="header" href="#les-fonctions">Les fonctions</a></h3>
<p>Une fonction (également désignée sous le nom de procédure ou de sous-routine) est un bloc d'instructions que l'on peut appeler à tout endroit du programme.</p>
<p>Le langage Arduino est constitué d'un certain nombre de fonctions, par exemple analogRead(), digitalWrite() ou delay().</p>
<p>Il est possible de déclarer ses propres fonctions par exemple :</p>
<pre><code class="language-arduino">void clignote(){
    digitalWrite (brocheLED,  HIGH) ;
    delay (1000) ;
    digitalWrite (brocheLED,  LOW) ;
    delay (1000) ;
}
</code></pre>
<p>Pour exécuter cette fonction, il suffit de taper la commande :</p>
<pre><code class="language-arduino">clignote();
</code></pre>
<p>On peut faire intervenir un ou des paramètres dans une fonction :</p>
<pre><code class="language-arduino">void clignote(int broche,int vitesse){
    digitalWrite (broche, HIGH) ;
    delay (1000/vitesse) ;
    digitalWrite (broche, LOW) ;
    delay (1000/vitesse) ;
}
</code></pre>
<p>Dans ce cas, l'on peut moduler leurs valeurs depuis la commande qui l'appelle :</p>
<pre><code class="language-arduino">clignote(5,1000); //la sortie 5 clignotera vite
clignote(3,250); //la sortie 3 clignotera lentement
</code></pre>
<h3 id="les-structures-de-contrôle"><a class="header" href="#les-structures-de-contrôle">Les structures de contrôle</a></h3>
<p>Les structures de contrôle sont des blocs d'instructions qui s'exécutent en fonction du respect d'un certain nombre de conditions.</p>
<p>Il existe quatre types de structure :</p>
<p><code>if...else</code> : exécute un code si certaines conditions sont remplies et éventuellement exécutera un autre code avec sinon.</p>
<p>Exemple :</p>
<pre><code class="language-arduino">//si la valeur du capteur depasse le seuil
if(valeurCapteur&gt;seuil){
    //appel de la fonction clignote
    clignote();
}
</code></pre>
<p><code>while</code> : exécute un code tant que certaines conditions sont remplies.</p>
<p>Exemple :</p>
<pre><code class="language-arduino">//tant que la valeur du capteur est supérieure à 250
while(valeurCapteur&gt;250){
    //allume la sortie 5
    digitalWrite(5,HIGH);
    //envoi le message &quot;0&quot; au port serie
    Serial.println(1);
    //en boucle tant que valeurCapteur est supérieue à 250
}

Serial.println(0);

digitalWrite(5,LOW);
</code></pre>
<p><code>for</code> : exécute un code pour un certain nombre de fois.</p>
<p>Exemple :</p>
<pre><code class="language-arduino">//pour i de 0 à 255, par pas de 1
for (int i=0; i &lt;= 255; i++){
    analogWrite(PWMpin, i);
    delay(10);
}
</code></pre>
<p><code>switch...case</code> : fait un choix entre plusieurs codes parmi une liste de possibilités</p>
<p>Exemple :</p>
<pre><code class="language-arduino">// fait un choix parmi plusieurs messages reçus
switch (message) {
    case 0: //si le message est &quot;0&quot;
        //allume que la sortie 3
        digitalWrite(3,HIGH);
        digitalWrite(4,LOW);
        digitalWrite(5,LOW);
        break;
    case 1: //si le message est &quot;1&quot;
        //allume que la sortie 4
        digitalWrite(3,HIGH);
        digitalWrite(4,LOW);
        digitalWrite(5,LOW);
        break;
    case 2: //si le message est &quot;2&quot;
        //allume que la sortie 5
        digitalWrite(3,LOW);
        digitalWrite(4,LOW);
        digitalWrite(5,HIGH);
        break;
    }
</code></pre>
<h2 id="variables-de-base"><a class="header" href="#variables-de-base">Variables de base</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Taille</th><th>Description</th></tr></thead><tbody>
<tr><td><code>char</code></td><td>8 bits</td><td>pour stocker des caractères</td></tr>
<tr><td><code>byte </code></td><td>8 bits</td><td>pour stocker un chiffre compris entre 0 et 255</td></tr>
<tr><td><code>int</code></td><td>16 bits</td><td>pour stocker un chiffre compris entre -32 768 et 32 767</td></tr>
<tr><td><code>unsigned int</code></td><td>16 bits</td><td>pour stocker un chiffre compris entre 0 et 65 535</td></tr>
<tr><td><code>long</code></td><td>32 bits</td><td>pour stocker un chiffre compris entre  -2 147 483 648 et 2 147 483 647</td></tr>
<tr><td><code>unsigned long</code></td><td>32 bits</td><td>pour stocker un chiffre compris entre 0 et 4 294 967 295</td></tr>
<tr><td><code>float</code></td><td>32 bits</td><td>pour stocker des nombres décimaux</td></tr>
<tr><td><code>double</code></td><td>64 bits</td><td>pour stocker des nombres décimaux avec plus de précision</td></tr>
</tbody></table>
</div>
<h2 id="arduino-cheat-sheet-de-sparkfun"><a class="header" href="#arduino-cheat-sheet-de-sparkfun">«Arduino Cheat Sheet» de SparkFun</a></h2>
<p><img src="arduino_code/./sparkfun_arduino_cheat_sheat.png" alt="Capture d'écran du «Arduino Cheat Sheet» de SparkFun" /></p>
<p>La version PDF du «Arduino Cheat Sheet» de SparkFun peut être téléchargée ici : <a href="https://sparkfuneducation.com/classroom-downloads/arduino-cheatsheet.html">SparkFun Education - Classroom Downloads - Arduino Cheatsheet</a>.</p>
<h2 id="références"><a class="header" href="#références">Références</a></h2>
<ul>
<li>FlossManuals. (s. d.). Programmer-Arduino. <a href="https://fr.flossmanuals.net/arduino/programmer-arduino/">https://fr.flossmanuals.net/arduino/programmer-arduino/</a></li>
</ul>
<h2 id="ressources-additionnelles"><a class="header" href="#ressources-additionnelles">Ressources additionnelles</a></h2>
<ul>
<li>FlossManuals. (s. d.). Bien coder. <a href="https://fr.flossmanuals.net/arduino/comment-bien-structurer-son-code/">https://fr.flossmanuals.net/arduino/comment-bien-structurer-son-code/</a></li>
</ul>
<h2 id="sources-des-images-2"><a class="header" href="#sources-des-images-2">Sources des images</a></h2>
<ul>
<li>Sparkfun. (s. d.). Arduino Cheatsheet. <a href="https://sparkfuneducation.com/classroom-downloads/arduino-cheatsheet.html">https://sparkfuneducation.com/classroom-downloads/arduino-cheatsheet.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mesurer-le-temps-avec-millis"><a class="header" href="#mesurer-le-temps-avec-millis">Mesurer le temps avec millis()</a></h1>
<p>La fonction <code>millis()</code> permet de résoudre ce problème. Elle retourne le temps en millisecondes depuis le début de démarrage de votre Arduino. </p>
<p>Jusqu'à présent, on a déclaré des variables comme étant des <code>int</code>. Un <code>int</code> est un nombre de 16 bits, il contient des valeurs comprises entre <code>-32 768</code> et <code>32 767</code>. Si l'Arduino compte en millisecondes, on risque de manquerez de valeurs pour représenter le temps en moins d'une minute. </p>
<p>Le type de données long peut contenir un nombre de 32 bits (entre <code>-2 147 483 648</code> et <code>2 147 483 647</code>). Comme vous ne pouvez pas exécuter le temps à rebours pour obtenir des nombres négatifs, nous utiliser le type <code>unsigned long</code> pour stocker le temps. Lorsqu'un type de données est indiqué «non signé», il ne peut être que positif. Cela permet de compter avec deux fois plus de valeurs positivres. Un <code>unsigned long</code> peut compter jusqu'à <code>4 294 967 295</code>. C’est assez d’espace pour stocker le temps pendant près de 50 jours. En comparant le <code>millis()</code> actuel à une valeur spécifique, vous pouvez voir si un certain temps s'est écoulé.</p>
<p>Déclarer une variable pour récupérer le temps:</p>
<pre><code class="language-arduino">unsigned long monTempsEcoule;
</code></pre>
<p>Mettre le temps dans la variable <code>monTempsEcoule</code>:</p>
<pre><code class="language-arduino">monTempsEcoule = millis();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intervalle-de-temps"><a class="header" href="#intervalle-de-temps">Intervalle de temps</a></h1>
<h2 id="comment-chronométer-un-intervalle-de-temps-avec-millis"><a class="header" href="#comment-chronométer-un-intervalle-de-temps-avec-millis">Comment chronométer un intervalle de temps avec millis()</a></h2>
<p>Créer une variable <strong>globale</strong> pour mettre en mémoire le temps de départ du chronomètre :</p>
<pre><code class="language-arduino">unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE
</code></pre>
<p>Pour calculer le temps écoulé on utilison le code suivant: </p>
<pre><code class="language-arduino">unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
</code></pre>
<p>On execute un bloc de code seulement si le temps écoulé dépasse un intervalle de temps (20 millisecondes dans cet exemple): </p>
<pre><code class="language-arduino">unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES
if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI LE TEMPS ÉCOULÉ DÉPASSE L'INTERVALLE...
	// ...FAIRE QQCH 
}
</code></pre>
<p>On peut redémarrer l'intervalle du  chronomètre avec le code suivant:</p>
<pre><code class="language-arduino">monChronoDepart = millis(); // REDÉMARRER LE CHRONOMÈTRE
</code></pre>
<h2 id="comment-exécuter-de-façon-cyclique"><a class="header" href="#comment-exécuter-de-façon-cyclique">Comment exécuter de façon cyclique</a></h2>
<p>Nous pouvons combiner les deux extraits de code précédents pour exécuter du code ET redémarrer le chronomètre de façon cyclique. Dans l'extrait suivant, le code entre les <code>{ }</code> est exécuté à chaque 20 millisecondes:</p>
<pre><code class="language-arduino">unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { 
};

void loop() {

    unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE

    unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

    if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI LE TEMPS ÉCOULÉ DÉPASSE L'INTERVALLE...
    	monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
    	// CETTE SECTION SERA EXÉCUTÉE À CHAQUE 20 MS
    }
}
</code></pre>
<h2 id="comment-exécuter-de-façon-cyclique-code-abrégé"><a class="header" href="#comment-exécuter-de-façon-cyclique-code-abrégé">Comment exécuter de façon cyclique (code abrégé)</a></h2>
<pre><code class="language-arduino">unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { 
};

void loop() {

    if ( millis() - monChronoDepart &gt;= 20 ) { // SI LE TEMPS ÉCOULÉ DÉPASSE L'INTERVALLE...
      monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
      // CETTE SECTION SERA EXÉCUTÉE À CHAQUE 20 MS
    }
}
</code></pre>
<h2 id="exemple--envoyer-la-valeur-dune-entrée-numérique-à-chaque-20-millisecondes"><a class="header" href="#exemple--envoyer-la-valeur-dune-entrée-numérique-à-chaque-20-millisecondes">Exemple : envoyer la valeur d'une entrée numérique à chaque 20 millisecondes</a></h2>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 4;
unsigned long monChronoDepart = 0;

void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'INTERRUPTEUR EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE
  

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES
  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI LE TEMPS ÉCOULÉ DÉPASSE L'INTERVALLE...
    monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
    
    int maValeurInterrupteur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION

    Serial.print( maValeurInterrupteur ); // ENVOYER LA VALEUR
    Serial.println();  // TERMINER LE MESSAGE
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sortie-numérique"><a class="header" href="#sortie-numérique">Sortie numérique</a></h1>
<p>Il est possible de régler la tension présente à la plupart des broches de la carte Arduino. </p>
<p>Cette tension peut être réglée à deux niveaux :</p>
<ul>
<li><code>HIGH</code> : règle la tension de sortie à 5V (pôle positif)</li>
<li><code>LOW</code> : règle la tension de sortie à 0V (pôle négatif/GND)</li>
</ul>
<p>Pour régler la tension électrique de sortie d'une broche, on utilise ces blocs de code :</p>
<ol>
<li>Configurer la broche <code>numeroBoche</code> en mode sortie avec <code>OUTPUT</code> :</li>
</ol>
<pre><code class="language-arduino">pinMode( numeroBoche , OUTPUT );
</code></pre>
<ol start="2">
<li>Pour règler la tension de sortie à 5V (pôle positif) :</li>
</ol>
<pre><code class="language-cpp">digitalWrite( numeroBoche, HIGH );
</code></pre>
<ol start="3">
<li>Pour règler la tension de sortie à 0V (pôle négatif/GND) :</li>
</ol>
<pre><code class="language-cpp">digitalWrite( numeroBoche, LOW );
</code></pre>
<h2 id="débogage-dune-sortie-numérique"><a class="header" href="#débogage-dune-sortie-numérique">Débogage d'une sortie numérique</a></h2>
<p>Dans le code suivant, nous déboguons la sortie numérique 13 : </p>
<pre><code class="language-arduino">int maBroche = 13;
int maValeur = LOW ; // VALEUR DÉSIRÉE DE LA SORTIE NUMÉRIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(115200); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBroche , OUTPUT); // CONFIGURER LA BROCHE EN SORTIE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 250; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 250 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...

    // ALTERNER LA VALEUR DÉSIRÉE DE LA SORTIE NUMÉRIQUE 
    if ( maValeur == LOW ) maValeur = HIGH; // SI LOW, METTRE À HIGH
    else maValeur = LOW; // SINON, METTRE À LOW

    // APLLIQUER LA VALEUR DÉSIRÉE À LA SORTIE NUMÉRIQUE
    digitalWrite( maBroche , maValeur );
    
    Serial.print( &quot;Envoi sur la broche &quot; ); // ENVOYER UNE EN-TÊTE DE MESSAGE
    Serial.print( maBroche ); // ENVOYER LE NUMÉRO DE LA BROCHE
    Serial.print( &quot; de la valeur (0=LOW, 1=HIGH) : &quot; ); // ENVOYER UN SÉPARATEUR ENTRE LE NUMÉRO DE LA BROCHE ET SA VALEUR
    Serial.print( maValeur ); // ENVOYER LA VALEUR
    Serial.println();  // TERMINER LE MESSAGE


  }
}
</code></pre>
<p><img src="sortie_numerique/./debogage_sortie_numerique_moniteur_serie.png" alt="Résultat du débogage de la sortie numérique dans le moniteur série" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contrôler-une-del"><a class="header" href="#contrôler-une-del">Contrôler une DEL</a></h1>
<p><img src="arduino_exemple_del/./arduino_allumer_del_resume.svg" alt="Fiche synthèse pour allumer une DEL" /></p>
<h2 id="segment-de-circuit"><a class="header" href="#segment-de-circuit">Segment de circuit</a></h2>
<p><img src="arduino_exemple_del/./Slide1.SVG" alt="Segment de circuit pour contrôler une DEL" /></p>
<h2 id="circuit-complet"><a class="header" href="#circuit-complet">Circuit complet</a></h2>
<h3 id="schéma-du-circuit"><a class="header" href="#schéma-du-circuit">Schéma du circuit</a></h3>
<p><img src="arduino_exemple_del/./del_arduino_schema.png" alt="Schéma du circuit de l'exemple pour contrôler une DEL" /></p>
<h3 id="illustration-du-circuit"><a class="header" href="#illustration-du-circuit">Illustration du circuit</a></h3>
<p><img src="arduino_exemple_del/./del_arduino_illustration.png" alt="Illustration du circuit de l'exemple pour contrôler une DEL" />
del_arduino</p>
<h3 id="comparaison-avec-le-circuit-dalimentation-simple"><a class="header" href="#comparaison-avec-le-circuit-dalimentation-simple">Comparaison avec le circuit d'alimentation simple</a></h3>
<p><img src="arduino_exemple_del/./Slide3.SVG" alt="Comparaison du circuit d'alimentation simple à gauche avec celui de contrôle à droite" /></p>
<p><img src="arduino_exemple_del/./del_alimentation_vs_controle_illustration.svg" alt="Comparaison du circuit d'alimentation simple à gauche avec celui de contrôle à droite" /></p>
<h2 id="fonctions-pertinentes"><a class="header" href="#fonctions-pertinentes">Fonctions pertinentes</a></h2>
<p><img src="arduino_exemple_del/./pinModeOutput.svg" alt="Configuer la broche # en tant que sortie numérique" /></p>
<p><img src="arduino_exemple_del/./digitalWriteHigh.svg" alt="Activer 5V à la broche #" /></p>
<p><img src="arduino_exemple_del/./digitalWriteLow.svg" alt="Activer 0V à la broche #" /></p>
<h2 id="fonction-additionnelle"><a class="header" href="#fonction-additionnelle">Fonction additionnelle</a></h2>
<p><img src="arduino_exemple_del/./delay.svg" alt="Bloquer/Arrêter le code pour un certain nombre de millisecondes" /></p>
<h2 id="code-complet"><a class="header" href="#code-complet">Code complet</a></h2>
<pre><code class="language-arduino">
int maDelBroche = 13;  // BROCHE CONNECTÉE À LA DEL

int maDelValeur = LOW;  // VALEUR INITIALE DE LA DEL

unsigned long monChronoDepart = 0;  // VARIABLE POUR CHRONOMÈTRER LE CLIGNOTEMENT

void setup() {
  pinMode(maDelBroche, OUTPUT);  // SORTIE NUMERIQUE
  digitalWrite(maDelBroche, maDelValeur); // APPLIQUER LA VALEUR A LA DEL
}

void loop() {
  
  if (millis() - monChronoDepart &gt;= 100) { // SI LE CHRONOMÈTRE DÉPASSE 100 MS
    monChronoDepart = millis(); // REDÉMARRER LE CHRONOMÈTRE

    maDelValeur = !(maDelValeur); // INVERSER LA VALEUR AVEC LE SYMBOL !
    digitalWrite(maDelBroche, maDelValeur); // APPLIQUER LA VALEUR A LA DEL

  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="débogage"><a class="header" href="#débogage">Débogage</a></h1>
<h2 id="ouvrir-et-configurer-le-moniteur-série"><a class="header" href="#ouvrir-et-configurer-le-moniteur-série">Ouvrir et configurer le moniteur série</a></h2>
<p>Le <em>baud</em> définit la vitesse de communication entre la carte et l’ordinateur. Plus le <em>baud</em> est rapide, plus on peut envoyer un grand nombre de messages. Par contre, cela augmente les erreurs potentielles. Pour l’Arduino Nano, une valeur de <em>baud</em> de 57 600 est un bon compromis entre la vitesse et les erreurs de communication. <strong>Le plus important est que l’ordinateur et la carte utilisent la même valeur!</strong></p>
<p>Valeurs de <em>baud</em> possibles : 300, 600, 1200, 2400, 4800, 9600, 14400, 19200,28800, 38400, 57600, 115200 et +.</p>
<p><img src="arduino_deboguer/./arduino_serie_ouvrir.svg" alt="Ouvrir et configurer le moniteur série" /></p>
<h2 id="fonctions-pour-déboguer-avec-serial"><a class="header" href="#fonctions-pour-déboguer-avec-serial">Fonctions pour déboguer avec Serial</a></h2>
<p><code>Serial.begin(baud)</code> démarre la communication avec l’ordinateur :</p>
<pre><code class="language-arduino">Serial.begin(57600);
</code></pre>
<p><code>Serial.print()</code> envoie la valeur d'une variable à l’ordinateur une valeur en ASCII :</p>
<pre><code class="language-arduino">Serial.print(maValeur);
</code></pre>
<p><code>Serial.println()</code> envoie la valeur d'une variable à l’ordinateur une valeur en ASCII, suivi d’un retour à la ligne (ln) et d'un retour de chariot (cr) :</p>
<pre><code class="language-arduino">Serial.println(maValeur);
</code></pre>
<p><code>Serial.println()</code>  peut aussi être utilisé sans argument pour envoyer un retour à la ligne (ln) et un retour de chariot (cr) :</p>
<pre><code class="language-arduino">Serial.println();
</code></pre>
<h2 id="le-code-ascii-utilisé-pour-le-débogage"><a class="header" href="#le-code-ascii-utilisé-pour-le-débogage">Le code ASCII utilisé pour le débogage</a></h2>
<p><img src="arduino_deboguer/./arduino_serie_ascii.svg" alt="Le code ASCII " /></p>
<h2 id="exemple--envoyer-le-temps-écoulé-à-chaque-100-ms"><a class="header" href="#exemple--envoyer-le-temps-écoulé-à-chaque-100-ms">Exemple : envoyer le temps écoulé à chaque 100 ms</a></h2>
<pre><code class="language-arduino">
void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE
  Serial.print( millis() ); // ENVOYER LE TEMPS ÉCOULÉ
  Serial.println();  // TERMINER LE MESSAGE
  delay(100);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrée-numérique"><a class="header" href="#entrée-numérique">Entrée numérique</a></h1>
<p>Jusqu'à maintenant, nous avons traité des sorties (<code>OUTPUT</code>). Grâce à la commande <code>digitalWrite()</code> on peut contrôler la tension électrique d'une broche : </p>
<ul>
<li>haute tension : <code>HIGH</code>.</li>
<li>basse tension : <code>LOW</code>.</li>
</ul>
<p>On a utilisé jusqu’ici cette différence de potentiel pour allumer des DEL. </p>
<p>Si une broche est configurée en entrée (<code>INPUT</code>), nous pouvons effectuer la mesure numérique de la tension électrique. Cette mes
s’effectue sur une échelle à deux niveaux : </p>
<ul>
<li>haute tension : <code>HIGH</code> présence d’une tension plus grande que 3.5V.</li>
<li>basse tension : <code>LOW</code> présence d’une tension sous 1.5V.</li>
</ul>
<p>En fonction du signal reçu, le microcontrôleur pourra effectuer une tâche prévue (allumer la lumière lorsqu'un capteur de mouvement détecte une présence, par exemple). </p>
<p>Pour effectuer la mesure numérique de la tension électrique présente à une broche, nous utilisons la paire de fonctions suivantes :</p>
<ol>
<li>Configurer la broche <code>numeroBoche</code> en mode entrée avec <code>INPUT_PULLUP</code> :</li>
</ol>
<pre><code class="language-cpp">pinMode( numeroBoche , INPUT_PULLUP );
</code></pre>
<ol start="2">
<li>Effectuer la mesure de la tension à la broche <code>numeroBoche</code> et sauvegarder la valeur dans une variable :</li>
</ol>
<pre><code class="language-cpp">int mesureDeTension;
mesureDeTension = digitalRead( numeroBoche );
</code></pre>
<h2 id="debogage-dune-entrée-numérique"><a class="header" href="#debogage-dune-entrée-numérique">Debogage d'une entrée numérique</a></h2>
<p>Dans le code suivant, nous déboguons l'entrée numérique 2 : </p>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 2;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMERIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(115200); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'ENTRÉE NUMERIQUE EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 20 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
     
    int maNouvelleValeur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION
    
    if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
      Serial.print( &quot;Valeur numerique de la broche &quot; ); // ENVOYER UNE EN-TÊTE DE MESSAGE
      Serial.print( maBrocheEntreeNumerique ); // ENVOYER LE NUMÉRO DE LA BROCHE
      Serial.print( &quot; : &quot; ); // ENVOYER UN SÉPARATEUR ENTRE LE NUMÉRO DE LA BROCHE ET SA VALEUR
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
    }
    
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

  }
}
</code></pre>
<p><img src="entree_numerique/./debogage_entree_numerique_moniteur_serie.png" alt="Résultat du débogage analogique dans le moniteur série" /></p>
<h2 id="allumer-ou-éteindre-une-del-à-partir-dun-interrupteur"><a class="header" href="#allumer-ou-éteindre-une-del-à-partir-dun-interrupteur">Allumer ou éteindre une DEL à partir d'un interrupteur</a></h2>
<pre><code class="language-arduino">int brocheDel = 3;
int brocheInterrupteur = 12;

void setup() {
  // put your setup code here, to run once:
  pinMode( brocheDel , OUTPUT);
  pinMode( brocheInterrupteur , INPUT_PULLUP);
}

void loop() {
  // put your main code here, to run repeatedly:
  int mesureDeTension = digitalRead( brocheInterrupteur); 
  if ( mesureDeTension == LOW ) {
    digitalWrite( brocheDel, HIGH);
  } else {
    digitalWrite( brocheDel, LOW);
  }
}
</code></pre>
<h2 id="contrôler-le-clignotement-dune-del-à-partir-dun-interrupteur"><a class="header" href="#contrôler-le-clignotement-dune-del-à-partir-dun-interrupteur">Contrôler le clignotement d'une DEL à partir d'un interrupteur</a></h2>
<pre><code class="language-arduino">int brocheDel = 3;
int brocheInterrupteur = 12;

void setup() {
  // put your setup code here, to run once:
  pinMode( brocheDel , OUTPUT);
  pinMode( brocheInterrupteur , INPUT_PULLUP);
}

void loop() {
  // put your main code here, to run repeatedly:
  int mesureDeTension = digitalRead( brocheInterrupteur); 
  if ( mesureDeTension == LOW ) {
    digitalWrite( brocheDel, HIGH);
    delay(250);
    digitalWrite( brocheDel, LOW);
    delay(250);
  } else {
    digitalWrite( brocheDel, LOW);
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupteur"><a class="header" href="#interrupteur">Interrupteur</a></h1>
<p><img src="interrupteur/./interrupteur_resume.svg" alt="L'interrupteur" /></p>
<h2 id="branchement-avec-la-résistance-de-rappel-interne"><a class="header" href="#branchement-avec-la-résistance-de-rappel-interne">Branchement avec la résistance de rappel interne</a></h2>
<p>Il existe plusieurs façon de brancher un interrupteur à un microcontrôleur. Le circuit avec une résistance de rappel interne est utilisée dans le schéma ci-bas. Dans le code, il faut activer le mode correspondant à la résistance internet avec la fonction <code>pinMode()</code> ainsi :</p>
<pre><code class="language-arduino">pinMode( maBroche , INPUT_PULLUP);
</code></pre>
<p>Lorsque l'interrupteur n’est pas appuyé, il y a présence de 5V (HIGH) à la broche 5 : la résistance de rappel interne est branchée au 5V et maintient l’entrée à ce niveau par défaut.</p>
<p>Lorsque l'interrupteur est appuyé, il y a présence de 0V (LOW) à la broche 5 : la broche 5 est directement relié au GND (0V).</p>
<p><img src="interrupteur/./interrupteur_branchement.svg" alt="Branchement d'un interrupteur avec la résistance de rappel interne" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bouton-poussoir"><a class="header" href="#bouton-poussoir">Bouton poussoir</a></h1>
<p><img src="bouton_poussoir/./bouton_poussoir_pcb_bb.svg" alt="Bouton poussoir" /></p>
<p><img src="bouton_poussoir/./bouton_poussoir_pcb_disposition.svg" alt="Comment placer un bouton poussoir sur une platine d'expérimentation" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bouton-darcade"><a class="header" href="#bouton-darcade">Bouton d'arcade</a></h1>
<h2 id="référence-du-produit"><a class="header" href="#référence-du-produit">Référence du produit</a></h2>
<ul>
<li>Adafruit. (s. d.). Arcade Button with LED – 30mm Translucent Red. <a href="https://www.adafruit.com/product/3489">https://www.adafruit.com/product/3489</a></li>
</ul>
<h2 id="microsoudure-du-bouton"><a class="header" href="#microsoudure-du-bouton">Microsoudure du bouton</a></h2>
<p><img src="bouton_arcade/./bouton_arcade_soudure1.svg" alt="Poser des bulles de métal sur les quatre pattes du bouton d’arcade" /></p>
<p><img src="bouton_arcade/./bouton_arcade_soudure2.svg" alt="Effectuer la microsoudure de deux câbles à une paire de pattes" /></p>
<p><img src="bouton_arcade/./bouton_arcade_soudure3.svg" alt="Effectuer la microsoudure des deux autres pattes" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="détecter-un-changement-de-valeur"><a class="header" href="#détecter-un-changement-de-valeur">Détecter un changement de valeur</a></h1>
<h2 id="organigramme-pour-lenvoi-de-la-valeur-dune-entrée-numérique-seulement-si-elle-change"><a class="header" href="#organigramme-pour-lenvoi-de-la-valeur-dune-entrée-numérique-seulement-si-elle-change">Organigramme pour l'envoi de la valeur d'une entrée numérique seulement si elle change</a></h2>
<p><img src="changement/./interrupteur_changement_de_valeur.svg" alt="Organigramme pour l'envoi lors d'un changement" /></p>
<h2 id="extraits-de-code-pertinents"><a class="header" href="#extraits-de-code-pertinents">Extraits de code pertinents</a></h2>
<p>Pour détecter un changement de valeur, il faut : </p>
<ol>
<li>Créer une variable pour se souvenir de la valeur précédente: </li>
</ol>
<pre><code class="language-arduino">int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMÉRIQUE
</code></pre>
<ol start="2">
<li>Aller chercher la nouvelle valeur.</li>
<li>Comparer la nouvelle valeur avec la précédente:</li>
</ol>
<pre><code class="language-arduino">if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
	// FAIRE QQCH
}
</code></pre>
<ol start="4">
<li>Mettre en mémoire la nouvelle valeur:</li>
</ol>
<pre><code class="language-arduino">maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR
</code></pre>
<h2 id="exemple--envoyer-la-valeur-dune-entrée-numérique-seulement-si-elle-change"><a class="header" href="#exemple--envoyer-la-valeur-dune-entrée-numérique-seulement-si-elle-change">Exemple : envoyer la valeur d'une entrée numérique seulement si elle change</a></h2>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 4;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMÉRIQUE

void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'INTERRUPTEUR EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE
  int maNouvelleValeur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION
  if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE     
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
   }
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="envoi-optimal-de-valeur"><a class="header" href="#envoi-optimal-de-valeur">Envoi optimal de valeur</a></h1>
<p>Le code suivant envoie la valeur seulement si elle change et au maximum à chaque 20 millisecondes:</p>
<pre><code class="language-arduino">int maBrocheEntreeNumerique = 4;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE NUMÉRIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(57600); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeNumerique , INPUT_PULLUP); // CONFIGURER LA BROCHE DE L'INTERRUPTEUR EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 20 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
     
    int maNouvelleValeur = digitalRead( maBrocheEntreeNumerique ); // LECTURE DE TENSION
    
    if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
    }
    
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entrée-analogique"><a class="header" href="#entrée-analogique">Entrée analogique</a></h1>
<p><img src="entree_analogique/./entrees_analogiques_nano.svg" alt="Broches pouvant effectuer une lecture analogique" /></p>
<p>Pour effectuer la mesure analogique de la tension électrique présente à une broche, on utilison la paire de fonctions suivantes : </p>
<ol>
<li>Configurer la broche <code>maBrocheAnalogique</code> en mode entrée avec <code>INPUT</code> :</li>
</ol>
<pre><code class="language-arduino">pinMode( maBrocheAnalogique , INPUT );
</code></pre>
<ol start="2">
<li>Effectuer la lecture de la broche <code>maBrocheAnalogique</code> avec <code>analogRead()</code> :</li>
</ol>
<pre><code class="language-arduino">int maLectureAnalogique = analogRead( maBrocheAnalogique );
</code></pre>
<p>La fonction <code>analogRead()</code> mesure une tension entre 0V et 5V avec une résolution de 1024 seuils. 
La valeur retournée par <code>analogRead()</code> est toujours entre 0 et 1023.</p>
<h2 id="debogage-dune-entrée-analogique"><a class="header" href="#debogage-dune-entrée-analogique">Debogage d'une entrée analogique</a></h2>
<p>Dans le code suivant, nous déboguons l'entrée analogique A1 : </p>
<pre><code class="language-arduino">int maBrocheEntreeAnalogique = A1;
int maValeurPrecedente; // VALEUR PRÉCÉDENTE DE L'ENTRÉE ANALOGIQUE

unsigned long monChronoDepart = 0; // DEPART DE MON CHRONOMÈTRE

void setup() { // AU DÉMARRAGE
  Serial.begin(115200); // CONFIGURER LA COMMUNICATION SÉRIE
  pinMode( maBrocheEntreeAnalogique , INPUT); // CONFIGURER LA BROCHE DE L'ENTRÉE ANALOGIQUE EN ENTRÉE
}

void loop() { // RÉPÉTER LE PLUS VITE POSSIBLE

  unsigned long monChronoEcoule = millis() - monChronoDepart; // TEMPS ÉCOULÉ DE MON CHRONOMÈTRE
  unsigned long monChronoIntervalle = 20; // INTERVALLE DE TEMPS EN MILLISECONDES

  if ( monChronoEcoule &gt;= monChronoIntervalle ) { // SI 20 MS SE SONT ECOULEES...
     monChronoDepart = millis(); // ...REDÉMARRER LE CHRONOMÈTRE...
     
    int maNouvelleValeur = analogRead( maBrocheEntreeAnalogique ); // LECTURE DE TENSION
    
    if ( maNouvelleValeur != maValeurPrecedente ) { // SI LA NOUVELLE VALEUR EST DIFFERENTE DE LA PRÉCÉDENTE
      Serial.print( &quot;Valeur analogique : &quot; ); // ENVOYER UNE EN-TÊTE DE MESSAGE
      Serial.print( maNouvelleValeur ); // ENVOYER LA VALEUR
      Serial.println();  // TERMINER LE MESSAGE
    }
    
    maValeurPrecedente = maNouvelleValeur; // METTRE EN MÉMOIRE LA NOUVELLE VALEUR

  }
}
</code></pre>
<p><img src="entree_analogique/./debogage_entree_analogique_moniteur_serie.png" alt="Résultat du débogage analogique dans le moniteur série" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="potentiomètre"><a class="header" href="#potentiomètre">Potentiomètre</a></h1>
<p><img src="potentiometre/./potentiometre_explication.svg" alt="Le potentiomètre" /></p>
<h2 id="connexion"><a class="header" href="#connexion">Connexion</a></h2>
<p>Connectez le <strong>OUT</strong> du potentiomètre à une <a href="potentiometre/../entree_analogique/entree_analogique.html">entrée analogique</a> de l'Arduino.</p>
<p><img src="potentiometre/./potentiometre_schema.svg" alt="Schéma du potentiomètre à gauche et identification des broches à droite (le 5V et le GND peuvent être échangés)" /></p>
<h2 id="microsoudure-du-potentiomètre"><a class="header" href="#microsoudure-du-potentiomètre">Microsoudure du potentiomètre</a></h2>
<p><img src="potentiometre/./potentiometre_soudure1.svg" alt="Un potentiomètre 100k" /></p>
<p><img src="potentiometre/./potentiometre_soudure2.svg" alt="Poser des bulles de métal sur les trois pattes du potentiomètre" /></p>
<p><img src="potentiometre/./potentiometre_soudure3.svg" alt="Effectuer la microsoudure de trois câbles aux pattes" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="photorésistance"><a class="header" href="#photorésistance">Photorésistance</a></h1>
<p><img src="photoresistance/./photoresistance1.svg" alt="" /></p>
<h2 id="connexion-avec-un-diviseur-de-tension"><a class="header" href="#connexion-avec-un-diviseur-de-tension">Connexion avec un diviseur de tension</a></h2>
<p>La photorésistance nécessite un circuit de diviseur de tension pour être connectée à l'Arduino. Connecter le <strong>OUT</strong> à une <a href="photoresistance/../entree_analogique/entree_analogique.html">entrée analogique</a> de l'Arduino.</p>
<p><img src="photoresistance/./photoresistance_diviseur_tension.svg" alt="Idendification (à gauche) et schéma (à droite) du circuit du diviseur de tension (le 5V et le GND peuvent être échangés et la photorésistance n'a pas de sens)" /></p>
<h2 id="information-complémentaire-sur-les-diviseurs-de-tension"><a class="header" href="#information-complémentaire-sur-les-diviseurs-de-tension">Information complémentaire sur les diviseurs de tension</a></h2>
<ul>
<li>JIMBLOM. (s. d.). Voltage Dividers. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/voltage-dividers">https://learn.sparkfun.com/tutorials/voltage-dividers</a></li>
</ul>
<h2 id="micro-soudure-de-la-photorésistance"><a class="header" href="#micro-soudure-de-la-photorésistance">Micro-soudure de la photorésistance</a></h2>
<p><img src="photoresistance/./photoresistance2.svg" alt="Étapes pour effectuer la micro-soudure de deux câbles à une photorésistance" /></p>
<h2 id="exemple-sur-la-variation-de-la-luminosité-dune-del-en-fonction-de-la-lumière-ambiante"><a class="header" href="#exemple-sur-la-variation-de-la-luminosité-dune-del-en-fonction-de-la-lumière-ambiante">Exemple sur la variation de la luminosité d'une DEL en fonction de la lumière ambiante</a></h2>
<ul>
<li>F-LEB. (s. d.) Cours pour débuter sur Arduino - XVII-D. Code 17 : variation de la luminosité d'une LED en fonction de la lumière ambiante. Développez. <a href="https://arduino.developpez.com/tutoriels/arduino-a-l-ecole/?page=projet-9-les-inputs-analogiques#LXVII-D">https://arduino.developpez.com/tutoriels/arduino-a-l-ecole/?page=projet-9-les-inputs-analogiques#LXVII-D</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sortie-analogiquemodulation-de-largeur-dimpulsion-pwm"><a class="header" href="#sortie-analogiquemodulation-de-largeur-dimpulsion-pwm">Sortie analogique/modulation de largeur d'impulsion (PWM)</a></h1>
<p>Un sortie analogique permet de <strong>simuler</strong> une variation de tension électrique. Par exemple, un sortie analogique peut être utilisée pour faire varier la luminosité d'une DEL et effectuer des effets de fondu.</p>
<p>Pour <strong>simuler</strong> cette variation de tension, nous utilisons la modulation de largeur d'impulsion, <em>Pulse Width Modulation (PWM)</em> en anglais. Il s'agit de faire alterner à grande fréquence les périodes hautes (allumée) et basses (éteinte) de la broche.  En d'autre termes, cela signifie que la DEL clignote très très vite. Tellement vite que l'oeil ne percevra qu'une lumière continue qui varie d'intensité. </p>
<p><img src="sortie_analogique/./Diapositive2.SVG" alt="Simulation de variation de tension à l'aide de modulation de largeur d'impulsion" /></p>
<p>Pour utiliser une sortie analogique, on utilise cette paire de blocs de code :</p>
<ol>
<li>Configurer la broche <code>maBroche</code> en mode sortie avec <code>OUTPUT</code> :</li>
</ol>
<pre><code class="language-arduino">pinMode( maBroche , OUTPUT );
</code></pre>
<ol start="2">
<li>Contrôler la modulation de largeur d'impulsion, qui est entre 0 et 255, de la broche <code>maBroche</code> avec <code>analogWrite()</code> :</li>
</ol>
<pre><code class="language-arduino">int maValeurPWM = 255; // VALEUR ENTRE 0 et 255
analogWrite( maBroche, maValeurPWM );
</code></pre>
<h2 id="broches"><a class="header" href="#broches">Broches</a></h2>
<p>Les broches capables de supporter modulation de largeur d'impulsions sont identifiées par un «~» ou le mot «PWM». Il s'agit des broches 3, 5, 6, 9, 10 et 11 pour l'Arduino Nano.
<img src="sortie_analogique/./Diapositive1.SVG" alt="Broches qui peuvent être configurées en sortie analogique" /></p>
<h2 id="debogage-dune-sortie-analogique"><a class="header" href="#debogage-dune-sortie-analogique">Debogage d'une sortie analogique</a></h2>
<p><img src="sortie_analogique/./debogage_sortie_analogique.png" alt="Circuit d'une DEL branchée à la broche 9" /></p>
<p>Le code suivant permet de déboguer la sortie numérique à l'aide d'une DEL branchée à la broche 9. À chaque 30 millisecondes, la largeur d'impulsion est augmentée de 5. Lorsque la valeur dépasse 255, elle retombe à 0.</p>
<pre><code class="language-arduino">int maDelBroche = 9;
int maDelPWM = 0;

unsigned long monChrono;

void setup() {
  Serial.begin(115200);
  
  pinMode( maDelBroche , OUTPUT);
}

void loop() {
  if ( millis() - monChrono &gt;= 30 ) {
    monChrono = millis();
    
    maDelPWM = maDelPWM + 5;
    if ( maDelPWM &gt; 255 ) maDelPWM = 0;

    analogWrite( maDelBroche , maDelPWM );

    Serial.print(&quot;analogWrite(&quot;);
    Serial.print(maDelBroche);
    Serial.print(&quot;,&quot;);
    Serial.print(maDelPWM);
    Serial.print(&quot;)&quot;);
    Serial.println();
  }
}
</code></pre>
<h2 id="information-complémentaire-sur-les-sorties-analogiquesla-modulation-de-largeur-dimpulsion-pwm"><a class="header" href="#information-complémentaire-sur-les-sorties-analogiquesla-modulation-de-largeur-dimpulsion-pwm">Information complémentaire sur les sorties analogiques/la modulation de largeur d’impulsion (PWM)</a></h2>
<ul>
<li>JORDANDEE. (s. d.). Pulse Width Modulation. Sparkfun. <a href="https://learn.sparkfun.com/tutorials/pulse-width-modulation">https://learn.sparkfun.com/tutorials/pulse-width-modulation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chandelle"><a class="header" href="#chandelle">Chandelle</a></h1>
<p>Dans cet exemple, nous simulons une chandelle en faisant varier aléatoirement l'intensité d'une DEL. </p>
<h2 id="aléatoire"><a class="header" href="#aléatoire">Aléatoire</a></h2>
<p>La fonction <code>random()</code> permet de générer un entier <code>int</code> entre un minimum et un maximum. Il est très important de remarquer que  la valeur maximale est exclue des valeurs possibles; si le miminum est 0 et le maximum est 5, les valeurs possibles sont 0,1,2,3,4 (sans le 5).</p>
<p>Exemple d'utilisation de <code>random()</code>:</p>
<pre><code class="language-arduino">int monMin = 0;
int monMax = 256;
int maValeurAleatoire = random( monMin , monMax );
</code></pre>
<h2 id="circuit"><a class="header" href="#circuit">Circuit</a></h2>
<h3 id="composants"><a class="header" href="#composants">Composants</a></h3>
<ul>
<li>Un Arduino avec une sortie analogique.</li>
<li>Une DEL.</li>
<li>Une résistance pour limiter l'intensité du courant qui traverse la DEL.</li>
</ul>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>La DEL doit être connectée à une sortie analogique de l'Arduino.</li>
</ul>
<h3 id="schéma"><a class="header" href="#schéma">Schéma</a></h3>
<p><img src="chandelle/./debogage_sortie_analogique.png" alt="Une DEL branchée à une sortie analogique de l'Arduino" /></p>
<h2 id="code"><a class="header" href="#code">Code</a></h2>
<pre><code class="language-arduino">int maBrocheDel = 9;

unsigned long monChrono;

void setup() {
  pinMode(maBrocheDel, OUTPUT);
}

void loop() {

  if ( millis() - monChrono &gt;= 20 ) {
    monChrono = millis();

    int monMin = 0;
    int monMax = 256;
    int maValeurAleatoire = random( monMin , monMax );

    analogWrite(maBrocheDel, maValeurAleatoire);

  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-sound-control-osc"><a class="header" href="#open-sound-control-osc">Open Sound Control (OSC)</a></h1>
<p>L'<em>Open Sound Control</em> (OSC) est un protocole de communication inter-applications. Contrairement à ce qu'indique son nom, il ne concerne pas uniquement le son, mais offre un système d'organisation générique mais uniformisé de l'information pertinent au contrôle de n'importe quel système, multimédia ou pas. L'OSC a été développé à UC Berkeley Center for New Music and Audio Technology (CNMAT).</p>
<h2 id="pourquoi-losc"><a class="header" href="#pourquoi-losc">Pourquoi l'OSC?</a></h2>
<p>La plupart des protocoles (COBS, JSON, FUDI, etc.) permettent une trop grande latitude dans la manière d'organiser les données, et s'appuient donc sur des architectures personnalisées spécifiques à chaque développeur. L'OSC impose une structure particulière de l'information que toutes les applications doivent supporter ce qui rend toute communication plus universelle : tout le monde parle la même langue!</p>
<p>L'OSC fournit également une vérification (primitive) des erreurs de transmission, ce qui est très important lorsque l'on travaille avec flux susceptibles au bruit!</p>
<h2 id="client-et-serveur"><a class="header" href="#client-et-serveur">Client et serveur</a></h2>
<ul>
<li>Une application qui envoie de l'OSC est un <strong>client OSC</strong>. </li>
<li>Une application qui reçoit de l'OSC est un <strong>serveur OSC</strong>. </li>
<li>Habituellement, toutes les applications qui supportent l'OSC sont <em>client OSC</em> et <em>serveur OSC</em> (elles peuvent donc supporter la réception et l'envoi de messages OSC).</li>
</ul>
<h2 id="unité-de-transmission"><a class="header" href="#unité-de-transmission">Unité de transmission</a></h2>
<ul>
<li>L'unité de transmission de l'OSC est le <strong>message</strong> ou le <strong>bundle</strong>. Un <strong>bundle</strong> contient un ou plusieurs messages et un <strong>timetag</strong>.</li>
<li>L'OSC est unidirectionnel et n'offre pas d'accusé de réception (on ne sait pas si le destinataire a reçu le message).</li>
</ul>
<h2 id="paquetage"><a class="header" href="#paquetage">Paquetage</a></h2>
<p>L'OSC ne définit pas la mise en paquet des messages. </p>
<p>Les deux types de paquets les plus communs sont:</p>
<ul>
<li><strong>UDP</strong> (le mode par défaut) pour la communication par réseau ou interne de l'ordinateur</li>
<li><strong>SLIP</strong> (souvent nommé <strong>OSC SLIP</strong>) pour la communication par série (USB) avec des microcontrôleurs plus vieux</li>
</ul>
<h3 id="par-udp"><a class="header" href="#par-udp">Par UDP</a></h3>
<p>De façon générale, l'OSC est envoyé sur un réseau par <em>UDP</em>. </p>
<p>Pour envoyer un message, il faut spécifier l'adresse UDP du destinataire. Cette adresse se compose de deux parties:</p>
<ul>
<li>IP de la machine adressée.</li>
<li>Port du client OSC.</li>
</ul>
<p>Pour recevoir un message , il faut simplement spécifier le port de réception.</p>
<h3 id="par-slip"><a class="header" href="#par-slip">Par SLIP</a></h3>
<p>Le <em>SLIP</em> ne permet pas d'adresser les messages à des destinataires spécifiques. Seule l'application qui est connectée au port série peut envoyer et recevoir des messages (qu'elle peut relayer par la suite par UDP si nécessaire).</p>
<h2 id="exemples-darchitectures"><a class="header" href="#exemples-darchitectures">Exemples d'architectures</a></h2>
<h3 id="un-client-sur-une-machine---un-serveur-sur-une-autre-machine"><a class="header" href="#un-client-sur-une-machine---un-serveur-sur-une-autre-machine">Un client sur une machine -&gt; un serveur sur une autre machine</a></h3>
<p><img src="osc/./OSC_unidirectionnel.png" alt="Un client qui envoie des message à un serveur" /></p>
<h3 id="une-machine---une-autre-machine"><a class="header" href="#une-machine---une-autre-machine">Une machine &lt;-&gt; une autre machine</a></h3>
<p><img src="osc/./OSC_bidirectionnel.png" alt="Deux clients/serveurs" /></p>
<h3 id="un-client---un-serveur-sur-la-même-machine"><a class="header" href="#un-client---un-serveur-sur-la-même-machine">Un client -&gt; un serveur sur la même machine</a></h3>
<p>L'architecture suivante  permet d'envoyer un message entre deux applications différentes sur la même machine (ou à l'intérieur de la même application). L'adresse IP <strong>127.0.0.1</strong> veut dire «la machine elle-même».</p>
<p><img src="osc/./OSC_mono.png" alt="Un client qui envoie des message à un serveur local (sur la même machine)" /></p>
<h2 id="composition-dun-bundle-osc"><a class="header" href="#composition-dun-bundle-osc">Composition d'un bundle OSC</a></h2>
<p>Un bundle OSC contient plusieurs messages OSC. Il sert surtout à s'assurer que plusieurs messages arrivent simultanément au destinataire. </p>
<h2 id="composition-dun-message-osc"><a class="header" href="#composition-dun-message-osc">Composition d'un message OSC</a></h2>
<p>Un message OSC est composé des éléments suivants:</p>
<ul>
<li>une <strong>adresse</strong></li>
<li>un ou plusieurs <strong>arguments</strong></li>
</ul>
<h3 id="adresse"><a class="header" href="#adresse">Adresse</a></h3>
<p>L'adresse indique quel est le paramètre que l'on veut modifier. Elle peut être composée de n'importe quelle lettre et chiffre. Par contre, voici quelques recommandations à suivre lorsque vous concevez votre propre serveur OSC:</p>
<ul>
<li>Une adresse doit toujours commencer par <code>/</code> (attention, dans certains logiciels comme Pure Data ou TouchDesigner, le <code>/</code>  est implicite).</li>
<li>Chaque <code>/</code> subdivise l'adresse en hiérarchie symbolique. Plus une subdivision se trouve au début, plus est elle haute dans hiérarchie. Prenons comme exemple <code>/A/B</code> : <code>A</code> englobe <code>B</code> et <code>B</code> fait partie de <code>A</code>.</li>
<li>Tous les <em>espaces</em> doivent être remplacés par des <code>_</code>.</li>
</ul>
<p>Quelques exemples: </p>
<pre><code>/application/fenetre/bouton
/torse/bras/main/doigt/index
/renoise/pattern_name
</code></pre>
<h3 id="arguments"><a class="header" href="#arguments">Arguments</a></h3>
<p>Chaque argument possède un type. Il existe quatre types de base :</p>
<ul>
<li><em>int</em> : nombre entier à 32 bit.</li>
<li><em>float</em> : nombre à virgule à 32 bit.</li>
<li><em>string</em> : chaîne de caractères.</li>
<li><em>blob</em> : un tableau d'octets (byte).</li>
</ul>
<p>Un message OSC peut mélanger plusieurs types d'arguments différents et peut contenir n'importe quel nombre d'arguments. </p>
<p>Quelques exemples: </p>
<pre><code>/application/fenetre/bouton 1
/torse/bras/main/doigt/index 0.324
/renoise/pattern_name intro 43
</code></pre>
<p>Voici quelques recommandations à suivre lorsque vous concevez votre propre serveur OSC:</p>
<ul>
<li>Essayer de réduire le nombre d'arguments au profit d'un adressage plus complet. Cela respecte mieux la hiérarchie de l'adressage et plusieurs serveurs OSC ne supportent qu'un seul argument à la fois. Par exemple, utiliser <code>/piste/0/vol 1.</code> a un seul argument plutôt que <code>/piste/vol 0 1.</code> à deux arguments.</li>
<li>Utiliser autant que possible des nombres réels normalisés entre <code>0.</code> et <code>1.</code> pour plus de compatibilité.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microosc"><a class="header" href="#microosc">MicroOsc</a></h1>
<p><strong>MicroOsc</strong> est une bibliothèque pour Arduino permettant à la plaquette de communiquer en OSC par SLIP ou UDP.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p><img src="microosc/./arduino_ide_gerer_bilbiotheques.png" alt="Ouverture du gestionnaire de bibliothèques" /></p>
<p><img src="microosc/./arduino_ide_installer_microosc.png" alt="Recherche et installation de la bibliothèque MicroOsc" /></p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>La documentation (en anglais) se trouve sur le <a href="https://github.com/thomasfredericks/MicroOsc">GitHub de la bibliothèque MicroOsc</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip"><a class="header" href="#osc-slip">OSC SLIP</a></h1>
<h2 id="scénario"><a class="header" href="#scénario">Scénario</a></h2>
<p><img src="osc_slip/./scenario_problematique.svg" alt="La question se poser sur comment relier l'Arduino à l'espace immersif?" /></p>
<h2 id="solutions-de-connectique"><a class="header" href="#solutions-de-connectique">Solutions de connectique</a></h2>
<p><img src="osc_slip/./scenario_multimedia.svg" alt="L'OSC SLIP permet de connecter un Arduino avec une application multimédia à travers sa prise USB" /></p>
<p>Cette solution se décline en deux implémentations :</p>
<ul>
<li>Avec une application qui supporte directement l'OSC SLIP.</li>
<li>Avec une application qui supporte l'OSC UPD à l'aide d'un relais OSC SLIP ⇄ OSC UDP.</li>
</ul>
<h3 id="dans-le-cas-dune-application-qui-supporte-directement-losc-slip"><a class="header" href="#dans-le-cas-dune-application-qui-supporte-directement-losc-slip">Dans le cas d'une application qui supporte directement l'OSC SLIP</a></h3>
<p><img src="osc_slip/./osc_slip_connectique_directe.svg" alt="Scénario de connectique à une application qui supporte directement l'OSC SLIP" /></p>
<h3 id="dans-le-cas-dune-application-qui-supporte-losc-upd-à-laide-dun-relais-osc-slip--osc-udp"><a class="header" href="#dans-le-cas-dune-application-qui-supporte-losc-upd-à-laide-dun-relais-osc-slip--osc-udp">Dans le cas d'une application qui supporte l'OSC UPD à l'aide d'un relais OSC SLIP ⇄ OSC UDP</a></h3>
<p><img src="osc_slip/../osc_espace_immersif/osc_espace_immersif_connectique.svg" alt="Schématisation de la chaîne de connectique OSC SLIP ⇄ OSC UDP" /></p>
<h2 id="circuit-de-démonstration"><a class="header" href="#circuit-de-démonstration">Circuit de démonstration</a></h2>
<h3 id="schéma-du-circuit-1"><a class="header" href="#schéma-du-circuit-1">Schéma du circuit</a></h3>
<p><img src="osc_slip/../osc_espace_immersif/osc_espace_immersif_schema.png" alt="Schéma d'un circuit avec un bouton d'arcade illuminé, une photorésistance et un potentiometre" /></p>
<h3 id="illustration-du-circuit-1"><a class="header" href="#illustration-du-circuit-1">Illustration du circuit</a></h3>
<p><img src="osc_slip/../osc_espace_immersif/osc_espace_immersif_illustration.png" alt="Illustration d'un circuit avec un bouton d'arcade illuminé, une photorésistance et un potentiometre" /></p>
<h2 id="code-osc-slip-avec-microosc-pour-la-démonstration"><a class="header" href="#code-osc-slip-avec-microosc-pour-la-démonstration">Code OSC SLIP avec MicroOsc pour la démonstration</a></h2>
<pre><code class="language-arduino">// MicroOsc_Demo_SLIP
// by Thomas O Fredericks
// 2023-02-20

// WHAT IS DOES
// ======================
// OSC communication example.
//
// OSC messages received by the Arduino :
// - /led int -&gt; turn off (0) or on (1) a LED 
// - /pwm int -&gt; set the pwm (0-255) of the arcade button LED 
//
// OSC messages sent by the Arduino :
// - /pot int -&gt; sends the value of a potentiometer 
// - /photo int -&gt; sends the value of a photocell
// - /button int -&gt; sends the value of a button

// HARDWARE REQUIREMENTS
// ==================
// - POTENTIOMETER connected to analog pin A0
// - POTOCELL (with voltage resistor) connected to analog pin A1
// - Illuminated arcade BUTTON with it's switch connected to pin 2
//   and it's LED connected to pin 3 (will be PWM modulated)
// - LED (and matching resistor) connected to pin 5 (will be turned off or on)

// REQUIRED LIBRARIES
// ==================
// - MicroOsc

// REQUIRED CONFIGURATION
// ======================
// - Set the baud of your computer's serial connection to 115200



#include &lt;MicroOscSlip.h&gt;

// THE NUMBER 64 BETWEEN THE &lt; &gt; SYMBOLS  BELOW IS THE MAXIMUM NUMBER OF BYTES RESERVED FOR INCOMMING MESSAGES.
// MAKE SURE THIS NUMBER OF BYTES CAN HOLD THE SIZE OF THE MESSAGE YOUR ARE RECEIVING IN ARDUINO.
// OUTGOING MESSAGES ARE WRITTEN DIRECTLY TO THE OUTPUT AND DO NOT NEED ANY RESERVED BYTES.
MicroOscSlip&lt;64&gt; myMicroOsc(&amp;Serial);  // CREATE AN INSTANCE OF MicroOsc FOR SLIP MESSAGES

unsigned long myChronoStart = 0;  // VARIABLE USED TO LIMIT THE SPEED OF THE loop() FUNCTION.

// POTENTIOMETER
int myPotPin = A0;
int myPotStoredValue = 0;

// PHOTOCELL
int myPhotoPin = A1;
int myPhotoStoredValue = 0;

// BUTTON
int myButtonPin = 2;
int myButtonSotredValue = 0;

// BUTON LED
int myButtonLedPin = 3;  // PIN MUST SUPPORT PWM

// LED
int myLedPin = 5;

/********
  SETUP
*********/
void setup() {
  Serial.begin(115200);                // START SERIAL COMMUNICATION
  pinMode(myPotPin, INPUT);            // POTENTIOMETER: ANALOG INPUT
  pinMode(myPhotoPin, INPUT);          // PHOTOCELL: ANALOG INPUT
  pinMode(myButtonPin, INPUT_PULLUP);  // BUTTON: DIGITAL INPUT
  pinMode(myButtonLedPin, OUTPUT);     // LED: DIGITAL OUTPUT
  pinMode(myLedPin, OUTPUT);           // LED: DIGITAL OUTPUT
}

/****************
  ON OSC MESSAGE
*****************/
void myOnOscMessageReceived(MicroOscMessage&amp; oscMessage) {
  
  if (oscMessage.checkOscAddress(&quot;/led&quot;)) {  // IF THE ADDRESS IS /led
    int newValue = oscMessage.nextAsInt();  // GET NEW VALUE AS INT
    digitalWrite(myLedPin, newValue);       // SET LED OUTPUT TO VALUE (DIGITAL: OFF/ON)
    
  } else if (oscMessage.checkOscAddress(&quot;/buttonLed&quot;)) {  // IF THE ADDRESS IS /buttonLed
    int newValue = oscMessage.nextAsInt();  // GET NEW VALUE AS INT
    analogWrite(myButtonLedPin, newValue);       // SET LED OUTPUT TO VALUE (ANALOG/PWM: 0-255)

  }
  
}

/****************
  POTENTIOMETER UPDATE
****************/
void myPotUpdateValueAndSendIfChanged() {
  int newValue = analogRead(myPotPin);             // READ NEW VALUE
  if (newValue != myPotStoredValue) {              // IF NEW VALUE DIFFERENT THAN STORED VALUE
    myPotStoredValue = newValue;                   // STORE NEW VALUE
    myMicroOsc.sendInt(&quot;/pot&quot;, myPotStoredValue);  // SEND UPDATED VALUE
  }
}

/*********************
  PHOTOCELL UPDATE
**********************/
void myPhotoUpdateValueAndSendIfChanged() {
  int newValue = analogRead(myPhotoPin);               // READ CURRENT VALUE
  if (newValue != myPhotoStoredValue) {                // IF NEW VALUE DIFFERENT THAN STORED VALUE
    myPhotoStoredValue = newValue;                     // STORE NEW VALUE
    myMicroOsc.sendInt(&quot;/photo&quot;, myPhotoStoredValue);  // SEND UPDATED VALUE
  }
}

/*********************
  BUTTON UPDATE
**********************/
void myButtonUpdateValueAndSendIfChanged() {
  int newValue = digitalRead(myButtonPin);               // READ CURRENT VALUE
  if (newValue != myButtonSotredValue) {                 // IF NEW VALUE DIFFERENT THAN STORED VALUE
    myButtonSotredValue = newValue;                      // STORE NEW VALUE
    myMicroOsc.sendInt(&quot;/button&quot;, myButtonSotredValue);  // SEND UPDATED VALUE
  }
}

/*******
  LOOP
********/
void loop() {

  myMicroOsc.onOscMessageReceived(myOnOscMessageReceived);  // TRIGGER OSC RECEPTION

  if (millis() - myChronoStart &gt;= 50) {  // IF 50 MS HAVE ELLAPSED
    myChronoStart = millis();            // RESTART CHRONO

    myPotUpdateValueAndSendIfChanged();  // POTENTIOMETER UPDATE

    myPhotoUpdateValueAndSendIfChanged();  // PHOTOCELL UPDATE

    myButtonUpdateValueAndSendIfChanged();  // BUTTON UPDATE
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip--pure-data-pd"><a class="header" href="#osc-slip--pure-data-pd">OSC SLIP : Pure Data (PD)</a></h1>
<h1 id="osc-slip-dans-pure-data"><a class="header" href="#osc-slip-dans-pure-data">OSC SLIP dans Pure Data</a></h1>
<h2 id="installation-de-pure-data"><a class="header" href="#installation-de-pure-data">Installation de Pure Data</a></h2>
<p>Télécharger la version appropriée au système d'exploitation (idéallement la version avec installateur) : <a href="https://puredata.info/downloads/pure-data">puredata.info/downloads/pure-data</a>.</p>
<h2 id="installation-des-objets-additionnels-pour-losc-slip-dans-pure-data"><a class="header" href="#installation-des-objets-additionnels-pour-losc-slip-dans-pure-data">Installation des objets additionnels pour l'OSC SLIP dans Pure Data</a></h2>
<p>Pour recevoir et envoyer de  l'OSC SLIP, il est nécessaire d'ajouter l'object <strong>comport</strong> à Pure Data.</p>
<p><img src="pd/./pd_installer_objets_supplementaires.svg" alt="Ouvrir le menu d'installation des objets supplémentaires" /></p>
<p><img src="pd/./pd_installation_comport.svg" alt="Installer comport" /></p>
<p><img src="pd/./pd_installation_comport_reussie.svg" alt="Installation de comport réussie (parfois le logiciel ne confirme pas l'installation réussie)" /></p>
<h2 id="patcher-pure-data-pour-traiter-directement-losc-slip"><a class="header" href="#patcher-pure-data-pour-traiter-directement-losc-slip">Patcher Pure Data pour traiter directement l'OSC SLIP</a></h2>
<p><img src="pd/./osc_slip_pd_direct.svg" alt="Capture d'écran du patcher «osc_slip.pd» (l'opacité du code optionnel a été réduite)" /></p>
<p><a href="pd/./osc_slip.pd"><img src="pd/../fichier_zip.png" alt="Cliquer pour télécharger «osc_slip.pd»" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip-avec-max"><a class="header" href="#osc-slip-avec-max">OSC SLIP avec Max</a></h1>
<h2 id="installation-de-max"><a class="header" href="#installation-de-max">Installation de Max</a></h2>
<p>Télécharger le logiciel ici (si possible la version avec installateur) : <a href="https://cycling74.com/downloads">cycling74.com/downloads</a>.</p>
<h2 id="installation-des-objets-additionnels-pour-losc-slip-dans-max"><a class="header" href="#installation-des-objets-additionnels-pour-losc-slip-dans-max">Installation des objets additionnels pour l'OSC SLIP dans Max</a></h2>
<p>Pour faire fonctionner l'OSC SLIP il est nécessaire d'ajouter une collection d'objets à Max:</p>
<ul>
<li>CNMAT</li>
</ul>
<p><img src="max/./max_installation_cnmat.png" alt="Installation de la bibliothèque(package) CNMAT dans Max" /></p>
<h2 id="patcher-pour-le-traitement-de-losc-slip-directement-dans-max"><a class="header" href="#patcher-pour-le-traitement-de-losc-slip-directement-dans-max">Patcher pour le traitement de l'OSC SLIP directement dans Max</a></h2>
<p><a href="max/./osc_slip_direct.maxpat"><img src="max/./osc_slip_direct_max_patcher.png" alt="Exemple osc_slip_direct.maxpat (cliquer pour télécharger)" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-slip-web"><a class="header" href="#osc-slip-web">OSC SLIP Web</a></h1>
<h2 id="préalables"><a class="header" href="#préalables">Préalables</a></h2>
<p>Cette exemple dépend du code et du circuit présenté à la section <a href="osc_slip_web/../osc_slip/osc_slip.html">OSC SLIP avec MicroOsc</a>.</p>
<h2 id="installation-de-nodejs"><a class="header" href="#installation-de-nodejs">Installation de Node.js</a></h2>
<p><img src="osc_slip_web/./installation_nodejs.png" alt="Installation de Node.js" /></p>
<h2 id="téléchargement-du-code-slipwebdemozip"><a class="header" href="#téléchargement-du-code-slipwebdemozip">Téléchargement du code slipWebDemo.zip</a></h2>
<p><a href="osc_slip_web/./slipWebDemo.zip"><img src="osc_slip_web/./telecharger_slipWebDemo.png" alt="CLiquer pour télécharger slipWebDemo.zip" /></a> </p>
<p><img src="osc_slip_web/./extraire_slipWebDemo.png" alt="Décompresser le code" /> </p>
<h2 id="configuration-et-démarrage-de-slipwebdemo"><a class="header" href="#configuration-et-démarrage-de-slipwebdemo">Configuration et démarrage de «slipWebDemo</a></h2>
<p><img src="osc_slip_web/./Diapositive1.SVG" alt="Démarrez l'invite de commande" /></p>
<p><img src="osc_slip_web/./Diapositive2.SVG" alt="Démarrez le script Node.js «slipDemo.js»" /></p>
<p><img src="osc_slip_web/./Diapositive4.SVG" alt="Configurez le code avec le bon port" /></p>
<p><img src="osc_slip_web/./Diapositive5.SVG" alt="Redémarrez le script et ouvrez le navigateur Web à la bonne adresse" /></p>
<p><img src="osc_slip_web/./Diapositive3.SVG" alt="Pour arrêter un script, tapez Ctrl+c 1 ou 2  fois" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relais-osc-slip--osc-udp-avec-pure-data"><a class="header" href="#relais-osc-slip--osc-udp-avec-pure-data">Relais OSC SLIP ⇄ OSC UDP avec Pure Data</a></h1>
<p>Pure Data peut être utilisé pour relayer les messages OSC entre une source SLIP et une source UDP. Cela permet d'ajouter la communication OSC UDP à un microcontrôleur qui ne possède d'habitude pas cette capacité.</p>
<p><img src="pd/../osc_slip/osc_slip_connectique.svg" alt="Scénario de connectique OSC SLIP ⇄ OSC UDP" /></p>
<h2 id="prérequis"><a class="header" href="#prérequis">Prérequis</a></h2>
<p>Assurez-vous d'avoir suivi les instruction dans la section <a href="pd/./osc_slip.html">OSC SLIP avec Pure Data (PD)</a>.</p>
<h2 id="patcher-pure-data-pour-le-relais-des-messages-osc-slip--udp"><a class="header" href="#patcher-pure-data-pour-le-relais-des-messages-osc-slip--udp">Patcher Pure Data pour le relais des messages OSC SLIP ⇄ UDP</a></h2>
<p><img src="pd/./osc_slip_pd_relay.svg" alt="Capture d'écran du patcher «osc_slip.pd» (l'opacité du code optionnel a été réduite)" /></p>
<p><a href="pd/./osc_slip.pd"><img src="pd/../fichier_zip.png" alt="Cliquer pour télécharger «osc_slip.pd»" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relais-osc-slip--osc-udp-avec-max"><a class="header" href="#relais-osc-slip--osc-udp-avec-max">Relais OSC SLIP ⇄ OSC UDP avec Max</a></h1>
<p>Max peut être utilisé pour relayer les messages OSC entre une source SLIP et une source UDP. Cela permet d'ajouter la communication OSC UDP à un microcontrôleur qui ne possède d'habitude pas cette capacité.</p>
<p><img src="max/./osc_slip_connectique.svg" alt="Scénario de connectique OSC SLIP ⇄ OSC UDP" /></p>
<h2 id="prérequis-1"><a class="header" href="#prérequis-1">Prérequis</a></h2>
<p>Assurez-vous d'avoir suivi les instruction dans la section <a href="max/../max/max_osc_slip.html">OSC SLIP : Max</a>.</p>
<h2 id="patcher-max-pour-le-relais-des-messages-osc-slip--udp"><a class="header" href="#patcher-max-pour-le-relais-des-messages-osc-slip--udp">Patcher Max pour le relais des messages OSC SLIP ⇄ UDP</a></h2>
<p><img src="max/./osc_slip_relay_max_patcher.png" alt="Capture d'écran du patcher «osc_slip_relay.maxpat»" /></p>
<p><a href="max/./osc_slip_relay.maxpat"><img src="max/../fichier_zip.png" alt="Cliquer pour télécharger «osc_slip_relay.maxpat»" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-udp-dans-pure-data"><a class="header" href="#osc-udp-dans-pure-data">OSC UDP dans Pure Data</a></h1>
<h2 id="installation-de-pure-data-1"><a class="header" href="#installation-de-pure-data-1">Installation de Pure Data</a></h2>
<p>Télécharger la version appropriée pour votre système ici (si possible la version avec installateur) : <a href="https://puredata.info/downloads/pure-data">puredata.info/downloads/pure-data</a></p>
<h2 id="patcher-pure-data-pour-traiter-directement-losc-udp"><a class="header" href="#patcher-pure-data-pour-traiter-directement-losc-udp">Patcher Pure Data pour traiter directement l'OSC UDP</a></h2>
<p><img src="pd/./osc_udp_pd.png" alt="Capture d'écran du patcher «osc_udp.pd»" /></p>
<p><a href="pd/./osc_udp.pd"><img src="pd/../fichier_zip.png" alt="Cliquer pour télécharger «osc_udp.pd»" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-udp-avec-max"><a class="header" href="#osc-udp-avec-max">OSC UDP avec Max</a></h1>
<h2 id="installation-de-max-1"><a class="header" href="#installation-de-max-1">Installation de Max</a></h2>
<p>Télécharger le logiciel ici (si possible la version avec installateur) : <a href="https://cycling74.com/downloads">cycling74.com/downloads</a></p>
<h2 id="patcher-pour-le-traitement-de-losc-udp-directement-dans-max"><a class="header" href="#patcher-pour-le-traitement-de-losc-udp-directement-dans-max">Patcher pour le traitement de l'OSC UDP directement dans Max</a></h2>
<p><img src="max/./osc_udp_maxpat.png" alt="Exemple «osc_udp_maxpat»" /></p>
<p><a href="max/./osc_udp_maxpat"><img src="max/../fichier_zip.png" alt="Cliquer pour télécharger «osc_udp_maxpat»" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-avec-vcv-rack"><a class="header" href="#osc-avec-vcv-rack">OSC avec VCV Rack</a></h1>
<p>Il existe quelques modules OSC pour VCV Rack.  Le module <strong>cvOSCcv</strong> est privilégié pour sa configurabilité. </p>
<h2 id="installation-de-cvosccv"><a class="header" href="#installation-de-cvosccv">Installation de cvOSCcv</a></h2>
<p>Le module <strong>cvOSCcv</strong> est disponible dans <a href="https://library.vcvrack.com/?query=cvosccv&amp;brand=&amp;tag=&amp;license=">VCV Library</a>.</p>
<h3 id="configuration-de-cvosccv"><a class="header" href="#configuration-de-cvosccv">Configuration de cvOSCcv</a></h3>
<p><img src="vcv_rack/./cvosccv_configuration_generale.svg" alt="Configuration générale" /></p>
<p><img src="vcv_rack/./cvosccv_adresses.svg" alt="Configurer les adresses des messages" /></p>
<p><img src="vcv_rack/./cvosccv_configurer_reception_messages.svg" alt="Configuration de la réception de messages analogiques" /></p>
<p><img src="vcv_rack/./cvosccv_configurer_reception_message_numerique.svg" alt="Configuration de la réception du messages numérique" /></p>
<p><img src="vcv_rack/./cvosccv_configurer_envoi_messages.svg" alt="Configuration de l'envoi de messages" /></p>
<p><img src="vcv_rack/./cvosccv_demarrer.svg" alt="Démarrer la connexion OSC" /></p>
<p><img src="vcv_rack/./cvosccv_visualisation_messages.svg" alt="Visualisation des messages OSC" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-udp-unity"><a class="header" href="#osc-udp-unity">OSC UDP: Unity</a></h1>
<h2 id="préalables-1"><a class="header" href="#préalables-1">Préalables</a></h2>
<p>Pour envoyer de l'OSC UDP à Unity, vous pouvez l'une des solutions suivantes :</p>
<ul>
<li><strong>de préférence</strong> un microcontrôleur avec une connexion WiFI ou Ethernet qui peut communiquer en UDP ; dans ce cas, utilisez <a href="osc_udp_unity/../osc_udp/osc_udp.html">MicroOsc UDP</a>.</li>
<li><strong>sinon</strong> un microcontrôleur avec une connexion série ; dans ce cas, utilisez <a href="osc_udp_unity/../osc_slip/osc_slip.html">MicroOsc SLIP</a> ainsi qu'un logiciel permettant de faire le relais SLIP à UDP.</li>
</ul>
<h3 id="relais-slip-à-udp-avec-pure-data-pour-microosc-slip"><a class="header" href="#relais-slip-à-udp-avec-pure-data-pour-microosc-slip">Relais SLIP à UDP avec Pure Data pour <a href="osc_udp_unity/../osc_slip/osc_slip.html">MicroOsc SLIP</a></a></h3>
<p><img src="osc_udp_unity/osc_slip_pd_udp_unity.svg" alt="Schéma illustrant le relais SLIP à UDP avec Pure Data" /></p>
<ul>
<li>Circuit et code Arduino : <a href="osc_udp_unity/../osc_slip/osc_slip.html">OSC SLIP avec MicroOsc</a></li>
<li>Code Pure Data : <a href="osc_udp_unity/../pd/relais_osc_slip_udp.html">Relais OSC UDP avec PD</a></li>
</ul>
<h2 id="installation-doscjackvs-dans-unity"><a class="header" href="#installation-doscjackvs-dans-unity">Installation d'OSCJackVS dans Unity</a></h2>
<p>Nous utilisons <a href="https://github.com/keijiro/OscJackVS">OSCJackVS</a> de Keijiro pour traiter les messages OSC UDP dans Unity.</p>
<p>Voici l'information à inscrire dans les paramètres du gestionnaire de paquets (voir figure ci-bas) :</p>
<ul>
<li>Name: <code>Keijiro</code></li>
<li>URL: <code>https://registry.npmjs.com</code></li>
<li>Scope: <code>jp.keijiro</code></li>
</ul>
<p><img src="osc_udp_unity/./Diapositive1.SVG" alt="Ajoutez le régistre de paquets de Keijiro" /></p>
<p><img src="osc_udp_unity/./Diapositive2.SVG" alt="Installez OSCJackVS" /></p>
<p><img src="osc_udp_unity/./Diapositive7.SVG" alt="Au besoin regénérez les Visual Scripting Nodes pour intégrer le code d'OSCJackVS" /></p>
<p><img src="osc_udp_unity/./Diapositive3.SVG" alt="Créez une connexion" /></p>
<p><img src="osc_udp_unity/./Diapositive4.SVG" alt="Renommez et configurez la connexion" /></p>
<h2 id="assignation-du-message-pot-à-la-rotation-dun-cylindre"><a class="header" href="#assignation-du-message-pot-à-la-rotation-dun-cylindre">Assignation du message /pot à la rotation d'un cylindre</a></h2>
<p><img src="osc_udp_unity/./Diapositive5.SVG" alt="Créez un cylindre et un nouveau Script Graph" /></p>
<p><img src="osc_udp_unity/./Diapositive6.SVG" alt="Ajoutez le code pour recevoir le message /pot et l'assigner à la rotation du cylindre" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osc-udp-avec-touchdesigner"><a class="header" href="#osc-udp-avec-touchdesigner">OSC UDP avec TouchDesigner</a></h1>
<h2 id="installation-de-touchdesigner"><a class="header" href="#installation-de-touchdesigner">Installation de TouchDesigner</a></h2>
<p>Le téléchargement du logiciel TouchDesigner (pour Windows et macOS) est disponible ici : <a href="https://derivative.ca/download">Download | Derivative</a></p>
<h2 id="code-pour-traiter-losc-udp-dans-touchdesigner"><a class="header" href="#code-pour-traiter-losc-udp-dans-touchdesigner">Code pour traiter l'OSC UDP dans TouchDesigner</a></h2>
<h3 id="capture-décran"><a class="header" href="#capture-décran">Capture d'écran</a></h3>
<p><img src="touchdesigner/./td_osc_udp.svg" alt="Capture d'écran de «td_osc_udp.toe»" /></p>
<h3 id="téléchargement"><a class="header" href="#téléchargement">Téléchargement</a></h3>
<ul>
<li>La document TouchDesigner peut être téléchargé ici : <a href="touchdesigner/./td_osc_udp.toe">td_osc_udp.toe</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bande-de-del"><a class="header" href="#bande-de-del">Bande de DEL</a></h1>
<h2 id="préparation"><a class="header" href="#préparation">Préparation</a></h2>
<p><img src="bande_del/./Diapositive1.SVG" alt="Couper une bande de DEL" /></p>
<p><img src="bande_del/./Diapositive2.SVG" alt="Enlevez soigneusement le revêtement sur la partie cuivrée coupée" /></p>
<p><img src="bande_del/./Diapositive3.SVG" alt="Effectuez la soudure de 3 connexions : GND, DI et +12v" /></p>
<p><img src="bande_del/./Diapositive4.SVG" alt="Ajoutez une deuxième connexion au GND (pour un total de 4 connexions)" /></p>
<h2 id="modèles"><a class="header" href="#modèles">Modèles</a></h2>
<p>Le modèle de bande de DEL qu'on utilise est le WS281X (le X indique que le dernier chiffre n’est pas important). Elle fonctionne avec une tension d'alimentation à 12V.</p>
<p>Elle est aussi connue sous le nom de <strong>NeoPixel</strong>, parce qu’elle a été popularisée en Amérique par la compagnie Adafruit qui l'a baptisé ainsi. Adafruit fournit <a href="https://www.adafruit.com/category/168">plusieurs modèles de NeoPixel</a>. Cependant, les NeoPixels fonctionnent à 5V. Toutefois, le système de contrôle est identique à celui de la bande de DEL qu'on utilise. </p>
<p><img src="bande_del/./bande_del_modeles.svg" alt="Différents modèles de bandes de DEL" /></p>
<h2 id="ordre-des-couleurs-des-del"><a class="header" href="#ordre-des-couleurs-des-del">Ordre des couleurs des DEL</a></h2>
<p>Pour chaque modèle de bande de DEL, les couleurs sont disposées dans un certain ordre: RGB, GRB, BGR, etc. <strong>Dans notre cas, l'ordre est : RGB</strong>.</p>
<h2 id="broches-1"><a class="header" href="#broches-1">Broches</a></h2>
<p>Les NeoPixels possèdent au moins 3 broches qui doivent toutes être connectées :</p>
<ul>
<li>GND.</li>
<li>Alimentation (5V, 12V ou 24V selon les modèles).</li>
<li>Entrée de données (<em>Data In</em>).</li>
</ul>
<p>Les WS281X 12V possèdent 4 broches (la broche supplémentaire est optionnelle) :</p>
<ul>
<li><strong>GND</strong>.</li>
<li><strong>+12V</strong> pour l'alimentation.</li>
<li><strong>DI</strong> pour l'entrée de données.</li>
<li><strong>BI</strong> qui est optionnel et utilisé seulement en cas de bris d'un segment.</li>
</ul>
<h2 id="branchement"><a class="header" href="#branchement">Branchement</a></h2>
<p><img src="bande_del/./bande_del_sens.svg" alt="Attention, les bandes de DEL ont un sens: connectez vous du côté du DI (Data Input) et non du DO!" /></p>
<p><img src="bande_del/./Diapositive5.SVG" alt="Alimentez la bande de DEL avec l’alimentation 12v" /></p>
<p><img src="bande_del/./bande_del_connectique.svg" alt="Peu-importe le modèle, la connectique est similaire" /></p>
<p><img src="bande_del/./bande_del_extension_schema.svg" alt="Les bandes peuvent être allongées en connectant les DO aux DI des bandes suivantes" /></p>
<p><img src="bande_del/./bande_del_extension.svg" alt="Peu importe le nombre de broches, le nombre de pixels peut ainsi être augmenté" /></p>
<h3 id="bonnes-pratiques"><a class="header" href="#bonnes-pratiques">Bonnes pratiques</a></h3>
<p>Adafruit recommande les bonnes pratiques de connexion suivantes : <a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/best-practices">Best Practices | Adafruit NeoPixel Überguide | Adafruit Learning System</a>.</p>
<h2 id="bibliothèques"><a class="header" href="#bibliothèques">Bibliothèques</a></h2>
<p><strong>Les bibliothèques de DEL supportent souvent plusieurs modèles. On doit sélectionner le bon modèle dans le code!</strong> </p>
<p>Les deux bibliothèques les plus populaires sont:</p>
<ul>
<li><a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/the-magic-of-neopixels">Adafruit NeoPixel</a> : NeoPixel est plus simple à utiliser mais moins performante.</li>
<li><a href="https://github.com/FastLED/FastLED">FastLED</a> : FastLED est plus performante, mais plus compliquée à utiliser. Cette bibliothèque présente aussi les meilleurs exemples.</li>
</ul>
<h3 id="bibliothèque-adafruit-neopixel"><a class="header" href="#bibliothèque-adafruit-neopixel">Bibliothèque Adafruit NeoPixel</a></h3>
<p><img src="bande_del/./arduino_bibliotheque_installation_neopixel.svg" alt="Installation de la bibliothèque Adafruit NeoPixel" /></p>
<h3 id="bibliothèque-fastled"><a class="header" href="#bibliothèque-fastled">Bibliothèque FastLED</a></h3>
<p><img src="bande_del/./Diapositive6.SVG" alt="Installation de la bibliothèque FastLED et où trouver les exemples" /></p>
<p>Exemples intéressants à essayer:</p>
<ul>
<li>Cylon.</li>
<li>TwinkleFox.</li>
<li>Fire2021.</li>
<li>DemoReel100.</li>
</ul>
<p>Dans <strong>chaque</strong> exemple, on doit s'assurer que la configuration est adéquate : </p>
<ul>
<li>Que le DATA_PIN ou LED_PIN corresponde à la broche Arduino qui est connectée à la broche DI de la bande.</li>
<li>Que NUM_LEDS corresponde au nombre de DEL de la bande.</li>
<li>Que COLOR_ORDER corresponde à l’ordre des couleurs RGB.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pong-1d-pong-à-une-dimension"><a class="header" href="#pong-1d-pong-à-une-dimension">Pong 1D (Pong à une dimension)</a></h1>
<h2 id="quest-ce-que-le-pong-original"><a class="header" href="#quest-ce-que-le-pong-original">Qu'est-ce que le Pong original?</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=CKzWAxMfZRA">Data Driven Gamer: Pong (Atari, 1972 arcade, 60fps) - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=84Ymt9BAq5s">Atari Pong Table Electromechanical Game Debut @ IAAPA 2017 (Calinfer / UNIS) - YouTube</a></li>
<li><a href="https://www.youtube.com/watch?v=6bm7fLcj5UI">Let's Play - The PainStation - YouTube</a></li>
</ul>
<h2 id="recréer-pong-en-1d"><a class="header" href="#recréer-pong-en-1d">Recréer Pong en 1D</a></h2>
<p>Cet exemple est basé sur le projet <a href="https://create.arduino.cc/projecthub/mircemk/diy-arduino-1d-pong-game-with-ws2812-led-strip-a2418b">DIY Arduino 1D Pong Game with WS2812 LED Strip</a>. </p>
<p>Le code original a été écrit par B.Stultiens en 2015. La version présentée ici a été modifiée pour en régler des bogues, pour le mettre à jour et pour en retirer toute la partie audio. Une simulation du projet modifié peut être consultée en ligne ici : <a href="https://pi-pico.preview.wokwi.com/arduino/projects/345886566467502674">https://pi-pico.preview.wokwi.com/arduino/projects/345886566467502674</a></p>
<p>Le projet dépend de la bibliothèque <strong>Adafruit NeoPixel</strong> et nécessite:</p>
<ul>
<li>1 bande de DEL d'au moins 32 pixels</li>
<li>la bibliothèque NeoPixel pour contrôler la bande de DEL</li>
<li>2 interrupteurs pour démarrer et frapper la balle</li>
<li><em>Optionnel</em>: 2 autres interrupteurs qui peuvent être ajoutés pour permettre l'activation des bonus de jeu</li>
</ul>
<h3 id="le-circuit"><a class="header" href="#le-circuit">Le circuit</a></h3>
<p><img src="pong_1d/./pong_1d.svg" alt="Circuit minimal du Pong 1D" /></p>
<h3 id="le-code"><a class="header" href="#le-code">Le code</a></h3>
<p>Ne pas oublier de modifier la configuration matérielle pour qu'elle corresponde au circuit: </p>
<ul>
<li><strong>PIN_WSDATA</strong>: Le numéro de la broche Arduino reliée à la broche DI de la bande de DEL</li>
<li><strong>NPIXELS</strong>: Le nombre de pixels dans botre bande de DEL</li>
<li><strong>PIN_BUT_RS</strong>: Le numéro de la broche Arduino reliée au bouton de droite</li>
<li><strong>PIN_BUT_LS</strong>: Le numéro de la broche Arduino reliée au bouton de gauche</li>
<li><strong>ZONE_SIZE</strong>: La taille des buts</li>
<li><strong>TIME_SPEED_MIN</strong>: La vitesse de la balle</li>
</ul>
<pre><code class="language-arduino">/*
   Arduino 1D Pong Game with (60) WS2812B LEDs

   Copyright (C) 2015  B.Stultiens (modified by Thomas O Fredericks in 2022)

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope sthat it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
*/
#include &quot;Adafruit_NeoPixel.h&quot;

// HARDWARE CONFIGURATION
#define PIN_WSDATA		10		// LED strip data in pin
#define NPIXELS      64    // Number of pixels to handle

#define PIN_BUT_RS		3		// Right start/hit button pin
#define PIN_BUT_LS		2		// Left start/hit button pin

#define PIN_BUT_RP    4   // Optionnal right power-up button
#define PIN_BUT_LP    6   // Optionnal left power-up button

// BALL SPEED
#define TIME_SPEED_MIN    10

// ZONE AND WIN CONFIGURATION
#define ZONE_SIZE		7		// Bounce-back zone size
#define WIN_POINTS    10    // Points needed to win
#define SHOW_LO			12		// Score dots intensity background
#define SHOW_HI			48		// Score dots intensity foreground


#define NELEM(x)    (sizeof(x) / sizeof((x)[0]))

Adafruit_NeoPixel one_d = Adafruit_NeoPixel(NPIXELS, PIN_WSDATA, NEO_GRB | NEO_KHZ800);

// Events from buttons and timers
#define EV_BUT_LS_PRESS		0x01
#define EV_BUT_RS_PRESS		0x02
#define EV_BUT_LP_PRESS		0x04
#define EV_BUT_RP_PRESS		0x08
#define EV_TIMER		0x10
#define EV_TIMEOUT		0x20


#define TIME_DEBOUNCE		8
#define TIME_IDLE		40
#define TIME_START_TIMEOUT	20000		// Go idle if nothing happens
#define TIME_RESUME_TIMEOUT	7500		// Auto-fire after timeout
#define TIME_BALL_BLINK		150
#define TIME_SPEED_INTERVAL	3
#define TIME_POINT_BLINK	233
#define TIME_WIN_BLINK		85
#define TIME_LOCKOUT		250		// Prevent fast button-press to max. 4 times/s



enum {
  ST_IDLE = 0,
  ST_START_L,
  ST_START_R,
  ST_MOVE_LR,
  ST_MOVE_RL,
  ST_ZONE_L,
  ST_ZONE_R,
  ST_POINT_L,
  ST_POINT_R,
  ST_RESUME_L,
  ST_RESUME_R,
  ST_WIN_L,
  ST_WIN_R,
};

static uint32_t oldtime;	// Previous' loop millis() value
static uint8_t thestate;	// Game state

static uint8_t bstate_ls;	// Button states
static uint8_t bstate_rs;
static uint8_t bstate_lp;
static uint8_t bstate_rp;
static uint8_t debtmr_ls;	// Button debounce timers
static uint8_t debtmr_rs;
static uint8_t debtmr_lp;
static uint8_t debtmr_rp;
static uint16_t timer;		// General timer
static uint16_t timeout;	// Timeout timer (auto-start and goto idle)

static uint16_t lockout_l;	// Lockout timer to prevent pushing too often
static uint16_t lockout_r;
static uint8_t ballblinkstate;	// Blinking ball at edge on/off
static uint8_t pointblinkcount;	// Blinking point when a side scores
static uint8_t ballpos;		// Current position of the ball
static uint16_t speed;		// Time between ball moves
static uint8_t speedup;		// Faster and faster replies counter
static uint8_t points_l;	// Score
static uint8_t points_r;
static uint8_t zone_l;		// Hit back zone
static uint8_t zone_r;
static uint8_t boost_l;		// Set if user boosted speed last round
static uint8_t boost_r;
static uint8_t boosted;		// Set if any user boosted until the ball reaches opposite side

static uint8_t tuneidx;		// Index to the running tune

/*
   Return the current state of a button.
   Returns non-zero on button pressed.
*/
static inline uint8_t button_is_down(uint8_t pin)
{
  switch (pin) {
    case PIN_BUT_LS:	return !debtmr_ls &amp;&amp; !bstate_ls;
    case PIN_BUT_RS:	return !debtmr_rs &amp;&amp; !bstate_rs;
    case PIN_BUT_LP:	return !debtmr_lp &amp;&amp; !bstate_lp;
    case PIN_BUT_RP:	return !debtmr_rp &amp;&amp; !bstate_rp;
  }
  return 0;
}

/*
   Debounce a button and return an event at the rising edge of the detection.
   The rising edge ensures that there is no delay from pressing the button and
   the event propagating. It is a prerequisite that the input line is not
   glitchy.
   A release event may be generated if the routine is slightly modified.
*/
static inline uint8_t do_debounce(uint8_t tdiff, uint8_t *bstate, uint8_t *debtmr, uint8_t pin, uint8_t ev)
{
  if (0 == *debtmr) {
    uint8_t state = digitalRead(pin);
    if (state != *bstate) {
      *debtmr = TIME_DEBOUNCE;
      if (!(*bstate = state))
        return ev;	// Event on High-to-Low transition of input
      // else
      //  return release_event_value
    }
  } else {
    if (*debtmr &gt;= tdiff)
      *debtmr -= tdiff;
    else
      *debtmr = 0;
  }
  return 0;
}

/*
   Timer countdown and return an event on timer reaching zero.
*/
static inline uint8_t do_timer(uint8_t tdiff, uint16_t *tmr, uint8_t ev)
{
  if (0 != *tmr) {
    if (*tmr &gt;= tdiff)
      *tmr -= tdiff;	// Timer countdown
    else
      *tmr = 0;
    // Set event when done counting
    if (0 == *tmr)
      return ev;
  }
  return 0;
}


/*
   Draw the left and right zones where the ball may be hit back.
*/
static void draw_sides()
{
  for (uint8_t i = 0; i &lt; zone_l - 1; i++) {
    one_d.setPixelColor(i, 0, 64, 64);
  }
  one_d.setPixelColor(0, 0, 64, 64);
  for (uint8_t i = 0; i &lt; zone_r - 1; i++) {
    one_d.setPixelColor(NPIXELS - 1 - i, 0, 64, 64);
  }
  one_d.setPixelColor(NPIXELS - 1, 0, 64, 64);
}

/*
   Draw the ball with a tail of five pixels in diminishing intensity.
*/
static void draw_ball(int8_t dir, uint8_t pos)
{
  uint8_t c = 255;
  for (uint8_t i = 0; i &lt; 5 &amp;&amp; pos &gt;= 0 &amp;&amp; pos &lt; NPIXELS; i++) {
    one_d.setPixelColor(pos, c, c, 0);
    c &gt;&gt;= 1;
    pos -= dir;
  }
}

/*
   Draw the playing field consisting of the zones and the points scored so far.
*/
static void draw_course(uint8_t v)
{
  one_d.clear();
  draw_sides();
  if (v) {
    for (uint8_t i = 0; i &lt; points_l; i++) {
      one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * i + 0), v, 0, 0);
      one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * i + 1), v, 0, 0);
    }
    for (uint8_t i = 0; i &lt; points_r; i++) {
      one_d.setPixelColor(NPIXELS / 2 + (2 * i + 0), 0, v, 0);
      one_d.setPixelColor(NPIXELS / 2 + (2 * i + 1), 0, v, 0);
    }
  }
}

/*
   Animate the game idle situation with following content:
   - A rainbow pattern
   - Ball bouncing left-right-left-right
   - Score animation
*/
static uint16_t ai_h;
static uint8_t ai_state;
static uint8_t ai_pos;

static void animate_idle_init(void)
{
  ai_h = 0;
  ai_state = 0;
}

#define H_STEPS	1542

static void animate_idle(void)
{
  switch (ai_state) {
    case 0:
    case 1:
    case 2:
    case 3:
      /* Rainbow pattern */
      for (uint8_t i = 0; i &lt; NPIXELS; i++) {
        uint16_t h = ai_h + (i &lt;&lt; 4);
        if (h &gt;= H_STEPS)
          h -= H_STEPS;
        uint32_t rgbcolor = one_d.ColorHSV(h, 255, 128);
        one_d.setPixelColor(i, rgbcolor);
      }
      ai_h += H_STEPS / 60;
      if (ai_h &gt;= H_STEPS) {
        ai_h -= H_STEPS;
        ai_pos = 0;
        ai_state++;
      }
      break;
    case 4:
    case 6:
      /* Ball left-to-right */
      draw_course(0);
      draw_ball(1, ai_pos++);
      if (ai_pos &gt;= NPIXELS) {
        ai_state++;
      }
      break;
    case 5:
    case 7:
      /* Ball right-to-left */
      draw_course(0);
      draw_ball(-1, --ai_pos);
      if (!ai_pos) {
        ai_state++;
      }
      break;
    case 8:
    case 10:
      /* Score blinkenlights */
      draw_course(0);
      for (uint8_t i = 0; i &lt; ai_pos; i++) {
        one_d.setPixelColor(NPIXELS / 2 - 1 - i, 255, 0, 0);
        one_d.setPixelColor(NPIXELS / 2 + i, 0, 255, 0);
      }
      if (++ai_pos &gt;= NPIXELS / 2) {
        ai_state++;
        ai_pos = 0;
      }
      break;

    case 9:
    case 11:
      draw_course(0);
      for (uint8_t i = 0; i &lt; NPIXELS / 2 - ai_pos; i++) {
        one_d.setPixelColor(NPIXELS / 2 - 1 - i, 255, 0, 0);
        one_d.setPixelColor(NPIXELS / 2 + i, 0, 255, 0);
      }
      if (++ai_pos &gt;= NPIXELS / 2) {
        ai_state++;
        ai_pos = 0;
      }
      break;

    default:
      ai_state = 0;
      break;
  }
  one_d.show();
}

/*
   Animate a winner. Flash the winning side's points.
*/
static uint8_t aw_state;
static void animate_win_init()
{
  aw_state = 0;
}

static uint8_t animate_win(uint8_t side)
{
  uint32_t clr;
  uint8_t pos;

  if (side) {
    clr = Adafruit_NeoPixel::Color(0, 255, 0);
    pos = NPIXELS / 2;
  } else {
    clr = Adafruit_NeoPixel::Color(255, 0, 0);
    pos = 0;
  }

  one_d.clear();
  if (aw_state &lt; 20) {
    if (aw_state &amp; 0x01) {
      for (uint8_t i = 0; i &lt; NPIXELS / 2; i++) {
        one_d.setPixelColor(pos + i, clr);
      }
    }
  } else if (aw_state &lt; 50) {
    for (uint8_t i = 0; i &lt; aw_state - 20; i++) {
      one_d.setPixelColor(pos + i, clr);
    }
  } else if (aw_state &lt; 80) {
    for (uint8_t i = aw_state - 50; i &lt; NPIXELS / 2; i++) {
      one_d.setPixelColor(pos + i, clr);
    }
  } else if (aw_state &lt; 110) {
    for (uint8_t i = 0; i &lt; aw_state - 80; i++) {
      one_d.setPixelColor(NPIXELS / 2 - 1 - i + pos, clr);
    }
  } else if (aw_state &lt; 140) {
    for (uint8_t i = aw_state - 110; i &lt; NPIXELS / 2; i++) {
      one_d.setPixelColor(NPIXELS / 2 - 1 - i + pos, clr);
    }
  }
  one_d.show();
  return ++aw_state &lt; 140;
}

/*
   Active game states suppress fast button pushes
*/
static uint8_t is_game_state(uint8_t s)
{
  switch (s) {
    case ST_MOVE_LR:	// If you press too soon
    case ST_MOVE_RL:
    case ST_ZONE_R:		// In the zone
    case ST_ZONE_L:
    case ST_POINT_L:	// Just got a point, delay resume
    case ST_POINT_R:
    case ST_WIN_R:		// Delay to activate the win sequence
    case ST_WIN_L:
      return 1;
    default:
      return 0;
  }
}

/*
   Set the timer to the speed of the ball and the current boost-state
*/
static inline void speed_to_timer()
{
  if (boosted)
    timer = speed * 3 / 4;
  else
    timer = speed;
  if (timer &lt; 2)
    timer = 2;
}

/*
   State transition routine. Setup prerequisites for the new state to function
   properly.
   - Handle a state's exit actions
   - Handle a state's entry actions
*/
static void set_state(uint8_t newstate)
{
  /* State exit actions */
  switch (thestate) {
    case ST_IDLE:
    case ST_WIN_L:
    case ST_WIN_R:
      points_l = points_r = 0;
      boost_l = boost_r = 0;
      zone_l = zone_r = ZONE_SIZE;
      speedup = 0;
      boosted = 0;
      break;

    case ST_START_L:
    case ST_POINT_L:
    case ST_RESUME_L:
      ballpos = 0;
      /* Serve speed not too fast */
      speed = TIME_SPEED_MIN + 5 * TIME_SPEED_INTERVAL;
      speedup = 0;
      break;

    case ST_START_R:
    case ST_POINT_R:
    case ST_RESUME_R:
      ballpos = NPIXELS - 1;
      /* Serve speed not too fast */
      speed = TIME_SPEED_MIN + 5 * TIME_SPEED_INTERVAL;
      speedup = 0;
      break;

    case ST_ZONE_L:
      /* Calculate the speed for the return */
      speed = TIME_SPEED_MIN + TIME_SPEED_INTERVAL * ballpos;
      if (++speedup / 2 &gt;= speed)
        speed = 2;
      else
        speed -= speedup / 2;
      boosted = 0;
      break;

    case ST_ZONE_R:
      /* Calculate the speed for the return */
      speed = TIME_SPEED_MIN + TIME_SPEED_INTERVAL * (NPIXELS - 1 - ballpos);
      if (++speedup / 2 &gt;= speed)
        speed = 2;
      else
        speed -= speedup / 2;
      boosted = 0;
      break;
  }

  thestate = newstate;
  /* State entry actions */
  switch (thestate) {
    case ST_IDLE:
      boost_l = boost_r = 0;
      zone_l = zone_r = ZONE_SIZE;
      animate_idle_init();
      timer = TIME_IDLE;
      break;

    case ST_START_L:
    case ST_START_R:
      draw_course(SHOW_HI);
      one_d.show();
      timer = TIME_BALL_BLINK;
      timeout = TIME_START_TIMEOUT;
      ballblinkstate = 0;
      ballpos = thestate == ST_START_L ? 0 : NPIXELS - 1;
      break;

    case ST_MOVE_LR:
    case ST_MOVE_RL:
      speed_to_timer();
      break;

    case ST_POINT_L:
    case ST_POINT_R:
      pointblinkcount = 7;
      /* Recover the zone next round */
      if (!boost_l &amp;&amp; zone_l &lt; ZONE_SIZE)
        zone_l++;
      if (!boost_r &amp;&amp; zone_r &lt; ZONE_SIZE)
        zone_r++;
      timer = TIME_POINT_BLINK;
      if (boost_l)
        boost_l--;
      if (boost_r)
        boost_r--;
      // Ensure we get to the score display before continuing
      lockout_l  = lockout_r = TIME_LOCKOUT;
      break;

    case ST_RESUME_L:
    case ST_RESUME_R:
      draw_course(SHOW_HI);
      one_d.show();
      timer = TIME_BALL_BLINK;
      timeout = TIME_RESUME_TIMEOUT;
      ballblinkstate = 0;
      break;

    case ST_WIN_L:
    case ST_WIN_R:
      // Ensure we get to the winner display before continuing
      lockout_l  = lockout_r = 2 * TIME_LOCKOUT;
      animate_win_init();
      timer = TIME_WIN_BLINK;
      tuneidx = 0;
      break;
  }
}

/*
   Arduino setup
*/
void setup()
{
  PORTB = PORTC = PORTD = 0xff;	// Enable all pull-ups so we don't have undef inputs hanging

  pinMode(PIN_BUT_LS, INPUT_PULLUP);
  pinMode(PIN_BUT_RS, INPUT_PULLUP);
  pinMode(PIN_BUT_LP, INPUT_PULLUP);
  pinMode(PIN_BUT_RP, INPUT_PULLUP);


  one_d.begin();		// Setup IO
  one_d.show();		// All leds off

  thestate = ST_IDLE;
  set_state(ST_IDLE);	// To run both exit and entry actions

  /*
     Setup sound hardware with Timer1 manually. The disabled interrupts
     in the pixel-update causes interference in the timing resulting in
     clicks in the sound output.
  */
  TCCR1A = 0;
  TCCR1B = _BV(WGM12) | _BV(CS10);
  OCR1A = 13;	// Just a value
  TCNT1 = 0;
}

/*
   Main program, called constantly and forever.

   - Handle timing and generate events
   - Run the game's state machine
*/
#define chk_ev(ev)	(events &amp; (ev))

void loop()
{
  uint32_t now;
  uint8_t tdiff = (now = millis()) - oldtime;
  uint8_t events = 0;

  /* Handle buttons and timers on (just about) every millisecond */
  if (tdiff) {
    oldtime = now;
    events |= do_debounce(tdiff, &amp;bstate_ls, &amp;debtmr_ls, PIN_BUT_LS, EV_BUT_LS_PRESS);
    events |= do_debounce(tdiff, &amp;bstate_rs, &amp;debtmr_rs, PIN_BUT_RS, EV_BUT_RS_PRESS);
    events |= do_debounce(tdiff, &amp;bstate_lp, &amp;debtmr_lp, PIN_BUT_LP, EV_BUT_LP_PRESS);
    events |= do_debounce(tdiff, &amp;bstate_rp, &amp;debtmr_rp, PIN_BUT_RP, EV_BUT_RP_PRESS);
    events |= do_timer(tdiff, &amp;timer, EV_TIMER);
    events |= do_timer(tdiff, &amp;timeout, EV_TIMEOUT);
    do_timer(tdiff, &amp;lockout_l, 0);
    do_timer(tdiff, &amp;lockout_r, 0);
  }

  if (is_game_state(thestate)) {
    // If the lockout timer is running, squash the button event
    if (lockout_l)
      events &amp;= ~EV_BUT_LS_PRESS;
    if (lockout_r)
      events &amp;= ~EV_BUT_RS_PRESS;
  }

  // A button press activates the lockout timer
  if (chk_ev(EV_BUT_LS_PRESS))
    lockout_l = TIME_LOCKOUT;
  if (chk_ev(EV_BUT_RS_PRESS))
    lockout_r = TIME_LOCKOUT;

  switch (thestate) {
    // Nothing to do
    case ST_IDLE:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_START_L);
      } else if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_START_R);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_IDLE;
        animate_idle();
      }
      break;

    // Game is started, waiting for left player to serve the ball
    case ST_START_L:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_MOVE_LR);
      } else if (chk_ev(EV_TIMEOUT)) {
        set_state(ST_IDLE);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // Game is started, waiting for right player to serve the ball
    case ST_START_R:
      if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_MOVE_RL);
      } else if (chk_ev(EV_TIMEOUT)) {
        set_state(ST_IDLE);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // Ball is moving left-to-right outside the playback zone
    case ST_MOVE_LR:
      if (chk_ev(EV_TIMER)) {

        speed_to_timer();
        draw_course(SHOW_LO);
        draw_ball(1, ballpos);
        one_d.show();
        ballpos++;
        if (NPIXELS - 1 - ballpos &lt;= zone_r)
          set_state(ST_ZONE_R);
      }
      break;

    // Ball is moving right-to-left outside the playback zone
    case ST_MOVE_RL:
      if (chk_ev(EV_TIMER)) {

        speed_to_timer();
        draw_course(SHOW_LO);
        draw_ball(-1, ballpos);
        one_d.show();
        ballpos--;
        if (ballpos &lt;= zone_l)
          set_state(ST_ZONE_L);
      }
      break;

    // Ball is in the left playback zone, waiting for hit/score
    case ST_ZONE_L:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_MOVE_LR);
        // Changing speed is done after the state-change's exit/entry action
        if (zone_l &gt; 1 &amp;&amp; button_is_down(PIN_BUT_LP)) {
          zone_l--;
          boosted = 1;
          speed_to_timer();
          boost_l++;
        }
      } else if (chk_ev(EV_TIMER)) {
        if (!ballpos) {
          if (++points_r &gt;= WIN_POINTS)
            set_state(ST_WIN_R);
          else
            set_state(ST_POINT_R);
        } else {
          speed_to_timer();
          ballpos--;
        }
        draw_course(SHOW_LO);
        draw_ball(-1, ballpos);
        one_d.show();
      }
      break;

    // Ball is in the right playback zone, waiting for hit/score
    case ST_ZONE_R:
      if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_MOVE_RL);
        // Changing speed is done after the state-change's exit/entry action
        if (zone_r &gt; 1 &amp;&amp; button_is_down(PIN_BUT_RP)) {
          zone_r--;
          speed_to_timer();
          boosted = 1;
          boost_r++;
        }
      } else if (chk_ev(EV_TIMER)) {
        if (ballpos == NPIXELS - 1) {

          if (++points_l &gt;= WIN_POINTS)
            set_state(ST_WIN_L);
          else
            set_state(ST_POINT_L);
        } else {
          speed_to_timer();
          ballpos++;
        }
        draw_course(SHOW_LO);
        draw_ball(1, ballpos);
        one_d.show();
      }
      break;

    // Left player scored, animate point
    case ST_POINT_L:
      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_RESUME_L);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_POINT_BLINK;
        draw_course(SHOW_HI);
        if (!(pointblinkcount &amp; 0x01)) {
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 0), 0, 0, 0);
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 1), 0, 0, 0);
        } else {
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 0), 255, 0, 0);
          one_d.setPixelColor(NPIXELS / 2 - 1 - (2 * (points_l - 1) + 1), 255, 0, 0);
        }
        one_d.show();
        if (!--pointblinkcount)
          set_state(ST_RESUME_L);
      }
      break;

    // Right player scored, animate point
    case ST_POINT_R:
      if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_RESUME_R);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_POINT_BLINK;
        draw_course(SHOW_HI);
        if (!(pointblinkcount &amp; 0x01)) {
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 0), 0, 0, 0);
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 1), 0, 0, 0);
        } else {
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 0), 0, 255, 0);
          one_d.setPixelColor(NPIXELS / 2 + (2 * (points_r - 1) + 1), 0, 255, 0);
        }
        one_d.show();
        if (!--pointblinkcount)
          set_state(ST_RESUME_R);
      }
      break;

    // Left player previously scored and must serve again (or timeout to auto-serve)
    case ST_RESUME_L:
      if (chk_ev(EV_BUT_LS_PRESS | EV_TIMEOUT)) {
        set_state(ST_MOVE_LR);

      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // Right player previously scored and must serve again (or timeout to auto-serve)
    case ST_RESUME_R:
      if (chk_ev(EV_BUT_RS_PRESS | EV_TIMEOUT)) {
        set_state(ST_MOVE_RL);

      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_BALL_BLINK;
        if (ballblinkstate)
          one_d.setPixelColor(ballpos, 255, 128, 0);
        else
          one_d.setPixelColor(ballpos, 0, 0, 0);
        one_d.show();
        ballblinkstate = !ballblinkstate;
      }
      break;

    // A player won the game, animate the winning side
    case ST_WIN_L:
    case ST_WIN_R:

      if (chk_ev(EV_BUT_LS_PRESS)) {
        set_state(ST_START_L);
      } else if (chk_ev(EV_BUT_RS_PRESS)) {
        set_state(ST_START_R);
      } else if (chk_ev(EV_TIMER)) {
        timer = TIME_WIN_BLINK;
        if (!animate_win(thestate == ST_WIN_R))
          set_state(ST_IDLE);
      }
      break;

    // If we get confused, start at idle...
    default:
      set_state(ST_IDLE);
      break;
  }



}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contrôler-une-bande-de-del-par-osc"><a class="header" href="#contrôler-une-bande-de-del-par-osc">Contrôler une bande de DEL par OSC</a></h1>
<h2 id="préalables-2"><a class="header" href="#préalables-2">Préalables</a></h2>
<ul>
<li>Alimentation d'une bande de DEL (30 pixels) avec la broche <em>Data Input(DI)</em> branchée à la broche 4 de l'Arduino; voir la section <a href="bande_del_osc/../bande_del/bande_del.html">Bande de DEL</a>.</li>
<li>Installation de la bibliothèque de contrôle de DEL : Adafruit NeoPixel.</li>
<li>Installation de la bibliothèque de communication : MicroOsc.</li>
</ul>
<h2 id="arduino--code"><a class="header" href="#arduino--code">Arduino : code</a></h2>
<pre><code class="language-Arduino">// MicroOsc_NeoPixel_SLIP
// by Thomas O Fredericks
// 2022-11-09

// HARDWARE REQUIREMENTS
// ==================
// NeoPixel LED strip connected to pin 4

// REQUIRED LIBRARIES
// ==================
// MicroOsc
// Adafruit NeoPixel

// REQUIRED CONFIGURATION
// ======================
// Set Serial baud to 115200


#include &lt;MicroOscSlip.h&gt;
// The number 128 between the &lt; &gt; below  is the maximum number of bytes reserved for incomming messages.
// If you want to control 30 RGB NeoPixels, you need at least 90 bytes for the data (1 byte per color). We are reserving a little more (128 bytes) just in case.
// Outgoing messages are written directly to the output and do not need more reserved bytes.
MicroOscSlip&lt;128&gt; myMicroOsc(&amp;Serial);

#include &lt;Adafruit_NeoPixel.h&gt;  
const int myPixelCount = 30;
const int myPixelPin = 4;
Adafruit_NeoPixel myPixelStrip(myPixelCount, myPixelPin , NEO_RGB + NEO_KHZ800);

void setup() {
  // INITIATE SERIAL COMMUNICATION
  Serial.begin(115200);                                         
  // INITIALIZE PIXEL STRIP
  myPixelStrip.begin(); 
  // STARTUP ANIMATION
  // LIGHT ALL PIXELS IN WHITE THEN TURN THEM ALL OFF
  for ( int i=0; i &lt; myPixelCount; i++ ) {
     myPixelStrip.setPixelColor(i, myPixelStrip.Color(255, 255 , 255));  
     myPixelStrip.show();
     delay(100);                                       
  }
  delay(1000);
  myPixelStrip.clear();
  myPixelStrip.show();
}

// FUNCTION THAT IS CALLED FOR EVERY RECEIVED OSC MESSAGE
void myOnReceiveMessage( MicroOscMessage&amp; receivedOscMessage ) {
  // IF THE ADDRESS IS /rgb
  if ( receivedOscMessage.fullMatch(&quot;/rgb&quot;) ) {   
                 
    // CREATE A VARIABLE TO STORE THE POINTER TO THE DATA
    const uint8_t* blobData;                                    
    // GET THE DATA SIZE AND THE POINTER TO THE DATA
    int blobSize = receivedOscMessage.nextAsBlob(&amp;blobData);    
    // IF DATA SIZE IS LARGER THAN 0 AND IS A MULTIPLE OF 3 AS REQUIRED BY RGB PIXELS
    if ( blobSize &gt; 0 &amp;&amp; blobSize % 3 == 0 ) {                  
      // DIVIDE THE DATA BY 3 TO GET THE NUMBER OF PIXELS
      int blobPixelCount = blobSize / 3;                        
      // ITERATE THROUGH EACH PIXEL IN THE BLOB 
      for ( int i = 0 ; i &lt; blobPixelCount ; i++ ) {            
        // EACH PIXEL HAS 3 BYTES, SO WE GO THROUGH THE DATA, 3 AT A TIME
        int blobIndex = i * 3; 
        uint8_t red =  myPixelStrip.gamma8(blobData[blobIndex]);
        uint8_t green =  myPixelStrip.gamma8(blobData[blobIndex+1]); 
        uint8_t blue =  myPixelStrip.gamma8(blobData[blobIndex+2]);                            
        myPixelStrip.setPixelColor(i, myPixelStrip.Color(red , green , blue));
      }
      myPixelStrip.show();
    }
  }
}

void loop() {
  myMicroOsc.receiveMessages( myOnReceiveMessage );
}
</code></pre>
<h2 id="contrôle-danimation-de-la-band-de-del"><a class="header" href="#contrôle-danimation-de-la-band-de-del">Contrôle d'animation de la band de DEL</a></h2>
<h3 id="À-partir-dune-image-matrice-générative-dans-max"><a class="header" href="#À-partir-dune-image-matrice-générative-dans-max">À partir d'une image (matrice) générative dans Max</a></h3>
<p><a href="bande_del_osc/./MicroOsc_NeoPixel_Slip.maxpat"><img src="bande_del_osc/./MicroOsc_NeoPixel_Slip.png" alt="Cliquer pour télécharger le patcher MicroOsc_NeoPixel_Slip.maxpat" /></a></p>
<h3 id="À-partir-de-la-conversion-brute-du-signal-audio-dans-max"><a class="header" href="#À-partir-de-la-conversion-brute-du-signal-audio-dans-max">À partir de la conversion brute du signal audio dans Max</a></h3>
<p><a href="bande_del_osc/./MicroOsc_NeoPixel_Audio_Slip.maxpat"><img src="bande_del_osc/./MicroOsc_NeoPixel_Audio_Slip.png" alt="Cliquer pour télécharger le patcher MicroOsc_NeoPixel_Audio_Slip.maxpat" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="raspberry-pi"><a class="header" href="#raspberry-pi">Raspberry Pi</a></h1>
<h2 id="scénario-distant"><a class="header" href="#scénario-distant">Scénario distant</a></h2>
<p><img src="raspberry_pi/./scenario_distant.svg" alt="Utilisation d'un Raspberry Pi pour le relais de messages OSC locaux à distance" /></p>
<h2 id="installation-de-raspberry-pi-os"><a class="header" href="#installation-de-raspberry-pi-os">Installation de Raspberry Pi OS</a></h2>
<p>Le système d'exploitation choisi pour le Raspberry Pi est le <a href="https://fr.wikipedia.org/wiki/Raspberry_Pi_OS">Raspberry Pi OS</a>.</p>
<h3 id="32-bits-vs-64-bits"><a class="header" href="#32-bits-vs-64-bits">32 bits vs 64 bits</a></h3>
<p><strong>La distribution 32 bits est a favorisée</strong> ; au temps d'écrire (janvier 2023), l'accélération matérielle du décodage caméra n'était pas encore active sur la mouture 64 bit.</p>
<h3 id="installer-raspberry-pi-os-sur-une-carte-micro-sd"><a class="header" href="#installer-raspberry-pi-os-sur-une-carte-micro-sd">Installer Raspberry Pi OS sur une carte micro SD</a></h3>
<h4 id="utiliser-raspberry-pi-imager"><a class="header" href="#utiliser-raspberry-pi-imager">Utiliser Raspberry Pi Imager</a></h4>
<p>Le logiciel <a href="https://www.raspberrypi.com/software/">Raspberry Pi Imager</a> permet d'installer facilement Raspberry Pi OS :</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ntaXWS8Lk34">Vidéo survolant Raspberry Pi Imager </a>.</li>
<li><a href="https://www.raspberrypi.com/documentation/computers/getting-started.html">Documentation officielle pour bien démarrer</a>.</li>
</ul>
<h3 id="raspi-config"><a class="header" href="#raspi-config">Raspi-config</a></h3>
<p>Une fois que le système sur le Raspberry Pi s'est initialisé, lancer un terminal et exécuter la commande suivante</p>
<p>Via <a href="https://www.raspberrypi.com/documentation/computers/configuration.html#the-raspi-config-tool">raspi-config</a></p>
<pre><code>sudo raspi-config
</code></pre>
<h4 id="hostname"><a class="header" href="#hostname">Hostname</a></h4>
<p>Il est préférable de configurer le <em>hostname</em>. Par exemple :  <code>tim-rpi-x</code> où <code>x</code> devient est le chiffre d'une séquence. Cela permet d'avoir plusieurs Raspberry Pi facilement reconnaissables.</p>
<h4 id="interface-option"><a class="header" href="#interface-option">Interface option</a></h4>
<ul>
<li>IP : <a href="https://www.raspberrypi.com/documentation/computers/remote-access.html#introduction-to-remote-access">Raspberry Pi Documentation - Remote access</a>.</li>
<li>SSH : <a href="https://www.raspberrypi.com/documentation/computers/remote-access.html#setting-up-an-ssh-server">Raspberry Pi Documentation - Setting up and SSH Server</a>.</li>
<li>VNC : <a href="https://www.raspberrypi.com/documentation/computers/remote-access.html#virtual-network-computing-vnc">Raspberry Pi Documentation - Virtual Network Computing (VNC)</a>.</li>
</ul>
<h3 id="partage-de-fichier-réseau"><a class="header" href="#partage-de-fichier-réseau">Partage de fichier réseau</a></h3>
<ul>
<li>Samba : <a href="https://www.raspberrypi.com/documentation/computers/remote-access.html#samba-smbcifs">Raspberry Pi Documentation - Samba (SMB/CIFS)</a>.</li>
</ul>
<pre><code>sudo apt-get update 
sudo apt-get install samba samba-common-bin
sudo smbpasswd -a tim
sudo service smbd restart
</code></pre>
<pre><code>micro /etc/samba/smb.conf 
</code></pre>
<p>Modifier le document vers la ligne ~176 :</p>
<pre><code class="language-diff">- read only = yes
+ read only = no
</code></pre>
<h3 id="affichage-réseau-ssh"><a class="header" href="#affichage-réseau-ssh">Affichage réseau SSH</a></h3>
<h4 id="avahi-ssh"><a class="header" href="#avahi-ssh">Avahi ssh</a></h4>
<pre><code>sudo su
curl https://raw.githubusercontent.com/lathiat/avahi/master/avahi-daemon/ssh.service &gt; /etc/avahi/services/ssh.service
exit
sudo systemctl restart avahi-daemon.service 
</code></pre>
<h3 id="clef-ssh"><a class="header" href="#clef-ssh">Clef SSH</a></h3>
<p>Si besoin </p>
<pre><code>ssh-keygen -t rsa -b 2048 -C $HOSTNAME
</code></pre>
<h2 id="applications-pour-lélectronique"><a class="header" href="#applications-pour-lélectronique">Applications pour l'électronique</a></h2>
<h3 id="arduino-legacy-ide-18x"><a class="header" href="#arduino-legacy-ide-18x">Arduino Legacy IDE (1.8.X)</a></h3>
<p>La version qui est disponible via le gestionnaire de paquet est désuète. </p>
<ul>
<li>Télécharger et installer la plus récente version de la série Legacy IDE (1.8.X) sur le site suivant <a href="https://www.arduino.cc/en/software">https://www.arduino.cc/en/software</a>.</li>
<li>Sélectionner <strong>Linux ARM 32 bits</strong> : <a href="https://downloads.arduino.cc/arduino-1.8.19-linux32.tar.xz">https://downloads.arduino.cc/arduino-1.8.19-linux32.tar.xz</a>.</li>
<li>Décompresser le fichier <code>tar.xz</code></li>
<li>Exécuter le fichier <code>install.sh</code></li>
<li>Lancer l'application via l'icône générée dans la barre de menu</li>
</ul>
<h2 id="applications-pour-la-programmation"><a class="header" href="#applications-pour-la-programmation">Applications pour la programmation</a></h2>
<h3 id="pure-data"><a class="header" href="#pure-data">Pure Data</a></h3>
<p>La version de <a href="http://msp.ucsd.edu/software.html">Pure Data</a> qui est disponible via le gestionnaire de paquet de Raspberry Pi OS est désuète. Il faut compiler Pure Data depuis la source.</p>
<h4 id="compiler-pure-data-depuis-la-source"><a class="header" href="#compiler-pure-data-depuis-la-source">Compiler Pure Data depuis la source</a></h4>
<ul>
<li>Lancer les commandes suivantes depuis un terminal </li>
</ul>
<pre><code>sudo apt-get install autoconf libtool libasound2-dev build-essential autoconf automake libtool gettext git libasound2-dev libjack-jackd2-dev libfftw3-3 libfftw3-dev tcl tk 
mkdir ~/src
cd ~/src
git clone https://github.com/pure-data/pure-data
cd pure-data
./autogen.sh
./configure --enable-jack --enable-fftw
make -j4
sudo make install
</code></pre>
<h3 id="plugdata"><a class="header" href="#plugdata">PlugData</a></h3>
<p><a href="https://plugdata.org/">PlugData</a> n'est pas disponible via le gestionnaire de paquets par défaut. Il faut l'ajouter au gestionnaire de paquets.</p>
<h4 id="ajouter-plugdata-au-gestionnaire-de-paquets"><a class="header" href="#ajouter-plugdata-au-gestionnaire-de-paquets">Ajouter plugdata au gestionnaire de paquets</a></h4>
<pre><code>echo 'deb http://download.opensuse.org/repositories/home:/plugdata/Debian_11/ /' | sudo tee /etc/apt/sources.list.d/home:plugdata.list
curl -fsSL https://download.opensuse.org/repositories/home:plugdata/Debian_11/Release.key | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/home_plugdata.gpg &gt; /dev/null
sudo apt update
sudo apt install plugdata
</code></pre>
<h2 id="applications-pour-laudio"><a class="header" href="#applications-pour-laudio">Applications pour l'audio</a></h2>
<h3 id="reaper"><a class="header" href="#reaper">Reaper</a></h3>
<p>Reaper est un DAW.</p>
<ul>
<li>Télécharger la version la plus récente pour l'architecture <code>Linux armv7l</code> sur le site <a href="https://www.reaper.fm/download.php">REAPER | Download</a></li>
<li>Décompresser </li>
<li>Executer install-reaper.sh depuis le terminal</li>
<li>Lancer l'application via l'icône générée dans la barre de menu</li>
</ul>
<h3 id="cardinal"><a class="header" href="#cardinal">Cardinal</a></h3>
<p>Cardinal est une version libre de VCV Rack.</p>
<ul>
<li>Télécharger la version <code>armhf</code> la plus récente depuis <a href="https://github.com/DISTRHO/Cardinal/releases">Releases · DISTRHO/Cardinal</a></li>
<li>Décompresser le fichier <code>tar.gz</code></li>
<li>Exécuter <code>CardinalNative</code> pour lancer l'application</li>
<li>Configurer les DAW vers le dossier de Cardinal pour indexer Cardinal comme effet (VST, VST3, LV2, CLAP)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
         <script type="text/javascript">
              // LIGHT BOX FOR VIDEOS
              // https://github.com/biati-digital/glightbox
              const main = document.getElementsByTagName('main')[0];
              var collectionOrNodes = main.getElementsByTagName('a');
              var a = Array.prototype.slice.call( collectionOrNodes );
              //console.log("Elements in main: "+a.length);
              a.forEach(function(currentElement){ 
                
                if ( currentElement.href.includes("youtube.com") || currentElement.href.includes("vimeo.com" ) ) {
                    currentElement.classList.add("glightboxed")
                }
                
                 });


                    var lightbox = GLightbox({
                        selector: '.glightboxed',
                        touchNavigation: true,
                        loop: false,
                        autoplayVideos: false,
                    });
                    lightbox.on('open', (target) => {
                        console.log('lightbox opened');
                    });
          </script>

          <script type="text/javascript">
              function altTextToImageCaption() {
                  let imgs = document.getElementsByTagName('img');
                  for (var i = 0; i < imgs.length; i++) {
      
                    var att = imgs[i].attributes.getNamedItem('alt');
                    if (!att) continue;
                    var alt = att.value;
                    if (!alt) continue;
                    //if (!alt.startsWith('Fig ')) continue;
                    var cap = document.createElement('div');
                    cap.setAttribute('class', 'imageCaption');
                    cap.appendChild(document.createTextNode(alt));
                    //imgs[i].parentNode.insertBefore(cap, imgs[i].nextSibling);
                    let containerDiv =  document.createElement('div');
                    //containerDiv.style.backgroundColor ='white';
                    //containerDiv.style.justifyContent = 'center';
                     //containerDiv.style.display = 'inline';
                    containerDiv.style.textAlign = 'center';
                    imgs[i].parentNode.appendChild(containerDiv);
                    containerDiv.appendChild(imgs[i]);
                    containerDiv.appendChild(cap);

                  }
                }
                altTextToImageCaption();

                function externalLinksOpenBlank() {
                    var anchorEls = document.querySelectorAll('a');
                    var anchorElsLength = anchorEls.length;

                    for (var i = 0; i < anchorElsLength; i++) {
                        var anchorEl = anchorEls[i];
                        var href = anchorEl.getAttribute('href');

                        if (href.startsWith("http",0)) {
                          anchorEl.setAttribute('target', '_blank');
                        }
                    }
                }
                externalLinksOpenBlank();

                function buildToc() {
                    
                    let tagetList = document.getElementsByTagName("h1");

                                        // Get the h2 tags — ToC entries
                    let headers = document.getElementsByTagName("h2");
                    if ( headers.length < 2) return;
                    
                     
                    if (tagetList.length < 1) return
                    let target = null;
                    for (i =0; i<tagetList.length;i++){
                      
                        if ( tagetList[i].children.length > 0 ) {
                            
                            if ( tagetList[i].children[0].classList.contains("header")) {
                                target = tagetList[i];
                                
                                break;
                            }
                        }
                    }
                    if ( target == null) return;

                    // Create a list for the ToC entries
                    let tocList = document.createElement("ul"); 

                    // Add a begin if missing a first header
                    if ( !(target.nextElementSibling.tagName == "H2" || target.nextElementSibling.tagName == "h2") )   {
                        let tocListItem = document.createElement("li");    
                        let tocEntry = document.createElement("a");
                        
                        tocEntry.setAttribute("href","#");
                        tocEntry.innerText="Début";
                     
                        tocListItem.appendChild(tocEntry);
                        tocList.appendChild(tocListItem);
                    }
                    
                                         

                     

                     
                     // For each h3
                     for (i = 0; i < headers.length; i++){
                     
                        // Create an id
                        //name = "h"+i;
                        //headers[i].id=name;
                     
                        // a list item for the entry
                        let tocListItem = document.createElement("li");    
                        let tocEntry = document.createElement("a");
                        
                        tocEntry.setAttribute("href",headers[i].children[0].href);
                        tocEntry.innerText=headers[i].innerText;
                     
                        tocListItem.appendChild(tocEntry);
                        tocList.appendChild(tocListItem);
                     }
                     target.parentNode.insertBefore(tocList, target.nextSibling);
                     //toc.insertBefore(tocList);
                }
                buildToc();

                
          </script>

    </body>
</html>
